function uiCodemirrorDirective($timeout, uiCodemirrorConfig) {
    function postLink(scope, iElement, iAttrs, ngModel) {
        var codemirrorOptions = angular.extend({
            value: iElement.text()
        }, uiCodemirrorConfig.codemirror || {}, scope.$eval(iAttrs.uiCodemirror), scope.$eval(iAttrs.uiCodemirrorOpts))
          , codemirror = newCodemirrorEditor(iElement, codemirrorOptions);
        configOptionsWatcher(codemirror, iAttrs.uiCodemirror || iAttrs.uiCodemirrorOpts, scope),
        configNgModelLink(codemirror, ngModel, scope),
        configUiRefreshAttribute(codemirror, iAttrs.uiRefresh, scope),
        scope.$on("CodeMirror", function(event, callback) {
            if (!angular.isFunction(callback))
                throw new Error("the CodeMirror event requires a callback function");
            callback(codemirror)
        }),
        angular.isFunction(codemirrorOptions.onLoad) && codemirrorOptions.onLoad(codemirror)
    }
    function newCodemirrorEditor(iElement, codemirrorOptions) {
        var codemirrot;
        return "TEXTAREA" === iElement[0].tagName ? codemirrot = window.CodeMirror.fromTextArea(iElement[0], codemirrorOptions) : (iElement.html(""),
        codemirrot = new window.CodeMirror(function(cm_el) {
            iElement.append(cm_el)
        }
        ,codemirrorOptions)),
        codemirrot
    }
    function configOptionsWatcher(codemirrot, uiCodemirrorAttr, scope) {
        function updateOptions(newValues, oldValue) {
            angular.isObject(newValues) && codemirrorDefaultsKeys.forEach(function(key) {
                if (newValues.hasOwnProperty(key)) {
                    if (oldValue && newValues[key] === oldValue[key])
                        return;
                    codemirrot.setOption(key, newValues[key])
                }
            })
        }
        if (uiCodemirrorAttr) {
            var codemirrorDefaultsKeys = Object.keys(window.CodeMirror.defaults);
            scope.$watch(uiCodemirrorAttr, updateOptions, !0)
        }
    }
    function configNgModelLink(codemirror, ngModel, scope) {
        ngModel && (ngModel.$formatters.push(function(value) {
            if (angular.isUndefined(value) || null === value)
                return "";
            if (angular.isObject(value) || angular.isArray(value))
                throw new Error("ui-codemirror cannot use an object or an array as a model");
            return value
        }),
        ngModel.$render = function() {
            var safeViewValue = ngModel.$viewValue || "";
            codemirror.setValue(safeViewValue)
        }
        ,
        codemirror.on("change", function(instance) {
            var newValue = instance.getValue();
            newValue !== ngModel.$viewValue && scope.$evalAsync(function() {
                ngModel.$setViewValue(newValue)
            })
        }))
    }
    function configUiRefreshAttribute(codeMirror, uiRefreshAttr, scope) {
        uiRefreshAttr && scope.$watch(uiRefreshAttr, function(newVal, oldVal) {
            newVal !== oldVal && $timeout(function() {
                codeMirror.refresh()
            })
        })
    }
    return {
        restrict: "EA",
        require: "?ngModel",
        compile: function() {
            if (angular.isUndefined(window.CodeMirror))
                throw new Error("ui-codemirror need CodeMirror to work... (o rly?)");
            return postLink
        }
    }
}
if (function(global, factory) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
        if (!w.document)
            throw new Error("jQuery requires a window with a document");
        return factory(w)
    }
    : factory(global)
}("undefined" != typeof window ? window : this, function(window, noGlobal) {
    "use strict";
    function DOMEval(code, doc) {
        doc = doc || document;
        var script = doc.createElement("script");
        script.text = code,
        doc.head.appendChild(script).parentNode.removeChild(script)
    }
    function isArrayLike(obj) {
        var length = !!obj && "length"in obj && obj.length
          , type = jQuery.type(obj);
        return "function" !== type && !jQuery.isWindow(obj) && ("array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj)
    }
    function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
    }
    function winnow(elements, qualifier, not) {
        return jQuery.isFunction(qualifier) ? jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not
        }) : qualifier.nodeType ? jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not
        }) : "string" != typeof qualifier ? jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not
        }) : risSimple.test(qualifier) ? jQuery.filter(qualifier, elements, not) : (qualifier = jQuery.filter(qualifier, elements),
        jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not && 1 === elem.nodeType
        }))
    }
    function sibling(cur, dir) {
        for (; (cur = cur[dir]) && 1 !== cur.nodeType; )
            ;
        return cur
    }
    function createOptions(options) {
        var object = {};
        return jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = !0
        }),
        object
    }
    function Identity(v) {
        return v
    }
    function Thrower(ex) {
        throw ex
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            value && jQuery.isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && jQuery.isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.apply(void 0, [value].slice(noValue))
        } catch (value) {
            reject.apply(void 0, [value])
        }
    }
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed),
        window.removeEventListener("load", completed),
        jQuery.ready()
    }
    function Data() {
        this.expando = jQuery.expando + Data.uid++
    }
    function getData(data) {
        return "true" === data || "false" !== data && ("null" === data ? null : data === +data + "" ? +data : rbrace.test(data) ? JSON.parse(data) : data)
    }
    function dataAttr(elem, key, data) {
        var name;
        if (void 0 === data && 1 === elem.nodeType)
            if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(),
            "string" == typeof (data = elem.getAttribute(name))) {
                try {
                    data = getData(data)
                } catch (e) {}
                dataUser.set(elem, key, data)
            } else
                data = void 0;
        return data
    }
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur()
        }
        : function() {
            return jQuery.css(elem, prop, "")
        }
        , initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3],
            valueParts = valueParts || [],
            initialInUnit = +initial || 1;
            do {
                scale = scale || ".5",
                initialInUnit /= scale,
                jQuery.style(elem, prop, initialInUnit + unit)
            } while (scale !== (scale = currentValue() / initial) && 1 !== scale && --maxIterations)
        }
        return valueParts && (initialInUnit = +initialInUnit || +initial || 0,
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2],
        tween && (tween.unit = unit,
        tween.start = initialInUnit,
        tween.end = adjusted)),
        adjusted
    }
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        return display || (temp = doc.body.appendChild(doc.createElement(nodeName)),
        display = jQuery.css(temp, "display"),
        temp.parentNode.removeChild(temp),
        "none" === display && (display = "block"),
        defaultDisplayMap[nodeName] = display,
        display)
    }
    function showHide(elements, show) {
        for (var display, elem, values = [], index = 0, length = elements.length; index < length; index++)
            elem = elements[index],
            elem.style && (display = elem.style.display,
            show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null,
            values[index] || (elem.style.display = "")),
            "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none",
            dataPriv.set(elem, "display", display)));
        for (index = 0; index < length; index++)
            null != values[index] && (elements[index].style.display = values[index]);
        return elements
    }
    function getAll(context, tag) {
        var ret;
        return ret = void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : void 0 !== context.querySelectorAll ? context.querySelectorAll(tag || "*") : [],
        void 0 === tag || tag && nodeName(context, tag) ? jQuery.merge([context], ret) : ret
    }
    function setGlobalEval(elems, refElements) {
        for (var i = 0, l = elems.length; i < l; i++)
            dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"))
    }
    function buildFragment(elems, context, scripts, selection, ignored) {
        for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; i < l; i++)
            if ((elem = elems[i]) || 0 === elem)
                if ("object" === jQuery.type(elem))
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                else if (rhtml.test(elem)) {
                    for (tmp = tmp || fragment.appendChild(context.createElement("div")),
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
                    wrap = wrapMap[tag] || wrapMap._default,
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2],
                    j = wrap[0]; j--; )
                        tmp = tmp.lastChild;
                    jQuery.merge(nodes, tmp.childNodes),
                    tmp = fragment.firstChild,
                    tmp.textContent = ""
                } else
                    nodes.push(context.createTextNode(elem));
        for (fragment.textContent = "",
        i = 0; elem = nodes[i++]; )
            if (selection && jQuery.inArray(elem, selection) > -1)
                ignored && ignored.push(elem);
            else if (contains = jQuery.contains(elem.ownerDocument, elem),
            tmp = getAll(fragment.appendChild(elem), "script"),
            contains && setGlobalEval(tmp),
            scripts)
                for (j = 0; elem = tmp[j++]; )
                    rscriptType.test(elem.type || "") && scripts.push(elem);
        return fragment
    }
    function returnTrue() {
        return !0
    }
    function returnFalse() {
        return !1
    }
    function safeActiveElement() {
        try {
            return document.activeElement
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if ("object" == typeof types) {
            "string" != typeof selector && (data = data || selector,
            selector = void 0);
            for (type in types)
                on(elem, type, selector, data, types[type], one);
            return elem
        }
        if (null == data && null == fn ? (fn = selector,
        data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data,
        data = void 0) : (fn = data,
        data = selector,
        selector = void 0)),
        !1 === fn)
            fn = returnFalse;
        else if (!fn)
            return elem;
        return 1 === one && (origFn = fn,
        fn = function(event) {
            return jQuery().off(event),
            origFn.apply(this, arguments)
        }
        ,
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)),
        elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector)
        })
    }
    function manipulationTarget(elem, content) {
        return nodeName(elem, "table") && nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? jQuery(">tbody", elem)[0] || elem : elem
    }
    function disableScript(elem) {
        return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type,
        elem
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        return match ? elem.type = match[1] : elem.removeAttribute("type"),
        elem
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (1 === dest.nodeType) {
            if (dataPriv.hasData(src) && (pdataOld = dataPriv.access(src),
            pdataCur = dataPriv.set(dest, pdataOld),
            events = pdataOld.events)) {
                delete pdataCur.handle,
                pdataCur.events = {};
                for (type in events)
                    for (i = 0,
                    l = events[type].length; i < l; i++)
                        jQuery.event.add(dest, type, events[type][i])
            }
            dataUser.hasData(src) && (udataOld = dataUser.access(src),
            udataCur = jQuery.extend({}, udataOld),
            dataUser.set(dest, udataCur))
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : "input" !== nodeName && "textarea" !== nodeName || (dest.defaultValue = src.defaultValue)
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value))
            return collection.each(function(index) {
                var self = collection.eq(index);
                isFunction && (args[0] = value.call(this, index, self.html())),
                domManip(self, args, callback, ignored)
            });
        if (l && (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored),
        first = fragment.firstChild,
        1 === fragment.childNodes.length && (fragment = first),
        first || ignored)) {
            for (scripts = jQuery.map(getAll(fragment, "script"), disableScript),
            hasScripts = scripts.length; i < l; i++)
                node = fragment,
                i !== iNoClone && (node = jQuery.clone(node, !0, !0),
                hasScripts && jQuery.merge(scripts, getAll(node, "script"))),
                callback.call(collection[i], node, i);
            if (hasScripts)
                for (doc = scripts[scripts.length - 1].ownerDocument,
                jQuery.map(scripts, restoreScript),
                i = 0; i < hasScripts; i++)
                    node = scripts[i],
                    rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : DOMEval(node.textContent.replace(rcleanScript, ""), doc))
        }
        return collection
    }
    function remove(elem, selector, keepData) {
        for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++)
            keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)),
            node.parentNode && (keepData && jQuery.contains(node.ownerDocument, node) && setGlobalEval(getAll(node, "script")),
            node.parentNode.removeChild(node));
        return elem
    }
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        return computed = computed || getStyles(elem),
        computed && (ret = computed.getPropertyValue(name) || computed[name],
        "" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)),
        !support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width,
        minWidth = style.minWidth,
        maxWidth = style.maxWidth,
        style.minWidth = style.maxWidth = style.width = ret,
        ret = computed.width,
        style.width = width,
        style.minWidth = minWidth,
        style.maxWidth = maxWidth)),
        void 0 !== ret ? ret + "" : ret
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments)
            }
        }
    }
    function vendorPropName(name) {
        if (name in emptyStyle)
            return name;
        for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--; )
            if ((name = cssPrefixes[i] + capName)in emptyStyle)
                return name
    }
    function finalPropName(name) {
        var ret = jQuery.cssProps[name];
        return ret || (ret = jQuery.cssProps[name] = vendorPropName(name) || name),
        ret
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i, val = 0;
        for (i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0; i < 4; i += 2)
            "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)),
            isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)),
            "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles),
            "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
        return val
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox, styles = getStyles(elem), val = curCSS(elem, name, styles), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
        return rnumnonpx.test(val) ? val : (valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]),
        "auto" === val && (val = elem["offset" + name[0].toUpperCase() + name.slice(1)]),
        (val = parseFloat(val) || 0) + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px")
    }
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem,options,prop,end,easing)
    }
    function schedule() {
        inProgress && (!1 === document.hidden && window.requestAnimationFrame ? window.requestAnimationFrame(schedule) : window.setTimeout(schedule, jQuery.fx.interval),
        jQuery.fx.tick())
    }
    function createFxNow() {
        return window.setTimeout(function() {
            fxNow = void 0
        }),
        fxNow = jQuery.now()
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        for (includeWidth = includeWidth ? 1 : 0; i < 4; i += 2 - includeWidth)
            which = cssExpand[i],
            attrs["margin" + which] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type),
        attrs
    }
    function createTween(value, prop, animation) {
        for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; index < length; index++)
            if (tween = collection[index].call(animation, prop, value))
                return tween
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width"in props || "height"in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        opts.queue || (hooks = jQuery._queueHooks(elem, "fx"),
        null == hooks.unqueued && (hooks.unqueued = 0,
        oldfire = hooks.empty.fire,
        hooks.empty.fire = function() {
            hooks.unqueued || oldfire()
        }
        ),
        hooks.unqueued++,
        anim.always(function() {
            anim.always(function() {
                hooks.unqueued--,
                jQuery.queue(elem, "fx").length || hooks.empty.fire()
            })
        }));
        for (prop in props)
            if (value = props[prop],
            rfxtypes.test(value)) {
                if (delete props[prop],
                toggle = toggle || "toggle" === value,
                value === (hidden ? "hide" : "show")) {
                    if ("show" !== value || !dataShow || void 0 === dataShow[prop])
                        continue;
                    hidden = !0
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
            }
        if ((propTween = !jQuery.isEmptyObject(props)) || !jQuery.isEmptyObject(orig)) {
            isBox && 1 === elem.nodeType && (opts.overflow = [style.overflow, style.overflowX, style.overflowY],
            restoreDisplay = dataShow && dataShow.display,
            null == restoreDisplay && (restoreDisplay = dataPriv.get(elem, "display")),
            display = jQuery.css(elem, "display"),
            "none" === display && (restoreDisplay ? display = restoreDisplay : (showHide([elem], !0),
            restoreDisplay = elem.style.display || restoreDisplay,
            display = jQuery.css(elem, "display"),
            showHide([elem]))),
            ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done(function() {
                style.display = restoreDisplay
            }),
            null == restoreDisplay && (display = style.display,
            restoreDisplay = "none" === display ? "" : display)),
            style.display = "inline-block")),
            opts.overflow && (style.overflow = "hidden",
            anim.always(function() {
                style.overflow = opts.overflow[0],
                style.overflowX = opts.overflow[1],
                style.overflowY = opts.overflow[2]
            })),
            propTween = !1;
            for (prop in orig)
                propTween || (dataShow ? "hidden"in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {
                    display: restoreDisplay
                }),
                toggle && (dataShow.hidden = !hidden),
                hidden && showHide([elem], !0),
                anim.done(function() {
                    hidden || showHide([elem]),
                    dataPriv.remove(elem, "fxshow");
                    for (prop in orig)
                        jQuery.style(elem, prop, orig[prop])
                })),
                propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim),
                prop in dataShow || (dataShow[prop] = propTween.start,
                hidden && (propTween.end = propTween.start,
                propTween.start = 0))
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props)
            if (name = jQuery.camelCase(index),
            easing = specialEasing[name],
            value = props[index],
            Array.isArray(value) && (easing = value[1],
            value = props[index] = value[0]),
            index !== name && (props[name] = value,
            delete props[index]),
            (hooks = jQuery.cssHooks[name]) && "expand"in hooks) {
                value = hooks.expand(value),
                delete props[name];
                for (index in value)
                    index in props || (props[index] = value[index],
                    specialEasing[index] = easing)
            } else
                specialEasing[name] = easing
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem
        }), tick = function() {
            if (stopped)
                return !1;
            for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; index < length; index++)
                animation.tweens[index].run(percent);
            return deferred.notifyWith(elem, [animation, percent, remaining]),
            percent < 1 && length ? remaining : (length || deferred.notifyWith(elem, [animation, 1, 0]),
            deferred.resolveWith(elem, [animation]),
            !1)
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(!0, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                return animation.tweens.push(tween),
                tween
            },
            stop: function(gotoEnd) {
                var index = 0
                  , length = gotoEnd ? animation.tweens.length : 0;
                if (stopped)
                    return this;
                for (stopped = !0; index < length; index++)
                    animation.tweens[index].run(1);
                return gotoEnd ? (deferred.notifyWith(elem, [animation, 1, 0]),
                deferred.resolveWith(elem, [animation, gotoEnd])) : deferred.rejectWith(elem, [animation, gotoEnd]),
                this
            }
        }), props = animation.props;
        for (propFilter(props, animation.opts.specialEasing); index < length; index++)
            if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts))
                return jQuery.isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result)),
                result;
        return jQuery.map(props, createTween, animation),
        jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation),
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always),
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })),
        animation
    }
    function stripAndCollapse(value) {
        return (value.match(rnothtmlwhite) || []).join(" ")
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || ""
    }
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj))
            jQuery.each(obj, function(i, v) {
                traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add)
            });
        else if (traditional || "object" !== jQuery.type(obj))
            add(prefix, obj);
        else
            for (name in obj)
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
    }
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            "string" != typeof dataTypeExpression && (func = dataTypeExpression,
            dataTypeExpression = "*");
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (jQuery.isFunction(func))
                for (; dataType = dataTypes[i++]; )
                    "+" === dataType[0] ? (dataType = dataType.slice(1) || "*",
                    (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
        }
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        function inspect(dataType) {
            var selected;
            return inspected[dataType] = !0,
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport),
                inspect(dataTypeOrTransport),
                !1)
            }),
            selected
        }
        var inspected = {}
          , seekingTransport = structure === transports;
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src)
            void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep),
        target
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; )
            dataTypes.shift(),
            void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
        if (ct)
            for (type in contents)
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break
                }
        if (dataTypes[0]in responses)
            finalDataType = dataTypes[0];
        else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break
                }
                firstDataType || (firstDataType = type)
            }
            finalDataType = finalDataType || firstDataType
        }
        if (finalDataType)
            return finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType),
            responses[finalDataType]
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1])
            for (conv in s.converters)
                converters[conv.toLowerCase()] = s.converters[conv];
        for (current = dataTypes.shift(); current; )
            if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response),
            !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)),
            prev = current,
            current = dataTypes.shift())
                if ("*" === current)
                    current = prev;
                else if ("*" !== prev && prev !== current) {
                    if (!(conv = converters[prev + " " + current] || converters["* " + current]))
                        for (conv2 in converters)
                            if (tmp = conv2.split(" "),
                            tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                                !0 === conv ? conv = converters[conv2] : !0 !== converters[conv2] && (current = tmp[0],
                                dataTypes.unshift(tmp[1]));
                                break
                            }
                    if (!0 !== conv)
                        if (conv && s.throws)
                            response = conv(response);
                        else
                            try {
                                response = conv(response)
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                }
                            }
                }
        return {
            state: "success",
            data: response
        }
    }
    var arr = []
      , document = window.document
      , getProto = Object.getPrototypeOf
      , slice = arr.slice
      , concat = arr.concat
      , push = arr.push
      , indexOf = arr.indexOf
      , class2type = {}
      , toString = class2type.toString
      , hasOwn = class2type.hasOwnProperty
      , fnToString = hasOwn.toString
      , ObjectFunctionString = fnToString.call(Object)
      , support = {}
      , jQuery = function(selector, context) {
        return new jQuery.fn.init(selector,context)
    }
      , rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g
      , rmsPrefix = /^-ms-/
      , rdashAlpha = /-([a-z])/g
      , fcamelCase = function(all, letter) {
        return letter.toUpperCase()
    };
    jQuery.fn = jQuery.prototype = {
        jquery: "3.2.1",
        constructor: jQuery,
        length: 0,
        toArray: function() {
            return slice.call(this)
        },
        get: function(num) {
            return null == num ? slice.call(this) : num < 0 ? this[num + this.length] : this[num]
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            return ret.prevObject = this,
            ret
        },
        each: function(callback) {
            return jQuery.each(this, callback)
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem)
            }))
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        eq: function(i) {
            var len = this.length
              , j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
        },
        end: function() {
            return this.prevObject || this.constructor()
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    },
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
        for ("boolean" == typeof target && (deep = target,
        target = arguments[i] || {},
        i++),
        "object" == typeof target || jQuery.isFunction(target) || (target = {}),
        i === length && (target = this,
        i--); i < length; i++)
            if (null != (options = arguments[i]))
                for (name in options)
                    src = target[name],
                    copy = options[name],
                    target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1,
                    clone = src && Array.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {},
                    target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        return target
    }
    ,
    jQuery.extend({
        expando: "jQuery" + ("3.2.1" + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(msg) {
            throw new Error(msg)
        },
        noop: function() {},
        isFunction: function(obj) {
            return "function" === jQuery.type(obj)
        },
        isWindow: function(obj) {
            return null != obj && obj === obj.window
        },
        isNumeric: function(obj) {
            var type = jQuery.type(obj);
            return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj))
        },
        isPlainObject: function(obj) {
            var proto, Ctor;
            return !(!obj || "[object Object]" !== toString.call(obj)) && (!(proto = getProto(obj)) || "function" == typeof (Ctor = hasOwn.call(proto, "constructor") && proto.constructor) && fnToString.call(Ctor) === ObjectFunctionString)
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj)
                return !1;
            return !0
        },
        type: function(obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj
        },
        globalEval: function(code) {
            DOMEval(code)
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj))
                for (length = obj.length; i < length && !1 !== callback.call(obj[i], i, obj[i]); i++)
                    ;
            else
                for (i in obj)
                    if (!1 === callback.call(obj[i], i, obj[i]))
                        break;
            return obj
        },
        trim: function(text) {
            return null == text ? "" : (text + "").replace(rtrim, "")
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : push.call(ret, arr)),
            ret
        },
        inArray: function(elem, arr, i) {
            return null == arr ? -1 : indexOf.call(arr, elem, i)
        },
        merge: function(first, second) {
            for (var len = +second.length, j = 0, i = first.length; j < len; j++)
                first[i++] = second[j];
            return first.length = i,
            first
        },
        grep: function(elems, callback, invert) {
            for (var matches = [], i = 0, length = elems.length, callbackExpect = !invert; i < length; i++)
                !callback(elems[i], i) !== callbackExpect && matches.push(elems[i]);
            return matches
        },
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems))
                for (length = elems.length; i < length; i++)
                    null != (value = callback(elems[i], i, arg)) && ret.push(value);
            else
                for (i in elems)
                    null != (value = callback(elems[i], i, arg)) && ret.push(value);
            return concat.apply([], ret)
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if ("string" == typeof context && (tmp = fn[context],
            context = fn,
            fn = tmp),
            jQuery.isFunction(fn))
                return args = slice.call(arguments, 2),
                proxy = function() {
                    return fn.apply(context || this, args.concat(slice.call(arguments)))
                }
                ,
                proxy.guid = fn.guid = fn.guid || jQuery.guid++,
                proxy
        },
        now: Date.now,
        support: support
    }),
    "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]),
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase()
    });
    var Sizzle = function(window) {
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            if (results = results || [],
            "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType)
                return results;
            if (!seed && ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context),
            context = context || document,
            documentIsHTML)) {
                if (11 !== nodeType && (match = rquickExpr.exec(selector)))
                    if (m = match[1]) {
                        if (9 === nodeType) {
                            if (!(elem = context.getElementById(m)))
                                return results;
                            if (elem.id === m)
                                return results.push(elem),
                                results
                        } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m)
                            return results.push(elem),
                            results
                    } else {
                        if (match[2])
                            return push.apply(results, context.getElementsByTagName(selector)),
                            results;
                        if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName)
                            return push.apply(results, context.getElementsByClassName(m)),
                            results
                    }
                if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    if (1 !== nodeType)
                        newContext = context,
                        newSelector = selector;
                    else if ("object" !== context.nodeName.toLowerCase()) {
                        for ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando),
                        groups = tokenize(selector),
                        i = groups.length; i--; )
                            groups[i] = "#" + nid + " " + toSelector(groups[i]);
                        newSelector = groups.join(","),
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context
                    }
                    if (newSelector)
                        try {
                            return push.apply(results, newContext.querySelectorAll(newSelector)),
                            results
                        } catch (qsaError) {} finally {
                            nid === expando && context.removeAttribute("id")
                        }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed)
        }
        function createCache() {
            function cache(key, value) {
                return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()],
                cache[key + " "] = value
            }
            var keys = [];
            return cache
        }
        function markFunction(fn) {
            return fn[expando] = !0,
            fn
        }
        function assert(fn) {
            var el = document.createElement("fieldset");
            try {
                return !!fn(el)
            } catch (e) {
                return !1
            } finally {
                el.parentNode && el.parentNode.removeChild(el),
                el = null
            }
        }
        function addHandle(attrs, handler) {
            for (var arr = attrs.split("|"), i = arr.length; i--; )
                Expr.attrHandle[arr[i]] = handler
        }
        function siblingCheck(a, b) {
            var cur = b && a
              , diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
            if (diff)
                return diff;
            if (cur)
                for (; cur = cur.nextSibling; )
                    if (cur === b)
                        return -1;
            return a ? 1 : -1
        }
        function createDisabledPseudo(disabled) {
            return function(elem) {
                return "form"in elem ? elem.parentNode && !1 === elem.disabled ? "label"in elem ? "label"in elem.parentNode ? elem.parentNode.disabled === disabled : elem.disabled === disabled : elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled : elem.disabled === disabled : "label"in elem && elem.disabled === disabled
            }
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                return argument = +argument,
                markFunction(function(seed, matches) {
                    for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; )
                        seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                })
            })
        }
        function testContext(context) {
            return context && void 0 !== context.getElementsByTagName && context
        }
        function setFilters() {}
        function toSelector(tokens) {
            for (var i = 0, len = tokens.length, selector = ""; i < len; i++)
                selector += tokens[i].value;
            return selector
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir
              , skip = combinator.next
              , key = skip || dir
              , checkNonElements = base && "parentNode" === key
              , doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                for (; elem = elem[dir]; )
                    if (1 === elem.nodeType || checkNonElements)
                        return matcher(elem, context, xml);
                return !1
            }
            : function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                    for (; elem = elem[dir]; )
                        if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml))
                            return !0
                } else
                    for (; elem = elem[dir]; )
                        if (1 === elem.nodeType || checkNonElements)
                            if (outerCache = elem[expando] || (elem[expando] = {}),
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {}),
                            skip && skip === elem.nodeName.toLowerCase())
                                elem = elem[dir] || elem;
                            else {
                                if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName)
                                    return newCache[2] = oldCache[2];
                                if (uniqueCache[key] = newCache,
                                newCache[2] = matcher(elem, context, xml))
                                    return !0
                            }
                return !1
            }
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                for (var i = matchers.length; i--; )
                    if (!matchers[i](elem, context, xml))
                        return !1;
                return !0
            }
            : matchers[0]
        }
        function multipleContexts(selector, contexts, results) {
            for (var i = 0, len = contexts.length; i < len; i++)
                Sizzle(selector, contexts[i], results);
            return results
        }
        function condense(unmatched, map, filter, context, xml) {
            for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; i < len; i++)
                (elem = unmatched[i]) && (filter && !filter(elem, context, xml) || (newUnmatched.push(elem),
                mapped && map.push(i)));
            return newUnmatched
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)),
            postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)),
            markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher && matcher(matcherIn, matcherOut, context, xml),
                postFilter)
                    for (temp = condense(matcherOut, postMap),
                    postFilter(temp, [], context, xml),
                    i = temp.length; i--; )
                        (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            for (temp = [],
                            i = matcherOut.length; i--; )
                                (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml)
                        }
                        for (i = matcherOut.length; i--; )
                            (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                    }
                } else
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut),
                    postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
            })
        }
        function matcherFromTokens(tokens) {
            for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext
            }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1
            }, implicitRelative, !0), matchers = [function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                return checkContext = null,
                ret
            }
            ]; i < len; i++)
                if (matcher = Expr.relative[tokens[i].type])
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                else {
                    if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches),
                    matcher[expando]) {
                        for (j = ++i; j < len && !Expr.relative[tokens[j].type]; j++)
                            ;
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: " " === tokens[i - 2].type ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
                    }
                    matchers.push(matcher)
                }
            return elementMatcher(matchers)
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0
              , byElement = elementMatchers.length > 0
              , superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                for (outermost && (outermostContext = context === document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                    if (byElement && elem) {
                        for (j = 0,
                        context || elem.ownerDocument === document || (setDocument(elem),
                        xml = !documentIsHTML); matcher = elementMatchers[j++]; )
                            if (matcher(elem, context || document, xml)) {
                                results.push(elem);
                                break
                            }
                        outermost && (dirruns = dirrunsUnique)
                    }
                    bySet && ((elem = !matcher && elem) && matchedCount--,
                    seed && unmatched.push(elem))
                }
                if (matchedCount += i,
                bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j++]; )
                        matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        if (matchedCount > 0)
                            for (; i--; )
                                unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                        setMatched = condense(setMatched)
                    }
                    push.apply(results, setMatched),
                    outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                }
                return outermost && (dirruns = dirrunsUnique,
                outermostContext = contextBackup),
                unmatched
            };
            return bySet ? markFunction(superMatcher) : superMatcher
        }
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date, preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            return a === b && (hasDuplicate = !0),
            0
        }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            for (var i = 0, len = list.length; i < len; i++)
                if (list[i] === elem)
                    return i;
            return -1
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+","g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$","g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]","g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)","i"),
            bool: new RegExp("^(?:" + booleans + ")$","i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)","i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)","ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320)
        }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            return asCodePoint ? "\0" === ch ? "�" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch
        }, unloadHandler = function() {
            setDocument()
        }, disabledAncestor = addCombinator(function(elem) {
            return !0 === elem.disabled && ("form"in elem || "label"in elem)
        }, {
            dir: "parentNode",
            next: "legend"
        });
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes),
            arr[preferredDoc.childNodes.length].nodeType
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els))
                }
                : function(target, els) {
                    for (var j = target.length, i = 0; target[j++] = els[i++]; )
                        ;
                    target.length = j - 1
                }
            }
        }
        support = Sizzle.support = {},
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return !!documentElement && "HTML" !== documentElement.nodeName
        }
        ,
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc,
            docElem = document.documentElement,
            documentIsHTML = !isXML(document),
            preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)),
            support.attributes = assert(function(el) {
                return el.className = "i",
                !el.getAttribute("className")
            }),
            support.getElementsByTagName = assert(function(el) {
                return el.appendChild(document.createComment("")),
                !el.getElementsByTagName("*").length
            }),
            support.getElementsByClassName = rnative.test(document.getElementsByClassName),
            support.getById = assert(function(el) {
                return docElem.appendChild(el).id = expando,
                !document.getElementsByName || !document.getElementsByName(expando).length
            }),
            support.getById ? (Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    return elem.getAttribute("id") === attrId
                }
            }
            ,
            Expr.find.ID = function(id, context) {
                if (void 0 !== context.getElementById && documentIsHTML) {
                    var elem = context.getElementById(id);
                    return elem ? [elem] : []
                }
            }
            ) : (Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    var node = void 0 !== elem.getAttributeNode && elem.getAttributeNode("id");
                    return node && node.value === attrId
                }
            }
            ,
            Expr.find.ID = function(id, context) {
                if (void 0 !== context.getElementById && documentIsHTML) {
                    var node, i, elems, elem = context.getElementById(id);
                    if (elem) {
                        if ((node = elem.getAttributeNode("id")) && node.value === id)
                            return [elem];
                        for (elems = context.getElementsByName(id),
                        i = 0; elem = elems[i++]; )
                            if ((node = elem.getAttributeNode("id")) && node.value === id)
                                return [elem]
                    }
                    return []
                }
            }
            ),
            Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                return void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0
            }
            : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if ("*" === tag) {
                    for (; elem = results[i++]; )
                        1 === elem.nodeType && tmp.push(elem);
                    return tmp
                }
                return results
            }
            ,
            Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                if (void 0 !== context.getElementsByClassName && documentIsHTML)
                    return context.getElementsByClassName(className)
            }
            ,
            rbuggyMatches = [],
            rbuggyQSA = [],
            (support.qsa = rnative.test(document.querySelectorAll)) && (assert(function(el) {
                docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>",
                el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"),
                el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"),
                el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="),
                el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"),
                el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]")
            }),
            assert(function(el) {
                el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var input = document.createElement("input");
                input.setAttribute("type", "hidden"),
                el.appendChild(input).setAttribute("name", "D"),
                el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="),
                2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"),
                docElem.appendChild(el).disabled = !0,
                2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"),
                el.querySelectorAll("*,:x"),
                rbuggyQSA.push(",.*:")
            })),
            (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(el) {
                support.disconnectedMatch = matches.call(el, "*"),
                matches.call(el, "[s!='']:x"),
                rbuggyMatches.push("!=", pseudos)
            }),
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")),
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")),
            hasCompare = rnative.test(docElem.compareDocumentPosition),
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = 9 === a.nodeType ? a.documentElement : a
                  , bup = b && b.parentNode;
                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
            }
            : function(a, b) {
                if (b)
                    for (; b = b.parentNode; )
                        if (b === a)
                            return !0;
                return !1
            }
            ,
            sortOrder = hasCompare ? function(a, b) {
                if (a === b)
                    return hasDuplicate = !0,
                    0;
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return compare || (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1,
                1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1)
            }
            : function(a, b) {
                if (a === b)
                    return hasDuplicate = !0,
                    0;
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup)
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                if (aup === bup)
                    return siblingCheck(a, b);
                for (cur = a; cur = cur.parentNode; )
                    ap.unshift(cur);
                for (cur = b; cur = cur.parentNode; )
                    bp.unshift(cur);
                for (; ap[i] === bp[i]; )
                    i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
            }
            ,
            document) : document
        }
        ,
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements)
        }
        ,
        Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem),
            expr = expr.replace(rattributeQuotes, "='$1']"),
            support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr)))
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType)
                        return ret
                } catch (e) {}
            return Sizzle(expr, document, null, [elem]).length > 0
        }
        ,
        Sizzle.contains = function(context, elem) {
            return (context.ownerDocument || context) !== document && setDocument(context),
            contains(context, elem)
        }
        ,
        Sizzle.attr = function(elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()]
              , val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        }
        ,
        Sizzle.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape)
        }
        ,
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg)
        }
        ,
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            if (hasDuplicate = !support.detectDuplicates,
            sortInput = !support.sortStable && results.slice(0),
            results.sort(sortOrder),
            hasDuplicate) {
                for (; elem = results[i++]; )
                    elem === results[i] && (j = duplicates.push(i));
                for (; j--; )
                    results.splice(duplicates[j], 1)
            }
            return sortInput = null,
            results
        }
        ,
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (nodeType) {
                if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                    if ("string" == typeof elem.textContent)
                        return elem.textContent;
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                        ret += getText(elem)
                } else if (3 === nodeType || 4 === nodeType)
                    return elem.nodeValue
            } else
                for (; node = elem[i++]; )
                    ret += getText(node);
            return ret
        }
        ,
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    return match[1] = match[1].replace(runescape, funescape),
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape),
                    "~=" === match[2] && (match[3] = " " + match[3] + " "),
                    match.slice(0, 4)
                },
                CHILD: function(match) {
                    return match[1] = match[1].toLowerCase(),
                    "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]),
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])),
                    match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]),
                    match
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess),
                    match[2] = unquoted.slice(0, excess)),
                    match.slice(0, 3))
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return "*" === nodeNameSelector ? function() {
                        return !0
                    }
                    : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                    }
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test("string" == typeof elem.className && elem.className || void 0 !== elem.getAttribute && elem.getAttribute("class") || "")
                    })
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        return null == result ? "!=" === operator : !operator || (result += "",
                        "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator && (result === check || result.slice(0, check.length + 1) === check + "-"))
                    }
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = "nth" !== type.slice(0, 3)
                      , forward = "last" !== type.slice(-4)
                      , ofType = "of-type" === what;
                    return 1 === first && 0 === last ? function(elem) {
                        return !!elem.parentNode
                    }
                    : function(elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = !1;
                        if (parent) {
                            if (simple) {
                                for (; dir; ) {
                                    for (node = elem; node = node[dir]; )
                                        if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType)
                                            return !1;
                                    start = dir = "only" === type && !start && "nextSibling"
                                }
                                return !0
                            }
                            if (start = [forward ? parent.firstChild : parent.lastChild],
                            forward && useCache) {
                                for (node = parent,
                                outerCache = node[expando] || (node[expando] = {}),
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}),
                                cache = uniqueCache[type] || [],
                                nodeIndex = cache[0] === dirruns && cache[1],
                                diff = nodeIndex && cache[2],
                                node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); )
                                    if (1 === node.nodeType && ++diff && node === elem) {
                                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                                        break
                                    }
                            } else if (useCache && (node = elem,
                            outerCache = node[expando] || (node[expando] = {}),
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}),
                            cache = uniqueCache[type] || [],
                            nodeIndex = cache[0] === dirruns && cache[1],
                            diff = nodeIndex),
                            !1 === diff)
                                for (; (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && (outerCache = node[expando] || (node[expando] = {}),
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}),
                                uniqueCache[type] = [dirruns, diff]),
                                node !== elem)); )
                                    ;
                            return (diff -= last) === first || diff % first == 0 && diff / first >= 0
                        }
                    }
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument],
                    Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                        for (var idx, matched = fn(seed, argument), i = matched.length; i--; )
                            idx = indexOf(seed, matched[i]),
                            seed[idx] = !(matches[idx] = matched[i])
                    }) : function(elem) {
                        return fn(elem, 0, args)
                    }
                    ) : fn
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = []
                      , results = []
                      , matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; )
                            (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                    }) : function(elem, context, xml) {
                        return input[0] = elem,
                        matcher(input, null, xml, results),
                        input[0] = null,
                        !results.pop()
                    }
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0
                    }
                }),
                contains: markFunction(function(text) {
                    return text = text.replace(runescape, funescape),
                    function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                    }
                }),
                lang: markFunction(function(lang) {
                    return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang),
                    lang = lang.replace(runescape, funescape).toLowerCase(),
                    function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))
                                return (elemLang = elemLang.toLowerCase()) === lang || 0 === elemLang.indexOf(lang + "-")
                        } while ((elem = elem.parentNode) && 1 === elem.nodeType);
                        return !1
                    }
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id
                },
                root: function(elem) {
                    return elem === docElem
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                },
                enabled: createDisabledPseudo(!1),
                disabled: createDisabledPseudo(!0),
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                },
                selected: function(elem) {
                    return elem.parentNode && elem.parentNode.selectedIndex,
                    !0 === elem.selected
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                        if (elem.nodeType < 6)
                            return !1;
                    return !0
                },
                parent: function(elem) {
                    return !Expr.pseudos.empty(elem)
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName)
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName)
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && "button" === elem.type || "button" === name
                },
                text: function(elem) {
                    var attr;
                    return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
                },
                first: createPositionalPseudo(function() {
                    return [0]
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [length - 1]
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument]
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; i < length; i += 2)
                        matchIndexes.push(i);
                    return matchIndexes
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; i < length; i += 2)
                        matchIndexes.push(i);
                    return matchIndexes
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; --i >= 0; )
                        matchIndexes.push(i);
                    return matchIndexes
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; ++i < length; )
                        matchIndexes.push(i);
                    return matchIndexes
                })
            }
        },
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        })
            Expr.pseudos[i] = function(type) {
                return function(elem) {
                    return "input" === elem.nodeName.toLowerCase() && elem.type === type
                }
            }(i);
        for (i in {
            submit: !0,
            reset: !0
        })
            Expr.pseudos[i] = function(type) {
                return function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return ("input" === name || "button" === name) && elem.type === type
                }
            }(i);
        return setFilters.prototype = Expr.filters = Expr.pseudos,
        Expr.setFilters = new setFilters,
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached)
                return parseOnly ? 0 : cached.slice(0);
            for (soFar = selector,
            groups = [],
            preFilters = Expr.preFilter; soFar; ) {
                matched && !(match = rcomma.exec(soFar)) || (match && (soFar = soFar.slice(match[0].length) || soFar),
                groups.push(tokens = [])),
                matched = !1,
                (match = rcombinators.exec(soFar)) && (matched = match.shift(),
                tokens.push({
                    value: matched,
                    type: match[0].replace(rtrim, " ")
                }),
                soFar = soFar.slice(matched.length));
                for (type in Expr.filter)
                    !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(),
                    tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    }),
                    soFar = soFar.slice(matched.length));
                if (!matched)
                    break
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
        }
        ,
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                for (match || (match = tokenize(selector)),
                i = match.length; i--; )
                    cached = matcherFromTokens(match[i]),
                    cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)),
                cached.selector = selector
            }
            return cached
        }
        ,
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            if (results = results || [],
            1 === match.length) {
                if (tokens = match[0] = match[0].slice(0),
                tokens.length > 2 && "ID" === (token = tokens[0]).type && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                    if (!(context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0]))
                        return results;
                    compiled && (context = context.parentNode),
                    selector = selector.slice(tokens.shift().value.length)
                }
                for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i],
                !Expr.relative[type = token.type]); )
                    if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                        if (tokens.splice(i, 1),
                        !(selector = seed.length && toSelector(tokens)))
                            return push.apply(results, seed),
                            results;
                        break
                    }
            }
            return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context),
            results
        }
        ,
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando,
        support.detectDuplicates = !!hasDuplicate,
        setDocument(),
        support.sortDetached = assert(function(el) {
            return 1 & el.compareDocumentPosition(document.createElement("fieldset"))
        }),
        assert(function(el) {
            return el.innerHTML = "<a href='#'></a>",
            "#" === el.firstChild.getAttribute("href")
        }) || addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML)
                return elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
        }),
        support.attributes && assert(function(el) {
            return el.innerHTML = "<input/>",
            el.firstChild.setAttribute("value", ""),
            "" === el.firstChild.getAttribute("value")
        }) || addHandle("value", function(elem, name, isXML) {
            if (!isXML && "input" === elem.nodeName.toLowerCase())
                return elem.defaultValue
        }),
        assert(function(el) {
            return null == el.getAttribute("disabled")
        }) || addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML)
                return !0 === elem[name] ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        }),
        Sizzle
    }(window);
    jQuery.find = Sizzle,
    jQuery.expr = Sizzle.selectors,
    jQuery.expr[":"] = jQuery.expr.pseudos,
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort,
    jQuery.text = Sizzle.getText,
    jQuery.isXMLDoc = Sizzle.isXML,
    jQuery.contains = Sizzle.contains,
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir, until) {
        for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; )
            if (1 === elem.nodeType) {
                if (truncate && jQuery(elem).is(until))
                    break;
                matched.push(elem)
            }
        return matched
    }
      , siblings = function(n, elem) {
        for (var matched = []; n; n = n.nextSibling)
            1 === n.nodeType && n !== elem && matched.push(n);
        return matched
    }
      , rneedsContext = jQuery.expr.match.needsContext
      , rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i
      , risSimple = /^.[^:#\[\.,]*$/;
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        return not && (expr = ":not(" + expr + ")"),
        1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return 1 === elem.nodeType
        }))
    }
    ,
    jQuery.fn.extend({
        find: function(selector) {
            var i, ret, len = this.length, self = this;
            if ("string" != typeof selector)
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++)
                        if (jQuery.contains(self[i], this))
                            return !0
                }));
            for (ret = this.pushStack([]),
            i = 0; i < len; i++)
                jQuery.find(selector, self[i], ret);
            return len > 1 ? jQuery.uniqueSort(ret) : ret
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], !1))
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], !0))
        },
        is: function(selector) {
            return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector)
            return this;
        if (root = root || rootjQuery,
        "string" == typeof selector) {
            if (!(match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [null, selector, null] : rquickExpr.exec(selector)) || !match[1] && context)
                return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
            if (match[1]) {
                if (context = context instanceof jQuery ? context[0] : context,
                jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)),
                rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
                    for (match in context)
                        jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                return this
            }
            return elem = document.getElementById(match[2]),
            elem && (this[0] = elem,
            this.length = 1),
            this
        }
        return selector.nodeType ? (this[0] = selector,
        this.length = 1,
        this) : jQuery.isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this)
    }
    ).prototype = jQuery.fn,
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/
      , guaranteedUnique = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this)
              , l = targets.length;
            return this.filter(function() {
                for (var i = 0; i < l; i++)
                    if (jQuery.contains(this, targets[i]))
                        return !0
            })
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = "string" != typeof selectors && jQuery(selectors);
            if (!rneedsContext.test(selectors))
                for (; i < l; i++)
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                        if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                            matched.push(cur);
                            break
                        }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched)
        },
        index: function(elem) {
            return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))))
        },
        addBack: function(selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
        }
    }),
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null
        },
        parents: function(elem) {
            return dir(elem, "parentNode")
        },
        parentsUntil: function(elem, i, until) {
            return dir(elem, "parentNode", until)
        },
        next: function(elem) {
            return sibling(elem, "nextSibling")
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling")
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling")
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling")
        },
        nextUntil: function(elem, i, until) {
            return dir(elem, "nextSibling", until)
        },
        prevUntil: function(elem, i, until) {
            return dir(elem, "previousSibling", until)
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem)
        },
        children: function(elem) {
            return siblings(elem.firstChild)
        },
        contents: function(elem) {
            return nodeName(elem, "iframe") ? elem.contentDocument : (nodeName(elem, "template") && (elem = elem.content || elem),
            jQuery.merge([], elem.childNodes))
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            return "Until" !== name.slice(-5) && (selector = until),
            selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)),
            this.length > 1 && (guaranteedUnique[name] || jQuery.uniqueSort(matched),
            rparentsprev.test(name) && matched.reverse()),
            this.pushStack(matched)
        }
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    jQuery.Callbacks = function(options) {
        options = "string" == typeof options ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            for (locked = locked || options.once,
            fired = firing = !0; queue.length; firingIndex = -1)
                for (memory = queue.shift(); ++firingIndex < list.length; )
                    !1 === list[firingIndex].apply(memory[0], memory[1]) && options.stopOnFalse && (firingIndex = list.length,
                    memory = !1);
            options.memory || (memory = !1),
            firing = !1,
            locked && (list = memory ? [] : "")
        }, self = {
            add: function() {
                return list && (memory && !firing && (firingIndex = list.length - 1,
                queue.push(memory)),
                function add(args) {
                    jQuery.each(args, function(_, arg) {
                        jQuery.isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== jQuery.type(arg) && add(arg)
                    })
                }(arguments),
                memory && !firing && fire()),
                this
            },
            remove: function() {
                return jQuery.each(arguments, function(_, arg) {
                    for (var index; (index = jQuery.inArray(arg, list, index)) > -1; )
                        list.splice(index, 1),
                        index <= firingIndex && firingIndex--
                }),
                this
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
            },
            empty: function() {
                return list && (list = []),
                this
            },
            disable: function() {
                return locked = queue = [],
                list = memory = "",
                this
            },
            disabled: function() {
                return !list
            },
            lock: function() {
                return locked = queue = [],
                memory || firing || (list = memory = ""),
                this
            },
            locked: function() {
                return !!locked
            },
            fireWith: function(context, args) {
                return locked || (args = args || [],
                args = [context, args.slice ? args.slice() : args],
                queue.push(args),
                firing || fire()),
                this
            },
            fire: function() {
                return self.fireWith(this, arguments),
                this
            },
            fired: function() {
                return !!fired
            }
        };
        return self
    }
    ,
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]]
              , state = "pending"
              , promise = {
                state: function() {
                    return state
                },
                always: function() {
                    return deferred.done(arguments).fail(arguments),
                    this
                },
                catch: function(fn) {
                    return promise.then(null, fn)
                },
                pipe: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                returned && jQuery.isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments)
                            })
                        }),
                        fns = null
                    }).promise()
                },
                then: function(onFulfilled, onRejected, onProgress) {
                    function resolve(depth, deferred, handler, special) {
                        return function() {
                            var that = this
                              , args = arguments
                              , mightThrow = function() {
                                var returned, then;
                                if (!(depth < maxDepth)) {
                                    if ((returned = handler.apply(that, args)) === deferred.promise())
                                        throw new TypeError("Thenable self-resolution");
                                    then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then,
                                    jQuery.isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++,
                                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0,
                                    args = [returned]),
                                    (special || deferred.resolveWith)(that, args))
                                }
                            }
                              , process = special ? mightThrow : function() {
                                try {
                                    mightThrow()
                                } catch (e) {
                                    jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace),
                                    depth + 1 >= maxDepth && (handler !== Thrower && (that = void 0,
                                    args = [e]),
                                    deferred.rejectWith(that, args))
                                }
                            }
                            ;
                            depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()),
                            window.setTimeout(process))
                        }
                    }
                    var maxDepth = 0;
                    return jQuery.Deferred(function(newDefer) {
                        tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)),
                        tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity)),
                        tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower))
                    }).promise()
                },
                promise: function(obj) {
                    return null != obj ? jQuery.extend(obj, promise) : promise
                }
            }
              , deferred = {};
            return jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2]
                  , stateString = tuple[5];
                promise[tuple[1]] = list.add,
                stateString && list.add(function() {
                    state = stateString
                }, tuples[3 - i][2].disable, tuples[0][2].lock),
                list.add(tuple[3].fire),
                deferred[tuple[0]] = function() {
                    return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments),
                    this
                }
                ,
                deferred[tuple[0] + "With"] = list.fireWith
            }),
            promise.promise(deferred),
            func && func.call(deferred, deferred),
            deferred
        },
        when: function(singleValue) {
            var remaining = arguments.length
              , i = remaining
              , resolveContexts = Array(i)
              , resolveValues = slice.call(arguments)
              , master = jQuery.Deferred()
              , updateFunc = function(i) {
                return function(value) {
                    resolveContexts[i] = this,
                    resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value,
                    --remaining || master.resolveWith(resolveContexts, resolveValues)
                }
            };
            if (remaining <= 1 && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining),
            "pending" === master.state() || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)))
                return master.then();
            for (; i--; )
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            return master.promise()
        }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
        window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack)
    }
    ,
    jQuery.readyException = function(error) {
        window.setTimeout(function() {
            throw error
        })
    }
    ;
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
        return readyList.then(fn).catch(function(error) {
            jQuery.readyException(error)
        }),
        this
    }
    ,
    jQuery.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(wait) {
            (!0 === wait ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0,
            !0 !== wait && --jQuery.readyWait > 0 || readyList.resolveWith(document, [jQuery]))
        }
    }),
    jQuery.ready.then = readyList.then,
    "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed),
    window.addEventListener("load", completed));
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0
          , len = elems.length
          , bulk = null == key;
        if ("object" === jQuery.type(key)) {
            chainable = !0;
            for (i in key)
                access(elems, fn, i, key[i], !0, emptyGet, raw)
        } else if (void 0 !== value && (chainable = !0,
        jQuery.isFunction(value) || (raw = !0),
        bulk && (raw ? (fn.call(elems, value),
        fn = null) : (bulk = fn,
        fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value)
        }
        )),
        fn))
            for (; i < len; i++)
                fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
    }
      , acceptData = function(owner) {
        return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType
    };
    Data.uid = 1,
    Data.prototype = {
        cache: function(owner) {
            var value = owner[this.expando];
            return value || (value = {},
            acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: !0
            }))),
            value
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if ("string" == typeof data)
                cache[jQuery.camelCase(data)] = value;
            else
                for (prop in data)
                    cache[jQuery.camelCase(prop)] = data[prop];
            return cache
        },
        get: function(owner, key) {
            return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)]
        },
        access: function(owner, key, value) {
            return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value),
            void 0 !== value ? value : key)
        },
        remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (void 0 !== cache) {
                if (void 0 !== key) {
                    Array.isArray(key) ? key = key.map(jQuery.camelCase) : (key = jQuery.camelCase(key),
                    key = key in cache ? [key] : key.match(rnothtmlwhite) || []),
                    i = key.length;
                    for (; i--; )
                        delete cache[key[i]]
                }
                (void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando])
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return void 0 !== cache && !jQuery.isEmptyObject(cache)
        }
    };
    var dataPriv = new Data
      , dataUser = new Data
      , rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
      , rmultiDash = /[A-Z]/g;
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem)
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data)
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name)
        },
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data)
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name)
        }
    }),
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (void 0 === key) {
                if (this.length && (data = dataUser.get(elem),
                1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
                    for (i = attrs.length; i--; )
                        attrs[i] && (name = attrs[i].name,
                        0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)),
                        dataAttr(elem, name, data[name])));
                    dataPriv.set(elem, "hasDataAttrs", !0)
                }
                return data
            }
            return "object" == typeof key ? this.each(function() {
                dataUser.set(this, key)
            }) : access(this, function(value) {
                var data;
                if (elem && void 0 === value) {
                    if (void 0 !== (data = dataUser.get(elem, key)))
                        return data;
                    if (void 0 !== (data = dataAttr(elem, key)))
                        return data
                } else
                    this.each(function() {
                        dataUser.set(this, key, value)
                    })
            }, null, value, arguments.length > 1, null, !0)
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key)
            })
        }
    }),
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem)
                return type = (type || "fx") + "queue",
                queue = dataPriv.get(elem, type),
                data && (!queue || Array.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)),
                queue || []
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type)
              , startLength = queue.length
              , fn = queue.shift()
              , hooks = jQuery._queueHooks(elem, type)
              , next = function() {
                jQuery.dequeue(elem, type)
            };
            "inprogress" === fn && (fn = queue.shift(),
            startLength--),
            fn && ("fx" === type && queue.unshift("inprogress"),
            delete hooks.stop,
            fn.call(elem, next, hooks)),
            !startLength && hooks && hooks.empty.fire()
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [type + "queue", key])
                })
            })
        }
    }),
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            return "string" != typeof type && (data = type,
            type = "fx",
            setter--),
            arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type),
                "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
            })
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type)
            })
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", [])
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                --count || defer.resolveWith(elements, [elements])
            };
            for ("string" != typeof type && (obj = type,
            type = void 0),
            type = type || "fx"; i--; )
                (tmp = dataPriv.get(elements[i], type + "queueHooks")) && tmp.empty && (count++,
                tmp.empty.add(resolve));
            return resolve(),
            defer.promise(obj)
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
      , rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$","i")
      , cssExpand = ["Top", "Right", "Bottom", "Left"]
      , isHiddenWithinTree = function(elem, el) {
        return elem = el || elem,
        "none" === elem.style.display || "" === elem.style.display && jQuery.contains(elem.ownerDocument, elem) && "none" === jQuery.css(elem, "display")
    }
      , swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options)
            old[name] = elem.style[name],
            elem.style[name] = options[name];
        ret = callback.apply(elem, args || []);
        for (name in options)
            elem.style[name] = old[name];
        return ret
    }
      , defaultDisplayMap = {};
    jQuery.fn.extend({
        show: function() {
            return showHide(this, !0)
        },
        hide: function() {
            return showHide(this)
        },
        toggle: function(state) {
            return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide()
            })
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i
      , rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i
      , rscriptType = /^$|\/(?:java|ecma)script/i
      , wrapMap = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
    };
    wrapMap.optgroup = wrapMap.option,
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead,
    wrapMap.th = wrapMap.td;
    var rhtml = /<|&#?\w+;/;
    !function() {
        var fragment = document.createDocumentFragment()
          , div = fragment.appendChild(document.createElement("div"))
          , input = document.createElement("input");
        input.setAttribute("type", "radio"),
        input.setAttribute("checked", "checked"),
        input.setAttribute("name", "t"),
        div.appendChild(input),
        support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked,
        div.innerHTML = "<textarea>x</textarea>",
        support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue
    }();
    var documentElement = document.documentElement
      , rkeyEvent = /^key/
      , rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/
      , rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (elemData)
                for (handler.handler && (handleObjIn = handler,
                handler = handleObjIn.handler,
                selector = handleObjIn.selector),
                selector && jQuery.find.matchesSelector(documentElement, selector),
                handler.guid || (handler.guid = jQuery.guid++),
                (events = elemData.events) || (events = elemData.events = {}),
                (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                    return void 0 !== jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0
                }
                ),
                types = (types || "").match(rnothtmlwhite) || [""],
                t = types.length; t--; )
                    tmp = rtypenamespace.exec(types[t]) || [],
                    type = origType = tmp[1],
                    namespaces = (tmp[2] || "").split(".").sort(),
                    type && (special = jQuery.event.special[type] || {},
                    type = (selector ? special.delegateType : special.bindType) || type,
                    special = jQuery.event.special[type] || {},
                    handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join(".")
                    }, handleObjIn),
                    (handlers = events[type]) || (handlers = events[type] = [],
                    handlers.delegateCount = 0,
                    special.setup && !1 !== special.setup.call(elem, data, namespaces, eventHandle) || elem.addEventListener && elem.addEventListener(type, eventHandle)),
                    special.add && (special.add.call(elem, handleObj),
                    handleObj.handler.guid || (handleObj.handler.guid = handler.guid)),
                    selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj),
                    jQuery.event.global[type] = !0)
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (elemData && (events = elemData.events)) {
                for (types = (types || "").match(rnothtmlwhite) || [""],
                t = types.length; t--; )
                    if (tmp = rtypenamespace.exec(types[t]) || [],
                    type = origType = tmp[1],
                    namespaces = (tmp[2] || "").split(".").sort(),
                    type) {
                        for (special = jQuery.event.special[type] || {},
                        type = (selector ? special.delegateType : special.bindType) || type,
                        handlers = events[type] || [],
                        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                        origCount = j = handlers.length; j--; )
                            handleObj = handlers[j],
                            !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1),
                            handleObj.selector && handlers.delegateCount--,
                            special.remove && special.remove.call(elem, handleObj));
                        origCount && !handlers.length && (special.teardown && !1 !== special.teardown.call(elem, namespaces, elemData.handle) || jQuery.removeEvent(elem, type, elemData.handle),
                        delete events[type])
                    } else
                        for (type in events)
                            jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events")
            }
        },
        dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, event = jQuery.event.fix(nativeEvent), args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            for (args[0] = event,
            i = 1; i < arguments.length; i++)
                args[i] = arguments[i];
            if (event.delegateTarget = this,
            !special.preDispatch || !1 !== special.preDispatch.call(this, event)) {
                for (handlerQueue = jQuery.event.handlers.call(this, event, handlers),
                i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); )
                    for (event.currentTarget = matched.elem,
                    j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); )
                        event.rnamespace && !event.rnamespace.test(handleObj.namespace) || (event.handleObj = handleObj,
                        event.data = handleObj.data,
                        void 0 !== (ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args)) && !1 === (event.result = ret) && (event.preventDefault(),
                        event.stopPropagation()));
                return special.postDispatch && special.postDispatch.call(this, event),
                event.result
            }
        },
        handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !("click" === event.type && event.button >= 1))
                for (; cur !== this; cur = cur.parentNode || this)
                    if (1 === cur.nodeType && ("click" !== event.type || !0 !== cur.disabled)) {
                        for (matchedHandlers = [],
                        matchedSelectors = {},
                        i = 0; i < delegateCount; i++)
                            handleObj = handlers[i],
                            sel = handleObj.selector + " ",
                            void 0 === matchedSelectors[sel] && (matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length),
                            matchedSelectors[sel] && matchedHandlers.push(handleObj);
                        matchedHandlers.length && handlerQueue.push({
                            elem: cur,
                            handlers: matchedHandlers
                        })
                    }
            return cur = this,
            delegateCount < handlers.length && handlerQueue.push({
                elem: cur,
                handlers: handlers.slice(delegateCount)
            }),
            handlerQueue
        },
        addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: !0,
                configurable: !0,
                get: jQuery.isFunction(hook) ? function() {
                    if (this.originalEvent)
                        return hook(this.originalEvent)
                }
                : function() {
                    if (this.originalEvent)
                        return this.originalEvent[name]
                }
                ,
                set: function(value) {
                    Object.defineProperty(this, name, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: value
                    })
                }
            })
        },
        fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent)
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus)
                        return this.focus(),
                        !1
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur)
                        return this.blur(),
                        !1
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if ("checkbox" === this.type && this.click && nodeName(this, "input"))
                        return this.click(),
                        !1
                },
                _default: function(event) {
                    return nodeName(event.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result)
                }
            }
        }
    },
    jQuery.removeEvent = function(elem, type, handle) {
        elem.removeEventListener && elem.removeEventListener(type, handle)
    }
    ,
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event))
            return new jQuery.Event(src,props);
        src && src.type ? (this.originalEvent = src,
        this.type = src.type,
        this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && !1 === src.returnValue ? returnTrue : returnFalse,
        this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target,
        this.currentTarget = src.currentTarget,
        this.relatedTarget = src.relatedTarget) : this.type = src,
        props && jQuery.extend(this, props),
        this.timeStamp = src && src.timeStamp || jQuery.now(),
        this[jQuery.expando] = !0
    }
    ,
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: !1,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue,
            e && !this.isSimulated && e.preventDefault()
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue,
            e && !this.isSimulated && e.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue,
            e && !this.isSimulated && e.stopImmediatePropagation(),
            this.stopPropagation()
        }
    },
    jQuery.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function(event) {
            var button = event.button;
            return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which
        }
    }, jQuery.event.addProp),
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                return related && (related === target || jQuery.contains(target, related)) || (event.type = handleObj.origType,
                ret = handleObj.handler.apply(this, arguments),
                event.type = fix),
                ret
            }
        }
    }),
    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn)
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1)
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj)
                return handleObj = types.handleObj,
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler),
                this;
            if ("object" == typeof types) {
                for (type in types)
                    this.off(type, selector, types[type]);
                return this
            }
            return !1 !== selector && "function" != typeof selector || (fn = selector,
            selector = void 0),
            !1 === fn && (fn = returnFalse),
            this.each(function() {
                jQuery.event.remove(this, types, fn, selector)
            })
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi
      , rnoInnerhtml = /<script|<style|<link/i
      , rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i
      , rscriptTypeMasked = /^true\/(.*)/
      , rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>")
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))
                for (destElements = getAll(clone),
                srcElements = getAll(elem),
                i = 0,
                l = srcElements.length; i < l; i++)
                    fixInput(srcElements[i], destElements[i]);
            if (dataAndEvents)
                if (deepDataAndEvents)
                    for (srcElements = srcElements || getAll(elem),
                    destElements = destElements || getAll(clone),
                    i = 0,
                    l = srcElements.length; i < l; i++)
                        cloneCopyEvent(srcElements[i], destElements[i]);
                else
                    cloneCopyEvent(elem, clone);
            return destElements = getAll(clone, "script"),
            destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")),
            clone
        },
        cleanData: function(elems) {
            for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++)
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events)
                            for (type in data.events)
                                special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                        elem[dataPriv.expando] = void 0
                    }
                    elem[dataUser.expando] && (elem[dataUser.expando] = void 0)
                }
        }
    }),
    jQuery.fn.extend({
        detach: function(selector) {
            return remove(this, selector, !0)
        },
        remove: function(selector) {
            return remove(this, selector)
        },
        text: function(value) {
            return access(this, function(value) {
                return void 0 === value ? jQuery.text(this) : this.empty().each(function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = value)
                })
            }, null, value, arguments.length)
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    manipulationTarget(this, elem).appendChild(elem)
                }
            })
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild)
                }
            })
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this)
            })
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
            })
        },
        empty: function() {
            for (var elem, i = 0; null != (elem = this[i]); i++)
                1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)),
                elem.textContent = "");
            return this
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            return dataAndEvents = null != dataAndEvents && dataAndEvents,
            deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents,
            this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
            })
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}
                  , i = 0
                  , l = this.length;
                if (void 0 === value && 1 === elem.nodeType)
                    return elem.innerHTML;
                if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (; i < l; i++)
                            elem = this[i] || {},
                            1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)),
                            elem.innerHTML = value);
                        elem = 0
                    } catch (e) {}
                }
                elem && this.empty().append(value)
            }, null, value, arguments.length)
        },
        replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)),
                parent && parent.replaceChild(elem, this))
            }, ignored)
        }
    }),
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; i <= last; i++)
                elems = i === last ? this : this.clone(!0),
                jQuery(insert[i])[original](elems),
                push.apply(ret, elems.get());
            return this.pushStack(ret)
        }
    });
    var rmargin = /^margin/
      , rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$","i")
      , getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        return view && view.opener || (view = window),
        view.getComputedStyle(elem)
    };
    !function() {
        function computeStyleTests() {
            if (div) {
                div.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",
                div.innerHTML = "",
                documentElement.appendChild(container);
                var divStyle = window.getComputedStyle(div);
                pixelPositionVal = "1%" !== divStyle.top,
                reliableMarginLeftVal = "2px" === divStyle.marginLeft,
                boxSizingReliableVal = "4px" === divStyle.width,
                div.style.marginRight = "50%",
                pixelMarginRightVal = "4px" === divStyle.marginRight,
                documentElement.removeChild(container),
                div = null
            }
        }
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
        div.style && (div.style.backgroundClip = "content-box",
        div.cloneNode(!0).style.backgroundClip = "",
        support.clearCloneStyle = "content-box" === div.style.backgroundClip,
        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",
        container.appendChild(div),
        jQuery.extend(support, {
            pixelPosition: function() {
                return computeStyleTests(),
                pixelPositionVal
            },
            boxSizingReliable: function() {
                return computeStyleTests(),
                boxSizingReliableVal
            },
            pixelMarginRight: function() {
                return computeStyleTests(),
                pixelMarginRightVal
            },
            reliableMarginLeft: function() {
                return computeStyleTests(),
                reliableMarginLeftVal
            }
        }))
    }();
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/
      , rcustomProp = /^--/
      , cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }
      , cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }
      , cssPrefixes = ["Webkit", "Moz", "ms"]
      , emptyStyle = document.createElement("div").style;
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return "" === ret ? "1" : ret
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                var ret, type, hooks, origName = jQuery.camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
                if (isCustomProp || (name = finalPropName(origName)),
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName],
                void 0 === value)
                    return hooks && "get"in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name];
                type = typeof value,
                "string" === type && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret),
                type = "number"),
                null != value && value === value && ("number" === type && (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")),
                support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"),
                hooks && "set"in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (isCustomProp ? style.setProperty(name, value) : style[name] = value))
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            return rcustomProp.test(name) || (name = finalPropName(origName)),
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName],
            hooks && "get"in hooks && (val = hooks.get(elem, !0, extra)),
            void 0 === val && (val = curCSS(elem, name, styles)),
            "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]),
            "" === extra || extra ? (num = parseFloat(val),
            !0 === extra || isFinite(num) ? num || 0 : val) : val
        }
    }),
    jQuery.each(["height", "width"], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed)
                    return !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, name, extra) : swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra)
                    })
            },
            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles);
                return subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[name] = value,
                value = jQuery.css(elem, name)),
                setPositiveNumber(elem, value, subtract)
            }
        }
    }),
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed)
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
                marginLeft: 0
            }, function() {
                return elem.getBoundingClientRect().left
            })) + "px"
    }),
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [value]; i < 4; i++)
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded
            }
        },
        rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
    }),
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name)) {
                    for (styles = getStyles(elem),
                    len = name.length; i < len; i++)
                        map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                    return map
                }
                return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
            }, name, value, arguments.length > 1)
        }
    }),
    jQuery.Tween = Tween,
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem,
            this.prop = prop,
            this.easing = easing || jQuery.easing._default,
            this.options = options,
            this.start = this.now = this.cur(),
            this.end = end,
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent,
            this.now = (this.end - this.start) * eased + this.start,
            this.options.step && this.options.step.call(this.elem, this.now, this),
            hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this),
            this
        }
    },
    Tween.prototype.init.prototype = Tween.prototype,
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, ""),
                result && "auto" !== result ? result : 0)
            },
            set: function(tween) {
                jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || null == tween.elem.style[jQuery.cssProps[tween.prop]] && !jQuery.cssHooks[tween.prop] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
            }
        }
    },
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
        }
    },
    jQuery.easing = {
        linear: function(p) {
            return p
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2
        },
        _default: "swing"
    },
    jQuery.fx = Tween.prototype.init,
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [function(prop, value) {
                var tween = this.createTween(prop, value);
                return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween),
                tween
            }
            ]
        },
        tweener: function(props, callback) {
            jQuery.isFunction(props) ? (callback = props,
            props = ["*"]) : props = props.match(rnothtmlwhite);
            for (var prop, index = 0, length = props.length; index < length; index++)
                prop = props[index],
                Animation.tweeners[prop] = Animation.tweeners[prop] || [],
                Animation.tweeners[prop].unshift(callback)
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
            prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback)
        }
    }),
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        return jQuery.fx.off ? opt.duration = 0 : "number" != typeof opt.duration && (opt.duration in jQuery.fx.speeds ? opt.duration = jQuery.fx.speeds[opt.duration] : opt.duration = jQuery.fx.speeds._default),
        null != opt.queue && !0 !== opt.queue || (opt.queue = "fx"),
        opt.old = opt.complete,
        opt.complete = function() {
            jQuery.isFunction(opt.old) && opt.old.call(this),
            opt.queue && jQuery.dequeue(this, opt.queue)
        }
        ,
        opt
    }
    ,
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback)
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop)
              , optall = jQuery.speed(speed, easing, callback)
              , doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                (empty || dataPriv.get(this, "finish")) && anim.stop(!0)
            };
            return doAnimation.finish = doAnimation,
            empty || !1 === optall.queue ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop,
                stop(gotoEnd)
            };
            return "string" != typeof type && (gotoEnd = clearQueue,
            clearQueue = type,
            type = void 0),
            clearQueue && !1 !== type && this.queue(type || "fx", []),
            this.each(function() {
                var dequeue = !0
                  , index = null != type && type + "queueHooks"
                  , timers = jQuery.timers
                  , data = dataPriv.get(this);
                if (index)
                    data[index] && data[index].stop && stopQueue(data[index]);
                else
                    for (index in data)
                        data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                for (index = timers.length; index--; )
                    timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd),
                    dequeue = !1,
                    timers.splice(index, 1));
                !dequeue && gotoEnd || jQuery.dequeue(this, type)
            })
        },
        finish: function(type) {
            return !1 !== type && (type = type || "fx"),
            this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                for (data.finish = !0,
                jQuery.queue(this, type, []),
                hooks && hooks.stop && hooks.stop.call(this, !0),
                index = timers.length; index--; )
                    timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0),
                    timers.splice(index, 1));
                for (index = 0; index < length; index++)
                    queue[index] && queue[index].finish && queue[index].finish.call(this);
                delete data.finish
            })
        }
    }),
    jQuery.each(["toggle", "show", "hide"], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
        }
    }),
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback)
        }
    }),
    jQuery.timers = [],
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        for (fxNow = jQuery.now(); i < timers.length; i++)
            (timer = timers[i])() || timers[i] !== timer || timers.splice(i--, 1);
        timers.length || jQuery.fx.stop(),
        fxNow = void 0
    }
    ,
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer),
        jQuery.fx.start()
    }
    ,
    jQuery.fx.interval = 13,
    jQuery.fx.start = function() {
        inProgress || (inProgress = !0,
        schedule())
    }
    ,
    jQuery.fx.stop = function() {
        inProgress = null
    }
    ,
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    },
    jQuery.fn.delay = function(time, type) {
        return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time,
        type = type || "fx",
        this.queue(type, function(next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function() {
                window.clearTimeout(timeout)
            }
        })
    }
    ,
    function() {
        var input = document.createElement("input")
          , select = document.createElement("select")
          , opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox",
        support.checkOn = "" !== input.value,
        support.optSelected = opt.selected,
        input = document.createElement("input"),
        input.value = "t",
        input.type = "radio",
        support.radioValue = "t" === input.value
    }();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1)
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name)
            })
        }
    }),
    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (3 !== nType && 8 !== nType && 2 !== nType)
                return void 0 === elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)),
                void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set"in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""),
                value) : hooks && "get"in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name),
                null == ret ? void 0 : ret))
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && "radio" === value && nodeName(elem, "input")) {
                        var val = elem.value;
                        return elem.setAttribute("type", value),
                        val && (elem.value = val),
                        value
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && 1 === elem.nodeType)
                for (; name = attrNames[i++]; )
                    elem.removeAttribute(name)
        }
    }),
    boolHook = {
        set: function(elem, value, name) {
            return !1 === value ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name),
            name
        }
    },
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            return isXML || (handle = attrHandle[lowercaseName],
            attrHandle[lowercaseName] = ret,
            ret = null != getter(elem, name, isXML) ? lowercaseName : null,
            attrHandle[lowercaseName] = handle),
            ret
        }
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i
      , rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1)
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name]
            })
        }
    }),
    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (3 !== nType && 8 !== nType && 2 !== nType)
                return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name,
                hooks = jQuery.propHooks[name]),
                void 0 !== value ? hooks && "set"in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get"in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }),
    support.optSelected || (jQuery.propHooks.selected = {
        get: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.parentNode && parent.parentNode.selectedIndex,
            null
        },
        set: function(elem) {
            var parent = elem.parentNode;
            parent && (parent.selectedIndex,
            parent.parentNode && parent.parentNode.selectedIndex)
        }
    }),
    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        jQuery.propFix[this.toLowerCase()] = this
    }),
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value))
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)))
                });
            if ("string" == typeof value && value)
                for (classes = value.match(rnothtmlwhite) || []; elem = this[i++]; )
                    if (curValue = getClass(elem),
                    cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                        for (j = 0; clazz = classes[j++]; )
                            cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                        finalValue = stripAndCollapse(cur),
                        curValue !== finalValue && elem.setAttribute("class", finalValue)
                    }
            return this
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value))
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)))
                });
            if (!arguments.length)
                return this.attr("class", "");
            if ("string" == typeof value && value)
                for (classes = value.match(rnothtmlwhite) || []; elem = this[i++]; )
                    if (curValue = getClass(elem),
                    cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                        for (j = 0; clazz = classes[j++]; )
                            for (; cur.indexOf(" " + clazz + " ") > -1; )
                                cur = cur.replace(" " + clazz + " ", " ");
                        finalValue = stripAndCollapse(cur),
                        curValue !== finalValue && elem.setAttribute("class", finalValue)
                    }
            return this
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal)
            }) : this.each(function() {
                var className, i, self, classNames;
                if ("string" === type)
                    for (i = 0,
                    self = jQuery(this),
                    classNames = value.match(rnothtmlwhite) || []; className = classNames[i++]; )
                        self.hasClass(className) ? self.removeClass(className) : self.addClass(className);
                else
                    void 0 !== value && "boolean" !== type || (className = getClass(this),
                    className && dataPriv.set(this, "__className__", className),
                    this.setAttribute && this.setAttribute("class", className || !1 === value ? "" : dataPriv.get(this, "__className__") || ""))
            })
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            for (className = " " + selector + " "; elem = this[i++]; )
                if (1 === elem.nodeType && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1)
                    return !0;
            return !1
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            {
                if (arguments.length)
                    return isFunction = jQuery.isFunction(value),
                    this.each(function(i) {
                        var val;
                        1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value,
                        null == val ? val = "" : "number" == typeof val ? val += "" : Array.isArray(val) && (val = jQuery.map(val, function(value) {
                            return null == value ? "" : value + ""
                        })),
                        (hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]) && "set"in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val))
                    });
                if (elem)
                    return (hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]) && "get"in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value,
                    "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret)
            }
        }
    }),
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return null != val ? val : stripAndCollapse(jQuery.text(elem))
                }
            },
            select: {
                get: function(elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type, values = one ? null : [], max = one ? index + 1 : options.length;
                    for (i = index < 0 ? max : one ? index : 0; i < max; i++)
                        if (option = options[i],
                        (option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                            if (value = jQuery(option).val(),
                            one)
                                return value;
                            values.push(value)
                        }
                    return values
                },
                set: function(elem, value) {
                    for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; )
                        option = options[i],
                        (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) && (optionSet = !0);
                    return optionSet || (elem.selectedIndex = -1),
                    values
                }
            }
        }
    }),
    jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (Array.isArray(value))
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1
            }
        },
        support.checkOn || (jQuery.valHooks[this].get = function(elem) {
            return null === elem.getAttribute("value") ? "on" : elem.value
        }
        )
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            if (cur = tmp = elem = elem || document,
            3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") > -1 && (namespaces = type.split("."),
            type = namespaces.shift(),
            namespaces.sort()),
            ontype = type.indexOf(":") < 0 && "on" + type,
            event = event[jQuery.expando] ? event : new jQuery.Event(type,"object" == typeof event && event),
            event.isTrigger = onlyHandlers ? 2 : 3,
            event.namespace = namespaces.join("."),
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
            event.result = void 0,
            event.target || (event.target = elem),
            data = null == data ? [event] : jQuery.makeArray(data, [event]),
            special = jQuery.event.special[type] || {},
            onlyHandlers || !special.trigger || !1 !== special.trigger.apply(elem, data))) {
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    for (bubbleType = special.delegateType || type,
                    rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode)
                        eventPath.push(cur),
                        tmp = cur;
                    tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                }
                for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); )
                    event.type = i > 1 ? bubbleType : special.bindType || type,
                    handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle"),
                    handle && handle.apply(cur, data),
                    (handle = ontype && cur[ontype]) && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data),
                    !1 === event.result && event.preventDefault());
                return event.type = type,
                onlyHandlers || event.isDefaultPrevented() || special._default && !1 !== special._default.apply(eventPath.pop(), data) || !acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype],
                tmp && (elem[ontype] = null),
                jQuery.event.triggered = type,
                elem[type](),
                jQuery.event.triggered = void 0,
                tmp && (elem[ontype] = tmp)),
                event.result
            }
        },
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event, event, {
                type: type,
                isSimulated: !0
            });
            jQuery.event.trigger(e, null, elem)
        }
    }),
    jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this)
            })
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem)
                return jQuery.event.trigger(type, data, elem, !0)
        }
    }),
    jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
        }
    }),
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
        }
    }),
    support.focusin = "onfocusin"in window,
    support.focusin || jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event))
        };
        jQuery.event.special[fix] = {
            setup: function() {
                var doc = this.ownerDocument || this
                  , attaches = dataPriv.access(doc, fix);
                attaches || doc.addEventListener(orig, handler, !0),
                dataPriv.access(doc, fix, (attaches || 0) + 1)
            },
            teardown: function() {
                var doc = this.ownerDocument || this
                  , attaches = dataPriv.access(doc, fix) - 1;
                attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0),
                dataPriv.remove(doc, fix))
            }
        }
    });
    var location = window.location
      , nonce = jQuery.now()
      , rquery = /\?/;
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || "string" != typeof data)
            return null;
        try {
            xml = (new window.DOMParser).parseFromString(data, "text/xml")
        } catch (e) {
            xml = void 0
        }
        return xml && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data),
        xml
    }
    ;
    var rbracket = /\[\]$/
      , rCRLF = /\r?\n/g
      , rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i
      , rsubmittable = /^(?:input|select|textarea|keygen)/i;
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
            var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value)
        };
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a))
            jQuery.each(a, function() {
                add(this.name, this.value)
            });
        else
            for (prefix in a)
                buildParams(prefix, a[prefix], traditional, add);
        return s.join("&")
    }
    ,
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return null == val ? null : Array.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    }
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                }
            }).get()
        }
    });
    var r20 = /%20/g
      , rhash = /#.*$/
      , rantiCache = /([?&])_=[^&]*/
      , rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm
      , rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/
      , rnoContent = /^(?:GET|HEAD)$/
      , rprotocol = /^\/\//
      , prefilters = {}
      , transports = {}
      , allTypes = "*/".concat("*")
      , originAnchor = document.createElement("a");
    originAnchor.href = location.href,
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                completed || (completed = !0,
                timeoutTimer && window.clearTimeout(timeoutTimer),
                transport = void 0,
                responseHeadersString = headers || "",
                jqXHR.readyState = status > 0 ? 4 : 0,
                isSuccess = status >= 200 && status < 300 || 304 === status,
                responses && (response = ajaxHandleResponses(s, jqXHR, responses)),
                response = ajaxConvert(s, response, jqXHR, isSuccess),
                isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"),
                modified && (jQuery.lastModified[cacheURL] = modified),
                (modified = jqXHR.getResponseHeader("etag")) && (jQuery.etag[cacheURL] = modified)),
                204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state,
                success = response.data,
                error = response.error,
                isSuccess = !error)) : (error = statusText,
                !status && statusText || (statusText = "error",
                status < 0 && (status = 0))),
                jqXHR.status = status,
                jqXHR.statusText = (nativeStatusText || statusText) + "",
                isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]),
                jqXHR.statusCode(statusCode),
                statusCode = void 0,
                fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]),
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]),
                fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]),
                --jQuery.active || jQuery.event.trigger("ajaxStop")))
            }
            "object" == typeof url && (options = url,
            url = void 0),
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders)
                            for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); )
                                responseHeaders[match[1].toLowerCase()] = match[2];
                        match = responseHeaders[key.toLowerCase()]
                    }
                    return null == match ? null : match
                },
                getAllResponseHeaders: function() {
                    return completed ? responseHeadersString : null
                },
                setRequestHeader: function(name, value) {
                    return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name,
                    requestHeaders[name] = value),
                    this
                },
                overrideMimeType: function(type) {
                    return null == completed && (s.mimeType = type),
                    this
                },
                statusCode: function(map) {
                    var code;
                    if (map)
                        if (completed)
                            jqXHR.always(map[jqXHR.status]);
                        else
                            for (code in map)
                                statusCode[code] = [statusCode[code], map[code]];
                    return this
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    return transport && transport.abort(finalText),
                    done(0, finalText),
                    this
                }
            };
            if (deferred.promise(jqXHR),
            s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"),
            s.type = options.method || options.type || s.method || s.type,
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""],
            null == s.crossDomain) {
                urlAnchor = document.createElement("a");
                try {
                    urlAnchor.href = s.url,
                    urlAnchor.href = urlAnchor.href,
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host
                } catch (e) {
                    s.crossDomain = !0
                }
            }
            if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)),
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR),
            completed)
                return jqXHR;
            fireGlobals = jQuery.event && s.global,
            fireGlobals && 0 == jQuery.active++ && jQuery.event.trigger("ajaxStart"),
            s.type = s.type.toUpperCase(),
            s.hasContent = !rnoContent.test(s.type),
            cacheURL = s.url.replace(rhash, ""),
            s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length),
            s.data && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data,
            delete s.data),
            !1 === s.cache && (cacheURL = cacheURL.replace(rantiCache, "$1"),
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached),
            s.url = cacheURL + uncached),
            s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]),
            jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])),
            (s.data && s.hasContent && !1 !== s.contentType || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType),
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers)
                jqXHR.setRequestHeader(i, s.headers[i]);
            if (s.beforeSend && (!1 === s.beforeSend.call(callbackContext, jqXHR, s) || completed))
                return jqXHR.abort();
            if (strAbort = "abort",
            completeDeferred.add(s.complete),
            jqXHR.done(s.success),
            jqXHR.fail(s.error),
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                if (jqXHR.readyState = 1,
                fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]),
                completed)
                    return jqXHR;
                s.async && s.timeout > 0 && (timeoutTimer = window.setTimeout(function() {
                    jqXHR.abort("timeout")
                }, s.timeout));
                try {
                    completed = !1,
                    transport.send(requestHeaders, done)
                } catch (e) {
                    if (completed)
                        throw e;
                    done(-1, e)
                }
            } else
                done(-1, "No Transport");
            return jqXHR
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json")
        },
        getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script")
        }
    }),
    jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            return jQuery.isFunction(data) && (type = type || callback,
            callback = data,
            data = void 0),
            jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url))
        }
    }),
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            throws: !0
        })
    }
    ,
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            return this[0] && (jQuery.isFunction(html) && (html = html.call(this[0])),
            wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0),
            this[0].parentNode && wrap.insertBefore(this[0]),
            wrap.map(function() {
                for (var elem = this; elem.firstElementChild; )
                    elem = elem.firstElementChild;
                return elem
            }).append(this)),
            this
        },
        wrapInner: function(html) {
            return jQuery.isFunction(html) ? this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i))
            }) : this.each(function() {
                var self = jQuery(this)
                  , contents = self.contents();
                contents.length ? contents.wrapAll(html) : self.append(html)
            })
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
            })
        },
        unwrap: function(selector) {
            return this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes)
            }),
            this
        }
    }),
    jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem)
    }
    ,
    jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)
    }
    ,
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest
        } catch (e) {}
    }
    ;
    var xhrSuccessStatus = {
        0: 200,
        1223: 204
    }
      , xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials"in xhrSupported,
    support.ajax = xhrSupported = !!xhrSupported,
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain)
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr();
                    if (xhr.open(options.type, options.url, options.async, options.username, options.password),
                    options.xhrFields)
                        for (i in options.xhrFields)
                            xhr[i] = options.xhrFields[i];
                    options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType),
                    options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                    for (i in headers)
                        xhr.setRequestHeader(i, headers[i]);
                    callback = function(type) {
                        return function() {
                            callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null,
                            "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {
                                binary: xhr.response
                            } : {
                                text: xhr.responseText
                            }, xhr.getAllResponseHeaders()))
                        }
                    }
                    ,
                    xhr.onload = callback(),
                    errorCallback = xhr.onerror = callback("error"),
                    void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function() {
                        4 === xhr.readyState && window.setTimeout(function() {
                            callback && errorCallback()
                        })
                    }
                    ,
                    callback = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null)
                    } catch (e) {
                        if (callback)
                            throw e
                    }
                },
                abort: function() {
                    callback && callback()
                }
            }
    }),
    jQuery.ajaxPrefilter(function(s) {
        s.crossDomain && (s.contents.script = !1)
    }),
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                return jQuery.globalEval(text),
                text
            }
        }
    }),
    jQuery.ajaxPrefilter("script", function(s) {
        void 0 === s.cache && (s.cache = !1),
        s.crossDomain && (s.type = "GET")
    }),
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove(),
                        callback = null,
                        evt && complete("error" === evt.type ? 404 : 200, evt.type)
                    }
                    ),
                    document.head.appendChild(script[0])
                },
                abort: function() {
                    callback && callback()
                }
            }
        }
    });
    var oldCallbacks = []
      , rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            return this[callback] = !0,
            callback
        }
    }),
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = !1 !== s.jsonp && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || "jsonp" === s.dataTypes[0])
            return callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,
            jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : !1 !== s.jsonp && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName),
            s.converters["script json"] = function() {
                return responseContainer || jQuery.error(callbackName + " was not called"),
                responseContainer[0]
            }
            ,
            s.dataTypes[0] = "json",
            overwritten = window[callbackName],
            window[callbackName] = function() {
                responseContainer = arguments
            }
            ,
            jqXHR.always(function() {
                void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten,
                s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback,
                oldCallbacks.push(callbackName)),
                responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]),
                responseContainer = overwritten = void 0
            }),
            "script"
    }),
    support.createHTMLDocument = function() {
        var body = document.implementation.createHTMLDocument("").body;
        return body.innerHTML = "<form></form><form></form>",
        2 === body.childNodes.length
    }(),
    jQuery.parseHTML = function(data, context, keepScripts) {
        if ("string" != typeof data)
            return [];
        "boolean" == typeof context && (keepScripts = context,
        context = !1);
        var base, parsed, scripts;
        return context || (support.createHTMLDocument ? (context = document.implementation.createHTMLDocument(""),
        base = context.createElement("base"),
        base.href = document.location.href,
        context.head.appendChild(base)) : context = document),
        parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [],
        parsed ? [context.createElement(parsed[1])] : (parsed = buildFragment([data], context, scripts),
        scripts && scripts.length && jQuery(scripts).remove(),
        jQuery.merge([], parsed.childNodes))
    }
    ,
    jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(" ");
        return off > -1 && (selector = stripAndCollapse(url.slice(off)),
        url = url.slice(0, off)),
        jQuery.isFunction(params) ? (callback = params,
        params = void 0) : params && "object" == typeof params && (type = "POST"),
        self.length > 0 && jQuery.ajax({
            url: url,
            type: type || "GET",
            dataType: "html",
            data: params
        }).done(function(responseText) {
            response = arguments,
            self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
        }).always(callback && function(jqXHR, status) {
            self.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR])
            })
        }
        ),
        this
    }
    ,
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn)
        }
    }),
    jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem
        }).length
    }
    ,
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            "static" === position && (elem.style.position = "relative"),
            curOffset = curElem.offset(),
            curCSSTop = jQuery.css(elem, "top"),
            curCSSLeft = jQuery.css(elem, "left"),
            calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1,
            calculatePosition ? (curPosition = curElem.position(),
            curTop = curPosition.top,
            curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0,
            curLeft = parseFloat(curCSSLeft) || 0),
            jQuery.isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))),
            null != options.top && (props.top = options.top - curOffset.top + curTop),
            null != options.left && (props.left = options.left - curOffset.left + curLeft),
            "using"in options ? options.using.call(elem, props) : curElem.css(props)
        }
    },
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length)
                return void 0 === options ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i)
                });
            var doc, docElem, rect, win, elem = this[0];
            if (elem)
                return elem.getClientRects().length ? (rect = elem.getBoundingClientRect(),
                doc = elem.ownerDocument,
                docElem = doc.documentElement,
                win = doc.defaultView,
                {
                    top: rect.top + win.pageYOffset - docElem.clientTop,
                    left: rect.left + win.pageXOffset - docElem.clientLeft
                }) : {
                    top: 0,
                    left: 0
                }
        },
        position: function() {
            if (this[0]) {
                var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
                return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(),
                offset = this.offset(),
                nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()),
                parentOffset = {
                    top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", !0),
                    left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", !0)
                }),
                {
                    top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                    left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                }
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position"); )
                    offsetParent = offsetParent.offsetParent;
                return offsetParent || documentElement
            })
        }
    }),
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win;
                if (jQuery.isWindow(elem) ? win = elem : 9 === elem.nodeType && (win = elem.defaultView),
                void 0 === val)
                    return win ? win[prop] : elem[method];
                win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val
            }, method, val, arguments.length)
        }
    }),
    jQuery.each(["top", "left"], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed)
                return computed = curCSS(elem, prop),
                rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
        })
    }),
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin)
                  , extra = defaultExtra || (!0 === margin || !0 === value ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    return jQuery.isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement,
                    Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                }, type, chainable ? margin : void 0, chainable)
            }
        })
    }),
    jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn)
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn)
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn)
        },
        undelegate: function(selector, types, fn) {
            return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
        }
    }),
    jQuery.holdReady = function(hold) {
        hold ? jQuery.readyWait++ : jQuery.ready(!0)
    }
    ,
    jQuery.isArray = Array.isArray,
    jQuery.parseJSON = JSON.parse,
    jQuery.nodeName = nodeName,
    "function" == typeof define && define.amd && define("jquery", [], function() {
        return jQuery
    });
    var _jQuery = window.jQuery
      , _$ = window.$;
    return jQuery.noConflict = function(deep) {
        return window.$ === jQuery && (window.$ = _$),
        deep && window.jQuery === jQuery && (window.jQuery = _jQuery),
        jQuery
    }
    ,
    noGlobal || (window.jQuery = window.$ = jQuery),
    jQuery
}),
"undefined" == typeof jQuery)
    throw new Error("Bootstrap's JavaScript requires jQuery");
+function($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || 1 == version[0] && 9 == version[1] && version[2] < 1 || version[0] > 3)
        throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4")
}(jQuery),
function($) {
    "use strict";
    function transitionEnd() {
        var el = document.createElement("bootstrap")
          , transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames)
            if (void 0 !== el.style[name])
                return {
                    end: transEndEventNames[name]
                };
        return !1
    }
    $.fn.emulateTransitionEnd = function(duration) {
        var called = !1
          , $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = !0
        });
        var callback = function() {
            called || $($el).trigger($.support.transition.end)
        };
        return setTimeout(callback, duration),
        this
    }
    ,
    $(function() {
        $.support.transition = transitionEnd(),
        $.support.transition && ($.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this))
                    return e.handleObj.handler.apply(this, arguments)
            }
        })
    })
}(jQuery),
function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.alert");
            data || $this.data("bs.alert", data = new Alert(this)),
            "string" == typeof option && data[option].call($this)
        })
    }
    var dismiss = '[data-dismiss="alert"]'
      , Alert = function(el) {
        $(el).on("click", dismiss, this.close)
    };
    Alert.VERSION = "3.3.7",
    Alert.TRANSITION_DURATION = 150,
    Alert.prototype.close = function(e) {
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove()
        }
        var $this = $(this)
          , selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"),
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = $("#" === selector ? [] : selector);
        e && e.preventDefault(),
        $parent.length || ($parent = $this.closest(".alert")),
        $parent.trigger(e = $.Event("close.bs.alert")),
        e.isDefaultPrevented() || ($parent.removeClass("in"),
        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement())
    }
    ;
    var old = $.fn.alert;
    $.fn.alert = Plugin,
    $.fn.alert.Constructor = Alert,
    $.fn.alert.noConflict = function() {
        return $.fn.alert = old,
        this
    }
    ,
    $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close)
}(jQuery),
function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.button")
              , options = "object" == typeof option && option;
            data || $this.data("bs.button", data = new Button(this,options)),
            "toggle" == option ? data.toggle() : option && data.setState(option)
        })
    }
    var Button = function(element, options) {
        this.$element = $(element),
        this.options = $.extend({}, Button.DEFAULTS, options),
        this.isLoading = !1
    };
    Button.VERSION = "3.3.7",
    Button.DEFAULTS = {
        loadingText: "loading..."
    },
    Button.prototype.setState = function(state) {
        var d = "disabled"
          , $el = this.$element
          , val = $el.is("input") ? "val" : "html"
          , data = $el.data();
        state += "Text",
        null == data.resetText && $el.data("resetText", $el[val]()),
        setTimeout($.proxy(function() {
            $el[val](null == data[state] ? this.options[state] : data[state]),
            "loadingText" == state ? (this.isLoading = !0,
            $el.addClass(d).attr(d, d).prop(d, !0)) : this.isLoading && (this.isLoading = !1,
            $el.removeClass(d).removeAttr(d).prop(d, !1))
        }, this), 0)
    }
    ,
    Button.prototype.toggle = function() {
        var changed = !0
          , $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            "radio" == $input.prop("type") ? ($input.prop("checked") && (changed = !1),
            $parent.find(".active").removeClass("active"),
            this.$element.addClass("active")) : "checkbox" == $input.prop("type") && ($input.prop("checked") !== this.$element.hasClass("active") && (changed = !1),
            this.$element.toggleClass("active")),
            $input.prop("checked", this.$element.hasClass("active")),
            changed && $input.trigger("change")
        } else
            this.$element.attr("aria-pressed", !this.$element.hasClass("active")),
            this.$element.toggleClass("active")
    }
    ;
    var old = $.fn.button;
    $.fn.button = Plugin,
    $.fn.button.Constructor = Button,
    $.fn.button.noConflict = function() {
        return $.fn.button = old,
        this
    }
    ,
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle"),
        $(e.target).is('input[type="radio"], input[type="checkbox"]') || (e.preventDefault(),
        $btn.is("input,button") ? $btn.trigger("focus") : $btn.find("input:visible,button:visible").first().trigger("focus"))
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type))
    })
}(jQuery),
function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.carousel")
              , options = $.extend({}, Carousel.DEFAULTS, $this.data(), "object" == typeof option && option)
              , action = "string" == typeof option ? option : options.slide;
            data || $this.data("bs.carousel", data = new Carousel(this,options)),
            "number" == typeof option ? data.to(option) : action ? data[action]() : options.interval && data.pause().cycle()
        })
    }
    var Carousel = function(element, options) {
        this.$element = $(element),
        this.$indicators = this.$element.find(".carousel-indicators"),
        this.options = options,
        this.paused = null,
        this.sliding = null,
        this.interval = null,
        this.$active = null,
        this.$items = null,
        this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this)),
        "hover" == this.options.pause && !("ontouchstart"in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this))
    };
    Carousel.VERSION = "3.3.7",
    Carousel.TRANSITION_DURATION = 600,
    Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    },
    Carousel.prototype.keydown = function(e) {
        if (!/input|textarea/i.test(e.target.tagName)) {
            switch (e.which) {
            case 37:
                this.prev();
                break;
            case 39:
                this.next();
                break;
            default:
                return
            }
            e.preventDefault()
        }
    }
    ,
    Carousel.prototype.cycle = function(e) {
        return e || (this.paused = !1),
        this.interval && clearInterval(this.interval),
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval)),
        this
    }
    ,
    Carousel.prototype.getItemIndex = function(item) {
        return this.$items = item.parent().children(".item"),
        this.$items.index(item || this.$active)
    }
    ,
    Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        if (("prev" == direction && 0 === activeIndex || "next" == direction && activeIndex == this.$items.length - 1) && !this.options.wrap)
            return active;
        var delta = "prev" == direction ? -1 : 1
          , itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex)
    }
    ,
    Carousel.prototype.to = function(pos) {
        var that = this
          , activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (!(pos > this.$items.length - 1 || pos < 0))
            return this.sliding ? this.$element.one("slid.bs.carousel", function() {
                that.to(pos)
            }) : activeIndex == pos ? this.pause().cycle() : this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos))
    }
    ,
    Carousel.prototype.pause = function(e) {
        return e || (this.paused = !0),
        this.$element.find(".next, .prev").length && $.support.transition && (this.$element.trigger($.support.transition.end),
        this.cycle(!0)),
        this.interval = clearInterval(this.interval),
        this
    }
    ,
    Carousel.prototype.next = function() {
        if (!this.sliding)
            return this.slide("next")
    }
    ,
    Carousel.prototype.prev = function() {
        if (!this.sliding)
            return this.slide("prev")
    }
    ,
    Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active")
          , $next = next || this.getItemForDirection(type, $active)
          , isCycling = this.interval
          , direction = "next" == type ? "left" : "right"
          , that = this;
        if ($next.hasClass("active"))
            return this.sliding = !1;
        var relatedTarget = $next[0]
          , slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if (this.$element.trigger(slideEvent),
        !slideEvent.isDefaultPrevented()) {
            if (this.sliding = !0,
            isCycling && this.pause(),
            this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
                $nextIndicator && $nextIndicator.addClass("active")
            }
            var slidEvent = $.Event("slid.bs.carousel", {
                relatedTarget: relatedTarget,
                direction: direction
            });
            return $.support.transition && this.$element.hasClass("slide") ? ($next.addClass(type),
            $next[0].offsetWidth,
            $active.addClass(direction),
            $next.addClass(direction),
            $active.one("bsTransitionEnd", function() {
                $next.removeClass([type, direction].join(" ")).addClass("active"),
                $active.removeClass(["active", direction].join(" ")),
                that.sliding = !1,
                setTimeout(function() {
                    that.$element.trigger(slidEvent)
                }, 0)
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION)) : ($active.removeClass("active"),
            $next.addClass("active"),
            this.sliding = !1,
            this.$element.trigger(slidEvent)),
            isCycling && this.cycle(),
            this
        }
    }
    ;
    var old = $.fn.carousel;
    $.fn.carousel = Plugin,
    $.fn.carousel.Constructor = Carousel,
    $.fn.carousel.noConflict = function() {
        return $.fn.carousel = old,
        this
    }
    ;
    var clickHandler = function(e) {
        var href, $this = $(this), $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        if ($target.hasClass("carousel")) {
            var options = $.extend({}, $target.data(), $this.data())
              , slideIndex = $this.attr("data-slide-to");
            slideIndex && (options.interval = !1),
            Plugin.call($target, options),
            slideIndex && $target.data("bs.carousel").to(slideIndex),
            e.preventDefault()
        }
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler),
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data())
        })
    })
}(jQuery),
function($) {
    "use strict";
    function getTargetFromTrigger($trigger) {
        var href, target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        return $(target)
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.collapse")
              , options = $.extend({}, Collapse.DEFAULTS, $this.data(), "object" == typeof option && option);
            !data && options.toggle && /show|hide/.test(option) && (options.toggle = !1),
            data || $this.data("bs.collapse", data = new Collapse(this,options)),
            "string" == typeof option && data[option]()
        })
    }
    var Collapse = function(element, options) {
        this.$element = $(element),
        this.options = $.extend({}, Collapse.DEFAULTS, options),
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],[data-toggle="collapse"][data-target="#' + element.id + '"]'),
        this.transitioning = null,
        this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger),
        this.options.toggle && this.toggle()
    };
    Collapse.VERSION = "3.3.7",
    Collapse.TRANSITION_DURATION = 350,
    Collapse.DEFAULTS = {
        toggle: !0
    },
    Collapse.prototype.dimension = function() {
        return this.$element.hasClass("width") ? "width" : "height"
    }
    ,
    Collapse.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var activesData, actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(actives && actives.length && (activesData = actives.data("bs.collapse")) && activesData.transitioning)) {
                var startEvent = $.Event("show.bs.collapse");
                if (this.$element.trigger(startEvent),
                !startEvent.isDefaultPrevented()) {
                    actives && actives.length && (Plugin.call(actives, "hide"),
                    activesData || actives.data("bs.collapse", null));
                    var dimension = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", !0),
                    this.$trigger.removeClass("collapsed").attr("aria-expanded", !0),
                    this.transitioning = 1;
                    var complete = function() {
                        this.$element.removeClass("collapsing").addClass("collapse in")[dimension](""),
                        this.transitioning = 0,
                        this.$element.trigger("shown.bs.collapse")
                    };
                    if (!$.support.transition)
                        return complete.call(this);
                    var scrollSize = $.camelCase(["scroll", dimension].join("-"));
                    this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
                }
            }
        }
    }
    ,
    Collapse.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var startEvent = $.Event("hide.bs.collapse");
            if (this.$element.trigger(startEvent),
            !startEvent.isDefaultPrevented()) {
                var dimension = this.dimension();
                this.$element[dimension](this.$element[dimension]())[0].offsetHeight,
                this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1),
                this.$trigger.addClass("collapsed").attr("aria-expanded", !1),
                this.transitioning = 1;
                var complete = function() {
                    this.transitioning = 0,
                    this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
                };
                if (!$.support.transition)
                    return complete.call(this);
                this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)
            }
        }
    }
    ,
    Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]()
    }
    ,
    Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
        }, this)).end()
    }
    ,
    Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen),
        $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen)
    }
    ;
    var old = $.fn.collapse;
    $.fn.collapse = Plugin,
    $.fn.collapse.Constructor = Collapse,
    $.fn.collapse.noConflict = function() {
        return $.fn.collapse = old,
        this
    }
    ,
    $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        $this.attr("data-target") || e.preventDefault();
        var $target = getTargetFromTrigger($this)
          , data = $target.data("bs.collapse")
          , option = data ? "toggle" : $this.data();
        Plugin.call($target, option)
    })
}(jQuery),
function($) {
    "use strict";
    function getParent($this) {
        var selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"),
        selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent()
    }
    function clearMenus(e) {
        e && 3 === e.which || ($(backdrop).remove(),
        $(toggle).each(function() {
            var $this = $(this)
              , $parent = getParent($this)
              , relatedTarget = {
                relatedTarget: this
            };
            $parent.hasClass("open") && (e && "click" == e.type && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target) || ($parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget)),
            e.isDefaultPrevented() || ($this.attr("aria-expanded", "false"),
            $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget)))))
        }))
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.dropdown");
            data || $this.data("bs.dropdown", data = new Dropdown(this)),
            "string" == typeof option && data[option].call($this)
        })
    }
    var backdrop = ".dropdown-backdrop"
      , toggle = '[data-toggle="dropdown"]'
      , Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle)
    };
    Dropdown.VERSION = "3.3.7",
    Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if (!$this.is(".disabled, :disabled")) {
            var $parent = getParent($this)
              , isActive = $parent.hasClass("open");
            if (clearMenus(),
            !isActive) {
                "ontouchstart"in document.documentElement && !$parent.closest(".navbar-nav").length && $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
                var relatedTarget = {
                    relatedTarget: this
                };
                if ($parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget)),
                e.isDefaultPrevented())
                    return;
                $this.trigger("focus").attr("aria-expanded", "true"),
                $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget))
            }
            return !1
        }
    }
    ,
    Dropdown.prototype.keydown = function(e) {
        if (/(38|40|27|32)/.test(e.which) && !/input|textarea/i.test(e.target.tagName)) {
            var $this = $(this);
            if (e.preventDefault(),
            e.stopPropagation(),
            !$this.is(".disabled, :disabled")) {
                var $parent = getParent($this)
                  , isActive = $parent.hasClass("open");
                if (!isActive && 27 != e.which || isActive && 27 == e.which)
                    return 27 == e.which && $parent.find(toggle).trigger("focus"),
                    $this.trigger("click");
                var $items = $parent.find(".dropdown-menu li:not(.disabled):visible a");
                if ($items.length) {
                    var index = $items.index(e.target);
                    38 == e.which && index > 0 && index--,
                    40 == e.which && index < $items.length - 1 && index++,
                    ~index || (index = 0),
                    $items.eq(index).trigger("focus")
                }
            }
        }
    }
    ;
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin,
    $.fn.dropdown.Constructor = Dropdown,
    $.fn.dropdown.noConflict = function() {
        return $.fn.dropdown = old,
        this
    }
    ,
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation()
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown)
}(jQuery),
function($) {
    "use strict";
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.modal")
              , options = $.extend({}, Modal.DEFAULTS, $this.data(), "object" == typeof option && option);
            data || $this.data("bs.modal", data = new Modal(this,options)),
            "string" == typeof option ? data[option](_relatedTarget) : options.show && data.show(_relatedTarget)
        })
    }
    var Modal = function(element, options) {
        this.options = options,
        this.$body = $(document.body),
        this.$element = $(element),
        this.$dialog = this.$element.find(".modal-dialog"),
        this.$backdrop = null,
        this.isShown = null,
        this.originalBodyPad = null,
        this.scrollbarWidth = 0,
        this.ignoreBackdropClick = !1,
        this.options.remote && this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
            this.$element.trigger("loaded.bs.modal")
        }, this))
    };
    Modal.VERSION = "3.3.7",
    Modal.TRANSITION_DURATION = 300,
    Modal.BACKDROP_TRANSITION_DURATION = 150,
    Modal.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    },
    Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget)
    }
    ,
    Modal.prototype.show = function(_relatedTarget) {
        var that = this
          , e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e),
        this.isShown || e.isDefaultPrevented() || (this.isShown = !0,
        this.checkScrollbar(),
        this.setScrollbar(),
        this.$body.addClass("modal-open"),
        this.escape(),
        this.resize(),
        this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this)),
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                $(e.target).is(that.$element) && (that.ignoreBackdropClick = !0)
            })
        }),
        this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            that.$element.parent().length || that.$element.appendTo(that.$body),
            that.$element.show().scrollTop(0),
            that.adjustDialog(),
            transition && that.$element[0].offsetWidth,
            that.$element.addClass("in"),
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e)
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e)
        }))
    }
    ,
    Modal.prototype.hide = function(e) {
        e && e.preventDefault(),
        e = $.Event("hide.bs.modal"),
        this.$element.trigger(e),
        this.isShown && !e.isDefaultPrevented() && (this.isShown = !1,
        this.escape(),
        this.resize(),
        $(document).off("focusin.bs.modal"),
        this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),
        this.$dialog.off("mousedown.dismiss.bs.modal"),
        $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal())
    }
    ,
    Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            document === e.target || this.$element[0] === e.target || this.$element.has(e.target).length || this.$element.trigger("focus")
        }, this))
    }
    ,
    Modal.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
            27 == e.which && this.hide()
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
    }
    ,
    Modal.prototype.resize = function() {
        this.isShown ? $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this)) : $(window).off("resize.bs.modal")
    }
    ,
    Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide(),
        this.backdrop(function() {
            that.$body.removeClass("modal-open"),
            that.resetAdjustments(),
            that.resetScrollbar(),
            that.$element.trigger("hidden.bs.modal")
        })
    }
    ,
    Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(),
        this.$backdrop = null
    }
    ,
    Modal.prototype.backdrop = function(callback) {
        var that = this
          , animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            if (this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body),
            this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
                if (this.ignoreBackdropClick)
                    return void (this.ignoreBackdropClick = !1);
                e.target === e.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide())
            }, this)),
            doAnimate && this.$backdrop[0].offsetWidth,
            this.$backdrop.addClass("in"),
            !callback)
                return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop(),
                callback && callback()
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove()
        } else
            callback && callback()
    }
    ,
    Modal.prototype.handleUpdate = function() {
        this.adjustDialog()
    }
    ,
    Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        })
    }
    ,
    Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        })
    }
    ,
    Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth,
        this.scrollbarWidth = this.measureScrollbar()
    }
    ,
    Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "",
        this.bodyIsOverflowing && this.$body.css("padding-right", bodyPad + this.scrollbarWidth)
    }
    ,
    Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad)
    }
    ,
    Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure",
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        return this.$body[0].removeChild(scrollDiv),
        scrollbarWidth
    }
    ;
    var old = $.fn.modal;
    $.fn.modal = Plugin,
    $.fn.modal.Constructor = Modal,
    $.fn.modal.noConflict = function() {
        return $.fn.modal = old,
        this
    }
    ,
    $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this)
          , href = $this.attr("href")
          , $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, ""))
          , option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        $this.is("a") && e.preventDefault(),
        $target.one("show.bs.modal", function(showEvent) {
            showEvent.isDefaultPrevented() || $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus")
            })
        }),
        Plugin.call($target, option, this)
    })
}(jQuery),
function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.tooltip")
              , options = "object" == typeof option && option;
            !data && /destroy|hide/.test(option) || (data || $this.data("bs.tooltip", data = new Tooltip(this,options)),
            "string" == typeof option && data[option]())
        })
    }
    var Tooltip = function(element, options) {
        this.type = null,
        this.options = null,
        this.enabled = null,
        this.timeout = null,
        this.hoverState = null,
        this.$element = null,
        this.inState = null,
        this.init("tooltip", element, options)
    };
    Tooltip.VERSION = "3.3.7",
    Tooltip.TRANSITION_DURATION = 150,
    Tooltip.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {
            selector: "body",
            padding: 0
        }
    },
    Tooltip.prototype.init = function(type, element, options) {
        if (this.enabled = !0,
        this.type = type,
        this.$element = $(element),
        this.options = this.getOptions(options),
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport),
        this.inState = {
            click: !1,
            hover: !1,
            focus: !1
        },
        this.$element[0]instanceof document.constructor && !this.options.selector)
            throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var triggers = this.options.trigger.split(" "), i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if ("click" == trigger)
                this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
            else if ("manual" != trigger) {
                var eventIn = "hover" == trigger ? "mouseenter" : "focusin"
                  , eventOut = "hover" == trigger ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this)),
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle()
    }
    ,
    Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS
    }
    ,
    Tooltip.prototype.getOptions = function(options) {
        return options = $.extend({}, this.getDefaults(), this.$element.data(), options),
        options.delay && "number" == typeof options.delay && (options.delay = {
            show: options.delay,
            hide: options.delay
        }),
        options
    }
    ,
    Tooltip.prototype.getDelegateOptions = function() {
        var options = {}
          , defaults = this.getDefaults();
        return this._options && $.each(this._options, function(key, value) {
            defaults[key] != value && (options[key] = value)
        }),
        options
    }
    ,
    Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        return self || (self = new this.constructor(obj.currentTarget,this.getDelegateOptions()),
        $(obj.currentTarget).data("bs." + this.type, self)),
        obj instanceof $.Event && (self.inState["focusin" == obj.type ? "focus" : "hover"] = !0),
        self.tip().hasClass("in") || "in" == self.hoverState ? void (self.hoverState = "in") : (clearTimeout(self.timeout),
        self.hoverState = "in",
        self.options.delay && self.options.delay.show ? void (self.timeout = setTimeout(function() {
            "in" == self.hoverState && self.show()
        }, self.options.delay.show)) : self.show())
    }
    ,
    Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState)
            if (this.inState[key])
                return !0;
        return !1
    }
    ,
    Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (self || (self = new this.constructor(obj.currentTarget,this.getDelegateOptions()),
        $(obj.currentTarget).data("bs." + this.type, self)),
        obj instanceof $.Event && (self.inState["focusout" == obj.type ? "focus" : "hover"] = !1),
        !self.isInStateTrue()) {
            if (clearTimeout(self.timeout),
            self.hoverState = "out",
            !self.options.delay || !self.options.delay.hide)
                return self.hide();
            self.timeout = setTimeout(function() {
                "out" == self.hoverState && self.hide()
            }, self.options.delay.hide)
        }
    }
    ,
    Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom)
                return;
            var that = this
              , $tip = this.tip()
              , tipId = this.getUID(this.type);
            this.setContent(),
            $tip.attr("id", tipId),
            this.$element.attr("aria-describedby", tipId),
            this.options.animation && $tip.addClass("fade");
            var placement = "function" == typeof this.options.placement ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement
              , autoToken = /\s?auto?\s?/i
              , autoPlace = autoToken.test(placement);
            autoPlace && (placement = placement.replace(autoToken, "") || "top"),
            $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this),
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element),
            this.$element.trigger("inserted.bs." + this.type);
            var pos = this.getPosition()
              , actualWidth = $tip[0].offsetWidth
              , actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement
                  , viewportDim = this.getPosition(this.$viewport);
                placement = "bottom" == placement && pos.bottom + actualHeight > viewportDim.bottom ? "top" : "top" == placement && pos.top - actualHeight < viewportDim.top ? "bottom" : "right" == placement && pos.right + actualWidth > viewportDim.width ? "left" : "left" == placement && pos.left - actualWidth < viewportDim.left ? "right" : placement,
                $tip.removeClass(orgPlacement).addClass(placement)
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type),
                that.hoverState = null,
                "out" == prevHoverState && that.leave(that)
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete()
        }
    }
    ,
    Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip()
          , width = $tip[0].offsetWidth
          , height = $tip[0].offsetHeight
          , marginTop = parseInt($tip.css("margin-top"), 10)
          , marginLeft = parseInt($tip.css("margin-left"), 10);
        isNaN(marginTop) && (marginTop = 0),
        isNaN(marginLeft) && (marginLeft = 0),
        offset.top += marginTop,
        offset.left += marginLeft,
        $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                })
            }
        }, offset), 0),
        $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth
          , actualHeight = $tip[0].offsetHeight;
        "top" == placement && actualHeight != height && (offset.top = offset.top + height - actualHeight);
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        delta.left ? offset.left += delta.left : offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement)
          , arrowDelta = isVertical ? 2 * delta.left - width + actualWidth : 2 * delta.top - height + actualHeight
          , arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset),
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
    }
    ,
    Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "")
    }
    ,
    Tooltip.prototype.setContent = function() {
        var $tip = this.tip()
          , title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title),
        $tip.removeClass("fade in top bottom left right")
    }
    ,
    Tooltip.prototype.hide = function(callback) {
        function complete() {
            "in" != that.hoverState && $tip.detach(),
            that.$element && that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type),
            callback && callback()
        }
        var that = this
          , $tip = $(this.$tip)
          , e = $.Event("hide.bs." + this.type);
        if (this.$element.trigger(e),
        !e.isDefaultPrevented())
            return $tip.removeClass("in"),
            $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete(),
            this.hoverState = null,
            this
    }
    ,
    Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        ($e.attr("title") || "string" != typeof $e.attr("data-original-title")) && $e.attr("data-original-title", $e.attr("title") || "").attr("title", "")
    }
    ,
    Tooltip.prototype.hasContent = function() {
        return this.getTitle()
    }
    ,
    Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0]
          , isBody = "BODY" == el.tagName
          , elRect = el.getBoundingClientRect();
        null == elRect.width && (elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
        }));
        var isSvg = window.SVGElement && el instanceof window.SVGElement
          , elOffset = isBody ? {
            top: 0,
            left: 0
        } : isSvg ? null : $element.offset()
          , scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        }
          , outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset)
    }
    ,
    Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return "bottom" == placement ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "top" == placement ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "left" == placement ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        }
    }
    ,
    Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport)
            return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
          , viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll
              , bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            topEdgeOffset < viewportDimensions.top ? delta.top = viewportDimensions.top - topEdgeOffset : bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height && (delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset)
        } else {
            var leftEdgeOffset = pos.left - viewportPadding
              , rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            leftEdgeOffset < viewportDimensions.left ? delta.left = viewportDimensions.left - leftEdgeOffset : rightEdgeOffset > viewportDimensions.right && (delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset)
        }
        return delta
    }
    ,
    Tooltip.prototype.getTitle = function() {
        var $e = this.$element
          , o = this.options;
        return $e.attr("data-original-title") || ("function" == typeof o.title ? o.title.call($e[0]) : o.title)
    }
    ,
    Tooltip.prototype.getUID = function(prefix) {
        do {
            prefix += ~~(1e6 * Math.random())
        } while (document.getElementById(prefix));
        return prefix
    }
    ,
    Tooltip.prototype.tip = function() {
        if (!this.$tip && (this.$tip = $(this.options.template),
        1 != this.$tip.length))
            throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip
    }
    ,
    Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }
    ,
    Tooltip.prototype.enable = function() {
        this.enabled = !0
    }
    ,
    Tooltip.prototype.disable = function() {
        this.enabled = !1
    }
    ,
    Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled
    }
    ,
    Tooltip.prototype.toggle = function(e) {
        var self = this;
        e && ((self = $(e.currentTarget).data("bs." + this.type)) || (self = new this.constructor(e.currentTarget,this.getDelegateOptions()),
        $(e.currentTarget).data("bs." + this.type, self))),
        e ? (self.inState.click = !self.inState.click,
        self.isInStateTrue() ? self.enter(self) : self.leave(self)) : self.tip().hasClass("in") ? self.leave(self) : self.enter(self)
    }
    ,
    Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout),
        this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type),
            that.$tip && that.$tip.detach(),
            that.$tip = null,
            that.$arrow = null,
            that.$viewport = null,
            that.$element = null
        })
    }
    ;
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin,
    $.fn.tooltip.Constructor = Tooltip,
    $.fn.tooltip.noConflict = function() {
        return $.fn.tooltip = old,
        this
    }
}(jQuery),
function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.popover")
              , options = "object" == typeof option && option;
            !data && /destroy|hide/.test(option) || (data || $this.data("bs.popover", data = new Popover(this,options)),
            "string" == typeof option && data[option]())
        })
    }
    var Popover = function(element, options) {
        this.init("popover", element, options)
    };
    if (!$.fn.tooltip)
        throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.7",
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }),
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype),
    Popover.prototype.constructor = Popover,
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS
    }
    ,
    Popover.prototype.setContent = function() {
        var $tip = this.tip()
          , title = this.getTitle()
          , content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title),
        $tip.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof content ? "html" : "append" : "text"](content),
        $tip.removeClass("fade top bottom left right in"),
        $tip.find(".popover-title").html() || $tip.find(".popover-title").hide()
    }
    ,
    Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent()
    }
    ,
    Popover.prototype.getContent = function() {
        var $e = this.$element
          , o = this.options;
        return $e.attr("data-content") || ("function" == typeof o.content ? o.content.call($e[0]) : o.content)
    }
    ,
    Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow")
    }
    ;
    var old = $.fn.popover;
    $.fn.popover = Plugin,
    $.fn.popover.Constructor = Popover,
    $.fn.popover.noConflict = function() {
        return $.fn.popover = old,
        this
    }
}(jQuery),
function($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body),
        this.$scrollElement = $($(element).is(document.body) ? window : element),
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options),
        this.selector = (this.options.target || "") + " .nav li > a",
        this.offsets = [],
        this.targets = [],
        this.activeTarget = null,
        this.scrollHeight = 0,
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this)),
        this.refresh(),
        this.process()
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.scrollspy")
              , options = "object" == typeof option && option;
            data || $this.data("bs.scrollspy", data = new ScrollSpy(this,options)),
            "string" == typeof option && data[option]()
        })
    }
    ScrollSpy.VERSION = "3.3.7",
    ScrollSpy.DEFAULTS = {
        offset: 10
    },
    ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }
    ,
    ScrollSpy.prototype.refresh = function() {
        var that = this
          , offsetMethod = "offset"
          , offsetBase = 0;
        this.offsets = [],
        this.targets = [],
        this.scrollHeight = this.getScrollHeight(),
        $.isWindow(this.$scrollElement[0]) || (offsetMethod = "position",
        offsetBase = this.$scrollElement.scrollTop()),
        this.$body.find(this.selector).map(function() {
            var $el = $(this)
              , href = $el.data("target") || $el.attr("href")
              , $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [[$href[offsetMethod]().top + offsetBase, href]] || null
        }).sort(function(a, b) {
            return a[0] - b[0]
        }).each(function() {
            that.offsets.push(this[0]),
            that.targets.push(this[1])
        })
    }
    ,
    ScrollSpy.prototype.process = function() {
        var i, scrollTop = this.$scrollElement.scrollTop() + this.options.offset, scrollHeight = this.getScrollHeight(), maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height(), offsets = this.offsets, targets = this.targets, activeTarget = this.activeTarget;
        if (this.scrollHeight != scrollHeight && this.refresh(),
        scrollTop >= maxScroll)
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        if (activeTarget && scrollTop < offsets[0])
            return this.activeTarget = null,
            this.clear();
        for (i = offsets.length; i--; )
            activeTarget != targets[i] && scrollTop >= offsets[i] && (void 0 === offsets[i + 1] || scrollTop < offsets[i + 1]) && this.activate(targets[i])
    }
    ,
    ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target,
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]'
          , active = $(selector).parents("li").addClass("active");
        active.parent(".dropdown-menu").length && (active = active.closest("li.dropdown").addClass("active")),
        active.trigger("activate.bs.scrollspy")
    }
    ,
    ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
    }
    ;
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin,
    $.fn.scrollspy.Constructor = ScrollSpy,
    $.fn.scrollspy.noConflict = function() {
        return $.fn.scrollspy = old,
        this
    }
    ,
    $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data())
        })
    })
}(jQuery),
function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.tab");
            data || $this.data("bs.tab", data = new Tab(this)),
            "string" == typeof option && data[option]()
        })
    }
    var Tab = function(element) {
        this.element = $(element)
    };
    Tab.VERSION = "3.3.7",
    Tab.TRANSITION_DURATION = 150,
    Tab.prototype.show = function() {
        var $this = this.element
          , $ul = $this.closest("ul:not(.dropdown-menu)")
          , selector = $this.data("target");
        if (selector || (selector = $this.attr("href"),
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")),
        !$this.parent("li").hasClass("active")) {
            var $previous = $ul.find(".active:last a")
              , hideEvent = $.Event("hide.bs.tab", {
                relatedTarget: $this[0]
            })
              , showEvent = $.Event("show.bs.tab", {
                relatedTarget: $previous[0]
            });
            if ($previous.trigger(hideEvent),
            $this.trigger(showEvent),
            !showEvent.isDefaultPrevented() && !hideEvent.isDefaultPrevented()) {
                var $target = $(selector);
                this.activate($this.closest("li"), $ul),
                this.activate($target, $target.parent(), function() {
                    $previous.trigger({
                        type: "hidden.bs.tab",
                        relatedTarget: $this[0]
                    }),
                    $this.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: $previous[0]
                    })
                })
            }
        }
    }
    ,
    Tab.prototype.activate = function(element, container, callback) {
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1),
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0),
            transition ? (element[0].offsetWidth,
            element.addClass("in")) : element.removeClass("fade"),
            element.parent(".dropdown-menu").length && element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0),
            callback && callback()
        }
        var $active = container.find("> .active")
          , transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next(),
        $active.removeClass("in")
    }
    ;
    var old = $.fn.tab;
    $.fn.tab = Plugin,
    $.fn.tab.Constructor = Tab,
    $.fn.tab.noConflict = function() {
        return $.fn.tab = old,
        this
    }
    ;
    var clickHandler = function(e) {
        e.preventDefault(),
        Plugin.call($(this), "show")
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler)
}(jQuery),
function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this)
              , data = $this.data("bs.affix")
              , options = "object" == typeof option && option;
            data || $this.data("bs.affix", data = new Affix(this,options)),
            "string" == typeof option && data[option]()
        })
    }
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options),
        this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this)),
        this.$element = $(element),
        this.affixed = null,
        this.unpin = null,
        this.pinnedOffset = null,
        this.checkPosition()
    };
    Affix.VERSION = "3.3.7",
    Affix.RESET = "affix affix-top affix-bottom",
    Affix.DEFAULTS = {
        offset: 0,
        target: window
    },
    Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop()
          , position = this.$element.offset()
          , targetHeight = this.$target.height();
        if (null != offsetTop && "top" == this.affixed)
            return scrollTop < offsetTop && "top";
        if ("bottom" == this.affixed)
            return null != offsetTop ? !(scrollTop + this.unpin <= position.top) && "bottom" : !(scrollTop + targetHeight <= scrollHeight - offsetBottom) && "bottom";
        var initializing = null == this.affixed
          , colliderTop = initializing ? scrollTop : position.top
          , colliderHeight = initializing ? targetHeight : height;
        return null != offsetTop && scrollTop <= offsetTop ? "top" : null != offsetBottom && colliderTop + colliderHeight >= scrollHeight - offsetBottom && "bottom"
    }
    ,
    Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset)
            return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop()
          , position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop
    }
    ,
    Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1)
    }
    ,
    Affix.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var height = this.$element.height()
              , offset = this.options.offset
              , offsetTop = offset.top
              , offsetBottom = offset.bottom
              , scrollHeight = Math.max($(document).height(), $(document.body).height());
            "object" != typeof offset && (offsetBottom = offsetTop = offset),
            "function" == typeof offsetTop && (offsetTop = offset.top(this.$element)),
            "function" == typeof offsetBottom && (offsetBottom = offset.bottom(this.$element));
            var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
            if (this.affixed != affix) {
                null != this.unpin && this.$element.css("top", "");
                var affixType = "affix" + (affix ? "-" + affix : "")
                  , e = $.Event(affixType + ".bs.affix");
                if (this.$element.trigger(e),
                e.isDefaultPrevented())
                    return;
                this.affixed = affix,
                this.unpin = "bottom" == affix ? this.getPinnedOffset() : null,
                this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix")
            }
            "bottom" == affix && this.$element.offset({
                top: scrollHeight - height - offsetBottom
            })
        }
    }
    ;
    var old = $.fn.affix;
    $.fn.affix = Plugin,
    $.fn.affix.Constructor = Affix,
    $.fn.affix.noConflict = function() {
        return $.fn.affix = old,
        this
    }
    ,
    $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this)
              , data = $spy.data();
            data.offset = data.offset || {},
            null != data.offsetBottom && (data.offset.bottom = data.offsetBottom),
            null != data.offsetTop && (data.offset.top = data.offsetTop),
            Plugin.call($spy, data)
        })
    })
}(jQuery),
function(window, document, undefined) {
    "use strict";
    function minErr(module, ErrorConstructor) {
        return ErrorConstructor = ErrorConstructor || Error,
        function() {
            var message, i, code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments;
            for (message = prefix + template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1);
                return index + 2 < templateArgs.length ? toDebugString(templateArgs[index + 2]) : match
            }),
            message = message + "\nhttp://errors.angularjs.org/1.3.20/" + (module ? module + "/" : "") + code,
            i = 2; i < arguments.length; i++)
                message = message + (2 == i ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(toDebugString(arguments[i]));
            return new ErrorConstructor(message)
        }
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj))
            return !1;
        var length = "length"in Object(obj) && obj.length;
        return !(obj.nodeType !== NODE_TYPE_ELEMENT || !length) || (isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj)
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj)
            if (isFunction(obj))
                for (key in obj)
                    "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key, obj);
            else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = "object" != typeof obj;
                for (key = 0,
                length = obj.length; key < length; key++)
                    (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj)
            } else if (obj.forEach && obj.forEach !== forEach)
                obj.forEach(iterator, context, obj);
            else
                for (key in obj)
                    obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj);
        return obj
    }
    function sortedKeys(obj) {
        return Object.keys(obj).sort()
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++)
            iterator.call(context, obj[keys[i]], keys[i]);
        return keys
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value)
        }
    }
    function nextUid() {
        return ++uid
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey
    }
    function extend(dst) {
        for (var h = dst.$$hashKey, i = 1, ii = arguments.length; i < ii; i++) {
            var obj = arguments[i];
            if (obj)
                for (var keys = Object.keys(obj), j = 0, jj = keys.length; j < jj; j++) {
                    var key = keys[j];
                    dst[key] = obj[key]
                }
        }
        return setHashKey(dst, h),
        dst
    }
    function int(str) {
        return parseInt(str, 10)
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra)
    }
    function noop() {}
    function identity($) {
        return $
    }
    function valueFn(value) {
        return function() {
            return value
        }
    }
    function isUndefined(value) {
        return void 0 === value
    }
    function isDefined(value) {
        return void 0 !== value
    }
    function isObject(value) {
        return null !== value && "object" == typeof value
    }
    function isString(value) {
        return "string" == typeof value
    }
    function isNumber(value) {
        return "number" == typeof value
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value)
    }
    function isFunction(value) {
        return "function" == typeof value
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value)
    }
    function isWindow(obj) {
        return obj && obj.window === obj
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj)
    }
    function isFormData(obj) {
        return "[object FormData]" === toString.call(obj)
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj)
    }
    function isBoolean(value) {
        return "boolean" == typeof value
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then)
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find))
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++)
            obj[items[i]] = !0;
        return obj
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName)
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && array.splice(index, 1),
        value
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source))
            throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        if (destination) {
            if (source === destination)
                throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            if (stackSource = stackSource || [],
            stackDest = stackDest || [],
            isObject(source)) {
                var index = stackSource.indexOf(source);
                if (-1 !== index)
                    return stackDest[index];
                stackSource.push(source),
                stackDest.push(destination)
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++)
                    result = copy(source[i], null, stackSource, stackDest),
                    isObject(source[i]) && (stackSource.push(source[i]),
                    stackDest.push(result)),
                    destination.push(result)
            } else {
                var h = destination.$$hashKey;
                isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                    delete destination[key]
                });
                for (var key in source)
                    source.hasOwnProperty(key) && (result = copy(source[key], null, stackSource, stackDest),
                    isObject(source[key]) && (stackSource.push(source[key]),
                    stackDest.push(result)),
                    destination[key] = result);
                setHashKey(destination, h)
            }
        } else if (destination = source,
        source)
            if (isArray(source))
                destination = copy(source, [], stackSource, stackDest);
            else if (isDate(source))
                destination = new Date(source.getTime());
            else if (isRegExp(source))
                destination = new RegExp(source.source,source.toString().match(/[^\/]*$/)[0]),
                destination.lastIndex = source.lastIndex;
            else if (isObject(source)) {
                var emptyObject = Object.create(Object.getPrototypeOf(source));
                destination = copy(source, emptyObject, stackSource, stackDest)
            }
        return destination
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; i < ii; i++)
                dst[i] = src[i]
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src)
                "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key])
        }
        return dst || src
    }
    function equals(o1, o2) {
        if (o1 === o2)
            return !0;
        if (null === o1 || null === o2)
            return !1;
        if (o1 !== o1 && o2 !== o2)
            return !0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 == t2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1))
                    return !!isDate(o2) && equals(o1.getTime(), o2.getTime());
                if (isRegExp(o1))
                    return !!isRegExp(o2) && o1.toString() == o2.toString();
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                    return !1;
                keySet = {};
                for (key in o1)
                    if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                        if (!equals(o1[key], o2[key]))
                            return !1;
                        keySet[key] = !0
                    }
                for (key in o2)
                    if (!keySet.hasOwnProperty(key) && "$" !== key.charAt(0) && o2[key] !== undefined && !isFunction(o2[key]))
                        return !1;
                return !0
            }
            if (!isArray(o2))
                return !1;
            if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++)
                    if (!equals(o1[key], o2[key]))
                        return !1;
                return !0
            }
        }
        return !1
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index))
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0)
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs)
        }
        : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self)
        }
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"),
        val
    }
    function toJson(obj, pretty) {
        return void 0 === obj ? undefined : (isNumber(pretty) || (pretty = pretty ? 2 : null),
        JSON.stringify(obj, toJsonReplacer, pretty))
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty()
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName)
            })
        } catch (e) {
            return lowercase(elemHtml)
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value)
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var key_value, key, obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue && (key_value = keyValue.replace(/\+/g, "%20").split("="),
            key = tryDecodeURIComponent(key_value[0]),
            isDefined(key))) {
                var val = !isDefined(key_value[1]) || tryDecodeURIComponent(key_value[1]);
                hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [obj[key], val] : obj[key] = val
            }
        }),
        obj
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (!0 === arrayValue ? "" : "=" + encodeUriQuery(arrayValue, !0)))
            }) : parts.push(encodeUriQuery(key, !0) + (!0 === value ? "" : "=" + encodeUriQuery(value, !0)))
        }),
        parts.length ? parts.join("&") : ""
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
    }
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (element = jqLite(element),
        i = 0; i < ii; ++i)
            if (attr = ngAttrPrefixes[i] + ngAttr,
            isString(attr = element.attr(attr)))
                return attr;
        return null
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element,
            module = element.getAttribute(name))
        }),
        forEach(ngAttrPrefixes, function(prefix) {
            var candidate, name = prefix + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate,
            module = candidate.getAttribute(name))
        }),
        appElement && (config.strictDi = null !== getNgAttribute(appElement, "strict-di"),
        bootstrap(appElement, module ? [module] : [], config))
    }
    function bootstrap(element, modules, config) {
        isObject(config) || (config = {}),
        config = extend({
            strictDi: !1
        }, config);
        var doBootstrap = function() {
            if (element = jqLite(element),
            element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"))
            }
            modules = modules || [],
            modules.unshift(["$provide", function($provide) {
                $provide.value("$rootElement", element)
            }
            ]),
            config.debugInfoEnabled && modules.push(["$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(!0)
            }
            ]),
            modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            return injector.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector),
                    compile(element)(scope)
                })
            }
            ]),
            injector
        }
          , NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/
          , NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0,
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")),
        window && !NG_DEFER_BOOTSTRAP.test(window.name))
            return doBootstrap();
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""),
        angular.resumeBootstrap = function(extraModules) {
            return forEach(extraModules, function(module) {
                modules.push(module)
            }),
            doBootstrap()
        }
        ,
        isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name,
        window.location.reload()
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector)
            throw ngMinErr("test", "no injector found for element argument to getTestability");
        return injector.get("$$testability")
    }
    function snake_case(name, separator) {
        return separator = separator || "_",
        name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase()
        })
    }
    function assertArg(arg, name, reason) {
        if (!arg)
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]),
        assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)),
        arg
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name)
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
    }
    function getter(obj, path, bindFnToScope) {
        if (!path)
            return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; i < len; i++)
            key = keys[i],
            obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj
    }
    function getBlockNodes(nodes) {
        var node = nodes[0]
          , endNode = nodes[nodes.length - 1]
          , blockNodes = [node];
        do {
            if (!(node = node.nextSibling))
                break;
            blockNodes.push(node)
        } while (node !== endNode);
        return jqLite(blockNodes)
    }
    function createMap() {
        return Object.create(null)
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory())
        }
        var $injectorMinErr = minErr("$injector")
          , ngMinErr = minErr("ng")
          , angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr,
        ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                return function(name, context) {
                    if ("hasOwnProperty" === name)
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
                }(name, "module"),
                requires && modules.hasOwnProperty(name) && (modules[name] = null),
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue || (queue = invokeQueue),
                        function() {
                            return queue[insertMethod || "push"]([provider, method, arguments]),
                            moduleInstance
                        }
                    }
                    if (!requires)
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = []
                      , configBlocks = []
                      , runBlocks = []
                      , config = invokeLater("$injector", "invoke", "push", configBlocks)
                      , moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block),
                            this
                        }
                    };
                    return configFn && config(configFn),
                    moduleInstance
                })
            }
        })
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            if (val = toJsonReplacer(key, val),
            isObject(val)) {
                if (seen.indexOf(val) >= 0)
                    return "<<already seen>>";
                seen.push(val)
            }
            return val
        })
    }
    function toDebugString(obj) {
        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : void 0 === obj ? "undefined" : "string" != typeof obj ? serializeObject(obj) : obj
    }
    function jqNextId() {
        return ++jqId
    }
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter
        }).replace(MOZ_HACK_REGEXP, "Moz$1")
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html)
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html))
            nodes.push(context.createTextNode(html));
        else {
            for (tmp = tmp || fragment.appendChild(context.createElement("div")),
            tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase(),
            wrap = wrapMap[tag] || wrapMap._default,
            tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2],
            i = wrap[0]; i--; )
                tmp = tmp.lastChild;
            nodes = concat(nodes, tmp.childNodes),
            tmp = fragment.firstChild,
            tmp.textContent = ""
        }
        return fragment.textContent = "",
        fragment.innerHTML = "",
        forEach(nodes, function(node) {
            fragment.appendChild(node)
        }),
        fragment
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [context.createElement(parsed[1])] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : []
    }
    function JQLite(element) {
        if (element instanceof JQLite)
            return element;
        var argIsString;
        if (isString(element) && (element = trim(element),
        argIsString = !0),
        !(this instanceof JQLite)) {
            if (argIsString && "<" != element.charAt(0))
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element)
        }
        argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : jqLiteAddNodes(this, element)
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0)
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (onlyDescendants || jqLiteRemoveData(element),
        element.querySelectorAll)
            for (var descendants = element.querySelectorAll("*"), i = 0, l = descendants.length; i < l; i++)
                jqLiteRemoveData(descendants[i])
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
            throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element)
          , events = expandoStore && expandoStore.events
          , handle = expandoStore && expandoStore.handle;
        if (handle)
            if (type)
                forEach(type.split(" "), function(type) {
                    if (isDefined(fn)) {
                        var listenerFns = events[type];
                        if (arrayRemove(listenerFns || [], fn),
                        listenerFns && listenerFns.length > 0)
                            return
                    }
                    removeEventListenerFn(element, type, handle),
                    delete events[type]
                });
            else
                for (type in events)
                    "$destroy" !== type && removeEventListenerFn(element, type, handle),
                    delete events[type]
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339
          , expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name)
                return void delete expandoStore.data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"),
            jqLiteOff(element)),
            delete jqCache[expandoId],
            element.ng339 = undefined
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339
          , expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(),
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
        }),
        expandoStore
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value)
              , isSimpleGetter = !isSimpleSetter && key && !isObject(key)
              , massGetter = !key
              , expandoStore = jqLiteExpandoStore(element, !isSimpleGetter)
              , data = expandoStore && expandoStore.data;
            if (isSimpleSetter)
                data[key] = value;
            else {
                if (massGetter)
                    return data;
                if (isSimpleGetter)
                    return data && data[key];
                extend(data, key)
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return !!element.getAttribute && (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")))
        })
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass),
                -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ")
            }),
            element.setAttribute("class", trim(existingClasses))
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements)
            if (elements.nodeType)
                root[root.length++] = elements;
            else {
                var length = elements.length;
                if ("number" == typeof length && elements.window !== elements) {
                    if (length)
                        for (var i = 0; i < length; i++)
                            root[root.length++] = elements[i]
                } else
                    root[root.length++] = elements
            }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller")
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType == NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [name]; element; ) {
            for (var i = 0, ii = names.length; i < ii; i++)
                if ((value = jqLite.data(element, names[i])) !== undefined)
                    return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; )
            element.removeChild(element.firstChild)
    }
    function jqLiteRemove(element, keepData) {
        keepData || jqLiteDealoc(element);
        var parent = element.parentNode;
        parent && parent.removeChild(element)
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window,
        "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action)
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr
    }
    function getAliasedAttrName(element, name) {
        var nodeName = element.nodeName;
        return ("INPUT" === nodeName || "TEXTAREA" === nodeName) && ALIASED_ATTR[name]
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented
            }
            ;
            var eventFns = events[type || event.type]
              , eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function() {
                        event.immediatePropagationStopped = !0,
                        event.stopPropagation && event.stopPropagation(),
                        originalStopImmediatePropagation && originalStopImmediatePropagation.call(event)
                    }
                }
                event.isImmediatePropagationStopped = function() {
                    return !0 === event.immediatePropagationStopped
                }
                ,
                eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                for (var i = 0; i < eventFnsLength; i++)
                    event.isImmediatePropagationStopped() || eventFns[i].call(element, event)
            }
        };
        return eventHandler.elem = element,
        eventHandler
    }
    function $$jqLiteProvider() {
        this.$get = function() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    return node.attr && (node = node[0]),
                    jqLiteHasClass(node, classes)
                },
                addClass: function(node, classes) {
                    return node.attr && (node = node[0]),
                    jqLiteAddClass(node, classes)
                },
                removeClass: function(node, classes) {
                    return node.attr && (node = node[0]),
                    jqLiteRemoveClass(node, classes)
                }
            })
        }
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key)
            return "function" == typeof key && (key = obj.$$hashKey()),
            key;
        var objType = typeof obj;
        return key = "function" == objType || "object" == objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid
            }
        }
        forEach(array, this.put, this)
    }
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, "")
          , args = fnText.match(FN_ARGS);
        return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn"
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [],
                fn.length) {
                    if (strictDi)
                        throw isString(name) && name || (name = fn.name || anonFn(fn)),
                        $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    fnText = fn.toString().replace(STRIP_COMMENTS, ""),
                    argDecl = fnText.match(FN_ARGS),
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name)
                        })
                    })
                }
                fn.$inject = $inject
            }
        } else
            isArray(fn) ? (last = fn.length - 1,
            assertArgFn(fn[last], "fn"),
            $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject
    }
    function createInjector(modulesToLoad, strictDi) {
        function supportObject(delegate) {
            return function(key, value) {
                if (!isObject(key))
                    return delegate(key, value);
                forEach(key, reverseParams(delegate))
            }
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"),
            (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)),
            !provider_.$get)
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_
        }
        function enforceReturnValue(name, factory) {
            return function() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result))
                    throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                return result
            }
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: !1 !== enforce ? enforceReturnValue(name, factoryFn) : factoryFn
            })
        }
        function service(name, constructor) {
            return factory(name, ["$injector", function($injector) {
                return $injector.instantiate(constructor)
            }
            ])
        }
        function value(name, val) {
            return factory(name, valueFn(val), !1)
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"),
            providerCache[name] = value,
            instanceCache[name] = value
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix)
              , orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                })
            }
        }
        function loadModules(modulesToLoad) {
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0,
                    ii = queue.length; i < ii; i++) {
                        var invokeArgs = queue[i]
                          , provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2])
                    }
                }
                if (!loadedModules.get(module)) {
                    loadedModules.put(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module),
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks),
                        runInvokeQueue(moduleFn._invokeQueue),
                        runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module")
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]),
                        e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack),
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e)
                    }
                }
            }),
            runBlocks
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING)
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName]
                }
                try {
                    return path.unshift(serviceName),
                    cache[serviceName] = INSTANTIATING,
                    cache[serviceName] = factory(serviceName, caller)
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName],
                    err
                } finally {
                    path.shift()
                }
            }
            function invoke(fn, self, locals, serviceName) {
                "string" == typeof locals && (serviceName = locals,
                locals = null);
                var length, i, key, args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                for (i = 0,
                length = $inject.length; i < length; i++) {
                    if ("string" != typeof (key = $inject[i]))
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName))
                }
                return isArray(fn) && (fn = fn[length]),
                fn.apply(self, args)
            }
            function instantiate(Type, locals, serviceName) {
                var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null)
                  , returnedValue = invoke(Type, instance, locals, serviceName);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name)
                }
            }
        }
        strictDi = !0 === strictDi;
        var INSTANTIATING = {}
          , providerSuffix = "Provider"
          , path = []
          , loadedModules = new HashMap([],!0)
          , providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }
          , providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            throw angular.isString(caller) && path.push(caller),
            $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "))
        })
          , instanceCache = {}
          , instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName)
        });
        return forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop)
        }),
        instanceInjector
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1
        }
        ,
        this.$get = ["$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return Array.prototype.some.call(list, function(element) {
                    if ("a" === nodeName_(element))
                        return result = element,
                        !0
                }),
                result
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset))
                    offset = offset();
                else if (isElement(offset)) {
                    var elem = offset[0]
                      , style = $window.getComputedStyle(elem);
                    offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom
                } else
                    isNumber(offset) || (offset = 0);
                return offset
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset)
                    }
                } else
                    $window.scrollTo(0, 0)
            }
            function scroll() {
                var elm, hash = $location.hash();
                hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null)
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash()
            }, function(newVal, oldVal) {
                newVal === oldVal && "" === newVal || jqLiteDocumentLoaded(function() {
                    $rootScope.$evalAsync(scroll)
                })
            }),
            scroll
        }
        ]
    }
    function $$AsyncCallbackProvider() {
        this.$get = ["$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn)
            }
            : function(fn) {
                return $timeout(fn, 0, !1)
            }
        }
        ]
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1))
            } finally {
                if (0 === --outstandingRequestCount)
                    for (; outstandingRequestCallbacks.length; )
                        try {
                            outstandingRequestCallbacks.pop()()
                        } catch (e) {
                            $log.error(e)
                        }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return -1 === index ? "" : url.substr(index)
        }
        function startPoller(interval, setTimeout) {
            !function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn()
                }),
                pollTimeout = setTimeout(check, interval)
            }()
        }
        function cacheStateAndFireUrlChange() {
            cacheState(),
            fireUrlChange()
        }
        function getCurrentState() {
            try {
                return history.state
            } catch (e) {}
        }
        function cacheState() {
            cachedState = getCurrentState(),
            cachedState = isUndefined(cachedState) ? null : cachedState,
            equals(cachedState, lastCachedState) && (cachedState = lastCachedState),
            lastCachedState = cachedState
        }
        function fireUrlChange() {
            lastBrowserUrl === self.url() && lastHistoryState === cachedState || (lastBrowserUrl = self.url(),
            lastHistoryState = cachedState,
            forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState)
            }))
        }
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str)
            } catch (e) {
                return str
            }
        }
        var self = this
          , rawDocument = document[0]
          , location = window.location
          , history = window.history
          , setTimeout = window.setTimeout
          , clearTimeout = window.clearTimeout
          , pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0
          , outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest,
        self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++
        }
        ,
        self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn()
            }),
            0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback)
        }
        ;
        var pollTimeout, pollFns = [];
        self.addPollFn = function(fn) {
            return isUndefined(pollTimeout) && startPoller(100, setTimeout),
            pollFns.push(fn),
            fn
        }
        ;
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null;
        cacheState(),
        lastHistoryState = cachedState,
        self.url = function(url, replace, state) {
            if (isUndefined(state) && (state = null),
            location !== window.location && (location = window.location),
            history !== window.history && (history = window.history),
            url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState))
                    return self;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url,
                lastHistoryState = state,
                !$sniffer.history || sameBase && sameState ? (sameBase && !reloadLocation || (reloadLocation = url),
                replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url) : (history[replace ? "replaceState" : "pushState"](state, "", url),
                cacheState(),
                lastHistoryState = cachedState),
                self
            }
            return reloadLocation || location.href.replace(/%27/g, "'")
        }
        ,
        self.state = function() {
            return cachedState
        }
        ;
        var urlChangeListeners = []
          , urlChangeInit = !1
          , lastCachedState = null;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange),
            jqLite(window).on("hashchange", cacheStateAndFireUrlChange),
            urlChangeInit = !0),
            urlChangeListeners.push(callback),
            callback
        }
        ,
        self.$$checkUrlChange = fireUrlChange,
        self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : ""
        }
        ;
        var lastCookies = {}
          , lastCookieString = ""
          , cookiePath = self.baseHref();
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (!name) {
                if (rawDocument.cookie !== lastCookieString)
                    for (lastCookieString = rawDocument.cookie,
                    cookieArray = lastCookieString.split("; "),
                    lastCookies = {},
                    i = 0; i < cookieArray.length; i++)
                        cookie = cookieArray[i],
                        (index = cookie.indexOf("=")) > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)),
                        lastCookies[name] === undefined && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
                return lastCookies
            }
            value === undefined ? rawDocument.cookie = encodeURIComponent(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" : isString(value) && (cookieLength = (rawDocument.cookie = encodeURIComponent(name) + "=" + encodeURIComponent(value) + ";path=" + cookiePath).length + 1) > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!")
        }
        ,
        self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++,
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId],
                completeOutstandingRequest(fn)
            }, delay || 0),
            pendingDeferIds[timeoutId] = !0,
            timeoutId
        }
        ,
        self.defer.cancel = function(deferId) {
            return !!pendingDeferIds[deferId] && (delete pendingDeferIds[deferId],
            clearTimeout(deferId),
            completeOutstandingRequest(noop),
            !0)
        }
    }
    function $BrowserProvider() {
        this.$get = ["$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window,$document,$log,$sniffer)
        }
        ]
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry,
                    link(entry.n, entry.p),
                    link(entry, freshEnd),
                    freshEnd = entry,
                    freshEnd.n = null)
                }
                function link(nextEntry, prevEntry) {
                    nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry),
                    prevEntry && (prevEntry.n = nextEntry))
                }
                if (cacheId in caches)
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0
                  , stats = extend({}, options, {
                    id: cacheId
                })
                  , data = {}
                  , capacity = options && options.capacity || Number.MAX_VALUE
                  , lruHash = {}
                  , freshEnd = null
                  , staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            refresh(lruHash[key] || (lruHash[key] = {
                                key: key
                            }))
                        }
                        if (!isUndefined(value))
                            return key in data || size++,
                            data[key] = value,
                            size > capacity && this.remove(staleEnd.key),
                            value
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry)
                                return;
                            refresh(lruEntry)
                        }
                        return data[key]
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry)
                                return;
                            lruEntry == freshEnd && (freshEnd = lruEntry.p),
                            lruEntry == staleEnd && (staleEnd = lruEntry.n),
                            link(lruEntry.n, lruEntry.p),
                            delete lruHash[key]
                        }
                        delete data[key],
                        size--
                    },
                    removeAll: function() {
                        data = {},
                        size = 0,
                        lruHash = {},
                        freshEnd = staleEnd = null
                    },
                    destroy: function() {
                        data = null,
                        stats = null,
                        lruHash = null,
                        delete caches[cacheId]
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        })
                    }
                }
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info()
                }),
                info
            }
            ,
            cacheFactory.get = function(cacheId) {
                return caches[cacheId]
            }
            ,
            cacheFactory
        }
    }
    function $TemplateCacheProvider() {
        this.$get = ["$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates")
        }
        ]
    }
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        function parseIsolateBindings(scope, directiveName) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/
              , bindings = {};
            return forEach(scope, function(definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match)
                    throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition);
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: "*" === match[2],
                    optional: "?" === match[3],
                    attrName: match[4] || scopeName
                }
            }),
            bindings
        }
        var hasDirectives = {}
          , Suffix = "Directive"
          , COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/
          , CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/
          , ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset")
          , REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/
          , EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
            return assertNotHasOwnProperty(name, "directive"),
            isString(name) ? (assertArg(directiveFactory, "directiveFactory"),
            hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [],
            $provide.factory(name + Suffix, ["$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)),
                        directive.priority = directive.priority || 0,
                        directive.index = index,
                        directive.name = directive.name || name,
                        directive.require = directive.require || directive.controller && directive.name,
                        directive.restrict = directive.restrict || "EA",
                        isObject(directive.scope) && (directive.$$isolateBindings = parseIsolateBindings(directive.scope, directive.name)),
                        directives.push(directive)
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                }),
                directives
            }
            ])),
            hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)),
            this
        }
        ,
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp),
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist()
        }
        ,
        this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp),
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist()
        }
        ;
        var debugInfoEnabled = !0;
        this.debugInfoEnabled = function(enabled) {
            return isDefined(enabled) ? (debugInfoEnabled = enabled,
            this) : debugInfoEnabled
        }
        ,
        this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className)
                } catch (e) {}
            }
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)),
                forEach($compileNodes, function(node, index) {
                    node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) && ($compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0])
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope"),
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn
                      , transcludeControllers = options.transcludeControllers
                      , futureParentElement = options.futureParentElement;
                    parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude),
                    namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                    var $linkNode;
                    if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes,
                    transcludeControllers)
                        for (var controllerName in transcludeControllers)
                            $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    return compile.$$addScopeInfo($linkNode, scope),
                    cloneConnectFn && cloneConnectFn($linkNode, scope),
                    compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn),
                    $linkNode
                }
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                return node && "foreignobject" !== nodeName_(node) && node.toString().match(/SVG/) ? "svg" : "html"
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        for (stableNodeList = new Array(nodeListLength),
                        i = 0; i < linkFns.length; i += 3)
                            idx = linkFns[i],
                            stableNodeList[idx] = nodeList[idx]
                    } else
                        stableNodeList = nodeList;
                    for (i = 0,
                    ii = linkFns.length; i < ii; )
                        node = stableNodeList[linkFns[i++]],
                        nodeLinkFn = linkFns[i++],
                        childLinkFn = linkFns[i++],
                        nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(),
                        compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope,
                        childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn, nodeLinkFn.elementTranscludeOnThisElement) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null,
                        nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn)
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], i = 0; i < nodeList.length; i++)
                    attrs = new Attributes,
                    directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective),
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null,
                    nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element),
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn),
                    (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn),
                    linkFnFound = !0,
                    nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn),
                    previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn, elementTransclusion) {
                return function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    return transcludedScope || (transcludedScope = scope.$new(!1, containingScope),
                    transcludedScope.$$transcluded = !0),
                    transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    })
                }
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                        var attrStartName = !1
                          , attrEndName = !1;
                        attr = nAttrs[j],
                        name = attr.name,
                        value = trim(attr.value),
                        ngAttrName = directiveNormalize(name),
                        (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                            return letter.toUpperCase()
                        }));
                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                        directiveIsMultiElement(directiveNName) && ngAttrName === directiveNName + "Start" && (attrStartName = name,
                        attrEndName = name.substr(0, name.length - 5) + "end",
                        name = name.substr(0, name.length - 6)),
                        nName = directiveNormalize(name.toLowerCase()),
                        attrsMap[nName] = name,
                        !isNgAttr && attrs.hasOwnProperty(nName) || (attrs[nName] = value,
                        getBooleanAttrName(node, nName) && (attrs[nName] = !0)),
                        addAttrInterpolateDirective(node, directives, value, nName, isNgAttr),
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName)
                    }
                    if (className = node.className,
                    isObject(className) && (className = className.animVal),
                    isString(className) && "" !== className)
                        for (; match = CLASS_DIRECTIVE_REGEXP.exec(className); )
                            nName = directiveNormalize(match[2]),
                            addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])),
                            className = className.substr(match.index + match[0].length);
                    break;
                case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;
                case NODE_TYPE_COMMENT:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue),
                        match && (nName = directiveNormalize(match[1]),
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])))
                    } catch (e) {}
                }
                return directives.sort(byPriority),
                directives
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = []
                  , depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart))
                    do {
                        if (!node)
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        node.nodeType == NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++,
                        node.hasAttribute(attrEnd) && depth--),
                        nodes.push(node),
                        node = node.nextSibling
                    } while (depth > 0);
                else
                    nodes.push(node);
                return jqLite(nodes)
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd),
                    linkFn(scope, element, attrs, controllers, transcludeFn)
                }
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)),
                    pre.require = directive.require,
                    pre.directiveName = directiveName,
                    (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })),
                    preLinkFns.push(pre)),
                    post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)),
                    post.require = directive.require,
                    post.directiveName = directiveName,
                    (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })),
                    postLinkFns.push(post))
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, match, retrievalMethod = "data", optional = !1, $searchElement = $element;
                    if (isString(require)) {
                        if (match = require.match(REQUIRE_PREFIX_REGEXP),
                        require = require.substring(match[0].length),
                        match[3] && (match[1] ? match[3] = null : match[1] = match[3]),
                        "^" === match[1] ? retrievalMethod = "inheritedData" : "^^" === match[1] && (retrievalMethod = "inheritedData",
                        $searchElement = $element.parent()),
                        "?" === match[2] && (optional = !0),
                        value = null,
                        elementControllers && "data" === retrievalMethod && (value = elementControllers[require]) && (value = value.instance),
                        !(value = value || $searchElement[retrievalMethod]("$" + require + "Controller")) && !optional)
                            throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                        return value || null
                    }
                    return isArray(require) && (value = [],
                    forEach(require, function(require) {
                        value.push(getControllers(directiveName, require, $element, elementControllers))
                    })),
                    value
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                        var transcludeControllers;
                        return isScope(scope) || (futureParentElement = cloneAttachFn,
                        cloneAttachFn = scope,
                        scope = undefined),
                        hasElementTranscludeDirective && (transcludeControllers = elementControllers),
                        futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element),
                        boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild)
                    }
                    var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                    if (compileNode === linkNode ? (attrs = templateAttrs,
                    $element = templateAttrs.$$element) : ($element = jqLite(linkNode),
                    attrs = new Attributes($element,templateAttrs)),
                    newIsolateScopeDirective && (isolateScope = scope.$new(!0)),
                    boundTranscludeFn && (transcludeFn = controllersBoundTransclude,
                    transcludeFn.$$boundTransclude = boundTranscludeFn),
                    controllerDirectives && (controllers = {},
                    elementControllers = {},
                    forEach(controllerDirectives, function(directive) {
                        var controllerInstance, locals = {
                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                            $element: $element,
                            $attrs: attrs,
                            $transclude: transcludeFn
                        };
                        controller = directive.controller,
                        "@" == controller && (controller = attrs[directive.name]),
                        controllerInstance = $controller(controller, locals, !0, directive.controllerAs),
                        elementControllers[directive.name] = controllerInstance,
                        hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance.instance),
                        controllers[directive.name] = controllerInstance
                    })),
                    newIsolateScopeDirective) {
                        compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))),
                        compile.$$addScopeClass($element, !0);
                        var isolateScopeController = controllers && controllers[newIsolateScopeDirective.name]
                          , isolateBindingContext = isolateScope;
                        isolateScopeController && isolateScopeController.identifier && !0 === newIsolateScopeDirective.bindToController && (isolateBindingContext = isolateScopeController.instance),
                        forEach(isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, function(definition, scopeName) {
                            var lastValue, parentGet, parentSet, compare, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                            switch (mode) {
                            case "@":
                                attrs.$observe(attrName, function(value) {
                                    isolateBindingContext[scopeName] = value
                                }),
                                attrs.$$observers[attrName].$$scope = scope,
                                attrs[attrName] && (isolateBindingContext[scopeName] = $interpolate(attrs[attrName])(scope));
                                break;
                            case "=":
                                if (optional && !attrs[attrName])
                                    return;
                                parentGet = $parse(attrs[attrName]),
                                compare = parentGet.literal ? equals : function(a, b) {
                                    return a === b || a !== a && b !== b
                                }
                                ,
                                parentSet = parentGet.assign || function() {
                                    throw lastValue = isolateBindingContext[scopeName] = parentGet(scope),
                                    $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name)
                                }
                                ,
                                lastValue = isolateBindingContext[scopeName] = parentGet(scope);
                                var parentValueWatch = function(parentValue) {
                                    return compare(parentValue, isolateBindingContext[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = isolateBindingContext[scopeName]) : isolateBindingContext[scopeName] = parentValue),
                                    lastValue = parentValue
                                };
                                parentValueWatch.$stateful = !0;
                                var unwatch;
                                unwatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal),
                                isolateScope.$on("$destroy", unwatch);
                                break;
                            case "&":
                                parentGet = $parse(attrs[attrName]),
                                isolateBindingContext[scopeName] = function(locals) {
                                    return parentGet(scope, locals)
                                }
                            }
                        })
                    }
                    for (controllers && (forEach(controllers, function(controller) {
                        controller()
                    }),
                    controllers = null),
                    i = 0,
                    ii = preLinkFns.length; i < ii; i++)
                        linkFn = preLinkFns[i],
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope),
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn),
                    i = postLinkFns.length - 1; i >= 0; i--)
                        linkFn = postLinkFns[i],
                        invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn)
                }
                previousCompileContext = previousCompileContext || {};
                for (var newScopeDirective, controllers, directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start
                      , attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)),
                    $template = undefined,
                    terminalPriority > directive.priority)
                        break;
                    if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode),
                    newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)),
                    newScopeDirective = newScopeDirective || directive),
                    directiveName = directive.name,
                    !directive.templateUrl && directive.controller && (directiveValue = directive.controller,
                    controllerDirectives = controllerDirectives || {},
                    assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode),
                    controllerDirectives[directiveName] = directive),
                    (directiveValue = directive.transclude) && (hasTranscludeDirective = !0,
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode),
                    nonTlbTranscludeDirective = directive),
                    "element" == directiveValue ? (hasElementTranscludeDirective = !0,
                    terminalPriority = directive.priority,
                    $template = $compileNode,
                    $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")),
                    compileNode = $compileNode[0],
                    replaceWith(jqCollection, sliceArgs($template), compileNode),
                    childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    })) : ($template = jqLite(jqLiteClone(compileNode)).contents(),
                    $compileNode.empty(),
                    childTranscludeFn = compile($template, transcludeFn))),
                    directive.template)
                        if (hasTemplate = !0,
                        assertNoDuplicate("template", templateDirective, directive, $compileNode),
                        templateDirective = directive,
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template,
                        directiveValue = denormalizeTemplate(directiveValue),
                        directive.replace) {
                            if (replaceDirective = directive,
                            $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))),
                            compileNode = $template[0],
                            1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT)
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {
                                $attr: {}
                            }
                              , templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs)
                              , unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives),
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives),
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs),
                            ii = directives.length
                        } else
                            $compileNode.html(directiveValue);
                    if (directive.templateUrl)
                        hasTemplate = !0,
                        assertNoDuplicate("template", templateDirective, directive, $compileNode),
                        templateDirective = directive,
                        directive.replace && (replaceDirective = directive),
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        }),
                        ii = directives.length;
                    else if (directive.compile)
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn),
                            isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd)
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode))
                        }
                    directive.terminal && (nodeLinkFn.terminal = !0,
                    terminalPriority = Math.max(terminalPriority, directive.priority))
                }
                return nodeLinkFn.scope = newScopeDirective && !0 === newScopeDirective.scope,
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective,
                nodeLinkFn.elementTranscludeOnThisElement = hasElementTranscludeDirective,
                nodeLinkFn.templateOnThisElement = hasTemplate,
                nodeLinkFn.transclude = childTranscludeFn,
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective,
                nodeLinkFn
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; j < jj; j++)
                    directives[j] = inherit(directives[j], {
                        $$isolateScope: !0
                    })
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective)
                    return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name))
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++)
                        try {
                            directive = directives[i],
                            (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
                                $$start: startAttrName,
                                $$end: endAttrName
                            })),
                            tDirectives.push(directive),
                            match = directive)
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                return match
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name))
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++)
                        if (directive = directives[i],
                        directive.multiElement)
                            return !0;
                return !1
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr
                  , dstAttr = dst.$attr
                  , $element = dst.$$element;
                forEach(dst, function(value, key) {
                    "$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" : " ") + src[key]),
                    dst.$set(key, value, !0, srcAttr[key]))
                }),
                forEach(src, function(value, key) {
                    "class" == key ? (safeAddClass($element, value),
                    dst.class = (dst.class ? dst.class + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value),
                    dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value,
                    dstAttr[key] = srcAttr[key])
                })
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                return $compileNode.empty(),
                $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content),
                    origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))),
                        compileNode = $template[0],
                        1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT)
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        },
                        replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives),
                        directives = templateDirectives.concat(directives),
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs)
                    } else
                        compileNode = beforeTemplateCompileNode,
                        $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective),
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext),
                    forEach($rootElement, function(node, i) {
                        node == compileNode && ($rootElement[i] = $compileNode[0])
                    }),
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift()
                          , beforeTemplateLinkNode = linkQueue.shift()
                          , linkRootElement = linkQueue.shift()
                          , boundTranscludeFn = linkQueue.shift()
                          , linkNode = $compileNode[0];
                        if (!scope.$$destroyed) {
                            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                var oldClasses = beforeTemplateLinkNode.className;
                                previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)),
                                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode),
                                safeAddClass(jqLite(linkNode), oldClasses)
                            }
                            childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn,
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn)
                        }
                    }
                    linkQueue = null
                }),
                function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)),
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)))
                }
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective)
                    throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element))
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var templateNodeParent = templateNode.parent()
                          , hasCompileParent = !!templateNodeParent.length;
                        return hasCompileParent && compile.$$addBindingClass(templateNodeParent),
                        function(scope, node) {
                            var parent = node.parent();
                            hasCompileParent || compile.$$addBindingClass(parent),
                            compile.$$addBindingInfo(parent, interpolateFn.expressions),
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value
                            })
                        }
                    }
                })
            }
            function wrapTemplate(type, template) {
                switch (type = lowercase(type || "html")) {
                case "svg":
                case "math":
                    var wrapper = document.createElement("div");
                    return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">",
                    wrapper.childNodes[0].childNodes;
                default:
                    return template
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" == attrNormalizedName)
                    return $sce.HTML;
                var tag = nodeName_(node);
                return "xlinkHref" == attrNormalizedName || "form" == tag && "action" == attrNormalizedName || "img" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0
            }
            function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                var trustedContext = getTrustedContext(node, name);
                allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                var interpolateFn = $interpolate(value, !0, trustedContext, allOrNothing);
                if (interpolateFn) {
                    if ("multiple" === name && "select" === nodeName_(node))
                        throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = {});
                                    if (EVENT_HANDLER_ATTR_REGEXP.test(name))
                                        throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                    var newValue = attr[name];
                                    newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing),
                                    value = newValue),
                                    interpolateFn && (attr[name] = interpolateFn(scope),
                                    ($$observers[name] || ($$observers[name] = [])).$$inter = !0,
                                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue)
                                    }))
                                }
                            }
                        }
                    })
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement)
                    for (i = 0,
                    ii = $rootElement.length; i < ii; i++)
                        if ($rootElement[i] == firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++,
                            j2++)
                                j2 < jj ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                            $rootElement.length -= removeCount - 1,
                            $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                            break
                        }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove),
                jqLite(newNode).data(jqLite(firstElementToRemove).data()),
                jQuery ? (skipDestroyOnNextJQueryCleanData = !0,
                jQuery.cleanData([firstElementToRemove])) : delete jqLite.cache[firstElementToRemove[jqLite.expando]];
                for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove(),
                    fragment.appendChild(element),
                    delete elementsToRemove[k]
                }
                elementsToRemove[0] = newNode,
                elementsToRemove.length = 1
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments)
                }, fn, annotation)
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn)
                } catch (e) {
                    $exceptionHandler(e, startingTag($element))
                }
            }
            var Attributes = function(element, attributesToCopy) {
                if (attributesToCopy) {
                    var i, l, key, keys = Object.keys(attributesToCopy);
                    for (i = 0,
                    l = keys.length; i < l; i++)
                        key = keys[i],
                        this[key] = attributesToCopy[key]
                } else
                    this.$attr = {};
                this.$$element = element
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal)
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal)
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove)
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(node, key), observer = key;
                    if (booleanKey ? (this.$$element.prop(key, value),
                    attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value,
                    observer = aliasedKey),
                    this[key] = value,
                    attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key]) || (this.$attr[key] = attrName = snake_case(key, "-")),
                    "a" === (nodeName = nodeName_(this.$$element)) && "href" === key || "img" === nodeName && "src" === key)
                        this[key] = value = $$sanitizeUri(value, "src" === key);
                    else if ("img" === nodeName && "srcset" === key) {
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = 2 * i;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), !0),
                            result += " " + trim(rawUris[innerIdx + 1])
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), !0),
                        2 === lastTuple.length && (result += " " + trim(lastTuple[1])),
                        this[key] = value = result
                    }
                    !1 !== writeAttr && (null === value || value === undefined ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value)
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                    })
                },
                $observe: function(key, fn) {
                    var attrs = this
                      , $$observers = attrs.$$observers || (attrs.$$observers = createMap())
                      , listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn),
                    $rootScope.$evalAsync(function() {
                        !listeners.$$inter && attrs.hasOwnProperty(key) && fn(attrs[key])
                    }),
                    function() {
                        arrayRemove(listeners, fn)
                    }
                }
            };
            var startSymbol = $interpolate.startSymbol()
              , endSymbol = $interpolate.endSymbol()
              , denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
            }
              , NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                var bindings = $element.data("$binding") || [];
                isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding),
                $element.data("$binding", bindings)
            }
            : noop,
            compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                safeAddClass($element, "ng-binding")
            }
            : noop,
            compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope)
            }
            : noop,
            compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope")
            }
            : noop,
            compile
        }
        ]
    }
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""))
    }
    function tokenDifference(str1, str2) {
        var values = ""
          , tokens1 = str1.split(/\s+/)
          , tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                if (token == tokens2[j])
                    continue outer;
            values += (values.length > 0 ? " " : "") + token
        }
        return values
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1)
            return jqNodes;
        for (; i--; ) {
            jqNodes[i].nodeType === NODE_TYPE_COMMENT && splice.call(jqNodes, i, 1)
        }
        return jqNodes
    }
    function $ControllerProvider() {
        var controllers = {}
          , globals = !1
          , CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"),
            isObject(name) ? extend(controllers, name) : controllers[name] = constructor
        }
        ,
        this.allowGlobals = function() {
            globals = !0
        }
        ,
        this.$get = ["$injector", "$window", function($injector, $window) {
            function addIdentifier(locals, identifier, instance, name) {
                if (!locals || !isObject(locals.$scope))
                    throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                locals.$scope[identifier] = instance
            }
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                if (later = !0 === later,
                ident && isString(ident) && (identifier = ident),
                isString(expression)) {
                    if (!(match = expression.match(CNTRL_REG)))
                        throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                    constructor = match[1],
                    identifier = identifier || match[3],
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || (globals ? getter($window, constructor, !0) : undefined),
                    assertArgFn(expression, constructor, !0)
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    return instance = Object.create(controllerPrototype || null),
                    identifier && addIdentifier(locals, identifier, instance, constructor || expression.name),
                    extend(function() {
                        return $injector.invoke(expression, instance, locals, constructor),
                        instance
                    }, {
                        instance: instance,
                        identifier: identifier
                    })
                }
                return instance = $injector.instantiate(expression, locals, constructor),
                identifier && addIdentifier(locals, identifier, instance, constructor || expression.name),
                instance
            }
        }
        ]
    }
    function $DocumentProvider() {
        this.$get = ["$window", function(window) {
            return jqLite(window.document)
        }
        ]
    }
    function $ExceptionHandlerProvider() {
        this.$get = ["$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments)
            }
        }
        ]
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                (contentType && 0 === contentType.indexOf(APPLICATION_JSON) || isJsonLike(tempData)) && (data = fromJson(tempData))
            }
        }
        return data
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str)
    }
    function parseHeaders(headers) {
        var key, val, i, parsed = createMap();
        return headers ? (forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"),
            key = lowercase(trim(line.substr(0, i))),
            val = trim(line.substr(i + 1)),
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val)
        }),
        parsed) : parsed
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function(name) {
            if (headersObj || (headersObj = parseHeaders(headers)),
            name) {
                var value = headersObj[lowercase(name)];
                return void 0 === value && (value = null),
                value
            }
            return headersObj
        }
    }
    function transformData(data, headers, status, fns) {
        return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
            data = fn(data, headers, status)
        }),
        data)
    }
    function isSuccess(status) {
        return 200 <= status && status < 300
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [defaultHttpResponseTransform],
            transformRequest: [function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d)
            }
            ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        }
          , useApplyAsync = !1;
        this.useApplyAsync = function(value) {
            return isDefined(value) ? (useApplyAsync = !!value,
            this) : useApplyAsync
        }
        ;
        var interceptorFactories = this.interceptors = [];
        this.$get = ["$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            function $http(requestConfig) {
                function transformResponse(response) {
                    var resp = extend({}, response);
                    return response.data ? resp.data = transformData(response.data, response.headers, response.status, config.transformResponse) : resp.data = response.data,
                    isSuccess(response.status) ? resp : $q.reject(resp)
                }
                function executeHeaderFns(headers) {
                    var headerContent, processedHeaders = {};
                    return forEach(headers, function(headerFn, header) {
                        isFunction(headerFn) ? null != (headerContent = headerFn()) && (processedHeaders[header] = headerContent) : processedHeaders[header] = headerFn
                    }),
                    processedHeaders
                }
                if (!angular.isObject(requestConfig))
                    throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }, requestConfig);
                config.headers = function(config) {
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders)
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName)
                                continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName]
                    }
                    return executeHeaderFns(reqHeaders)
                }(requestConfig),
                config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    var headers = config.headers
                      , reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header]
                    }),
                    isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials),
                    sendReq(config, reqData).then(transformResponse, transformResponse)
                }
                  , chain = [serverRequest, undefined]
                  , promise = $q.when(config);
                for (forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError),
                    (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError)
                }); chain.length; ) {
                    var thenFn = chain.shift()
                      , rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn)
                }
                return promise.success = function(fn) {
                    return assertArgFn(fn, "fn"),
                    promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config)
                    }),
                    promise
                }
                ,
                promise.error = function(fn) {
                    return assertArgFn(fn, "fn"),
                    promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config)
                    }),
                    promise
                }
                ,
                promise
            }
            function sendReq(config, reqData) {
                function done(status, response, headersString, statusText) {
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText)
                    }
                    cache && (isSuccess(status) ? cache.put(url, [status, response, parseHeaders(headersString), statusText]) : cache.remove(url)),
                    useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(),
                    $rootScope.$$phase || $rootScope.$apply())
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = status >= -1 ? status : 0,
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    })
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText)
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1)
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, url = buildUrl(config.url, config.params);
                if ($http.pendingRequests.push(config),
                promise.then(removePendingReq, removePendingReq),
                !config.cache && !defaults.cache || !1 === config.cache || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache),
                cache && (cachedResp = cache.get(url),
                isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK") : cache.put(url, promise)),
                isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue),
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType)
                }
                return promise
            }
            function buildUrl(url, params) {
                if (!params)
                    return url;
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || (isArray(value) || (value = [value]),
                    forEach(value, function(v) {
                        isObject(v) && (v = isDate(v) ? v.toISOString() : toJson(v)),
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v))
                    }))
                }),
                parts.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + parts.join("&")),
                url
            }
            var defaultCache = $cacheFactory("$http")
              , reversedInterceptors = [];
            return forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory))
            }),
            $http.pendingRequests = [],
            function(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }))
                    }
                })
            }("get", "delete", "head", "jsonp"),
            function(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }))
                    }
                })
            }("post", "put", "patch"),
            $http.defaults = defaults,
            $http
        }
        ]
    }
    function createXhr() {
        return new window.XMLHttpRequest
    }
    function $HttpBackendProvider() {
        this.$get = ["$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0])
        }
        ]
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script")
              , callback = null;
            return script.type = "text/javascript",
            script.src = url,
            script.async = !0,
            callback = function(event) {
                removeEventListenerFn(script, "load", callback),
                removeEventListenerFn(script, "error", callback),
                rawDocument.body.removeChild(script),
                script = null;
                var status = -1
                  , text = "unknown";
                event && ("load" !== event.type || callbacks[callbackId].called || (event = {
                    type: "error"
                }),
                text = event.type,
                status = "error" === event.type ? 404 : 200),
                done && done(status, text)
            }
            ,
            addEventListenerFn(script, "load", callback),
            addEventListenerFn(script, "error", callback),
            rawDocument.body.appendChild(script),
            callback
        }
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            function timeoutRequest() {
                jsonpDone && jsonpDone(),
                xhr && xhr.abort()
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                timeoutId !== undefined && $browserDefer.cancel(timeoutId),
                jsonpDone = xhr = null,
                callback(status, response, headersString, statusText),
                $browser.$$completeOutstandingRequest(noop)
            }
            if ($browser.$$incOutstandingRequestCount(),
            url = url || $browser.url(),
            "jsonp" == lowercase(method)) {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data,
                    callbacks[callbackId].called = !0
                }
                ;
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text),
                    callbacks[callbackId] = noop
                })
            } else {
                var xhr = createXhr();
                xhr.open(method, url, !0),
                forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value)
                }),
                xhr.onload = function() {
                    var statusText = xhr.statusText || ""
                      , response = "response"in xhr ? xhr.response : xhr.responseText
                      , status = 1223 === xhr.status ? 204 : xhr.status;
                    0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0),
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText)
                }
                ;
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "")
                };
                if (xhr.onerror = requestError,
                xhr.onabort = requestError,
                withCredentials && (xhr.withCredentials = !0),
                responseType)
                    try {
                        xhr.responseType = responseType
                    } catch (e) {
                        if ("json" !== responseType)
                            throw e
                    }
                xhr.send(post || null)
            }
            if (timeout > 0)
                var timeoutId = $browserDefer(timeoutRequest, timeout);
            else
                isPromiseLike(timeout) && timeout.then(timeoutRequest)
        }
    }
    function $InterpolateProvider() {
        var startSymbol = "{{"
          , endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value,
            this) : startSymbol
        }
        ,
        this.endSymbol = function(value) {
            return value ? (endSymbol = value,
            this) : endSymbol
        }
        ,
        this.$get = ["$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function escape(ch) {
                return "\\\\\\" + ch
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                function unescapeText(text) {
                    return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol)
                }
                function parseStringifyInterceptor(value) {
                    try {
                        return value = getValue(value),
                        allOrNothing && !isDefined(value) ? value : stringify(value)
                    } catch (err) {
                        var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                        $exceptionHandler(newErr)
                    }
                }
                allOrNothing = !!allOrNothing;
                for (var startIndex, endIndex, exp, index = 0, expressions = [], parseFns = [], textLength = text.length, concat = [], expressionPositions = []; index < textLength; ) {
                    if (-1 == (startIndex = text.indexOf(startSymbol, index)) || -1 == (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                        index !== textLength && concat.push(unescapeText(text.substring(index)));
                        break
                    }
                    index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))),
                    exp = text.substring(startIndex + startSymbolLength, endIndex),
                    expressions.push(exp),
                    parseFns.push($parse(exp, parseStringifyInterceptor)),
                    index = endIndex + endSymbolLength,
                    expressionPositions.push(concat.length),
                    concat.push("")
                }
                if (trustedContext && concat.length > 1)
                    throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
                if (!mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; i < ii; i++) {
                            if (allOrNothing && isUndefined(values[i]))
                                return;
                            concat[expressionPositions[i]] = values[i]
                        }
                        return concat.join("")
                    }
                      , getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value)
                    }
                      , stringify = function(value) {
                        if (null == value)
                            return "";
                        switch (typeof value) {
                        case "string":
                            break;
                        case "number":
                            value = "" + value;
                            break;
                        default:
                            value = toJson(value)
                        }
                        return value
                    };
                    return extend(function(context) {
                        var i = 0
                          , ii = expressions.length
                          , values = new Array(ii);
                        try {
                            for (; i < ii; i++)
                                values[i] = parseFns[i](context);
                            return compute(values)
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                            $exceptionHandler(newErr)
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener, objectEquality) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function(values, oldValues) {
                                var currValue = compute(values);
                                isFunction(listener) && listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope),
                                lastValue = currValue
                            }, objectEquality)
                        }
                    })
                }
            }
            var startSymbolLength = startSymbol.length
              , endSymbolLength = endSymbol.length
              , escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape),"g")
              , escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape),"g");
            return $interpolate.startSymbol = function() {
                return startSymbol
            }
            ,
            $interpolate.endSymbol = function() {
                return endSymbol
            }
            ,
            $interpolate
        }
        ]
    }
    function $IntervalProvider() {
        this.$get = ["$rootScope", "$window", "$q", "$$q", function($rootScope, $window, $q, $$q) {
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval
                  , clearInterval = $window.clearInterval
                  , iteration = 0
                  , skipApply = isDefined(invokeApply) && !invokeApply
                  , deferred = (skipApply ? $$q : $q).defer()
                  , promise = deferred.promise;
                return count = isDefined(count) ? count : 0,
                promise.then(null, null, fn),
                promise.$$intervalId = setInterval(function() {
                    deferred.notify(iteration++),
                    count > 0 && iteration >= count && (deferred.resolve(iteration),
                    clearInterval(promise.$$intervalId),
                    delete intervals[promise.$$intervalId]),
                    skipApply || $rootScope.$apply()
                }, delay),
                intervals[promise.$$intervalId] = deferred,
                promise
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                return !!(promise && promise.$$intervalId in intervals) && (intervals[promise.$$intervalId].reject("canceled"),
                $window.clearInterval(promise.$$intervalId),
                delete intervals[promise.$$intervalId],
                !0)
            }
            ,
            interval
        }
        ]
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [{
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "¤",
                        posSuf: "",
                        negPre: "(¤",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    }],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: ["AM", "PM"],
                    medium: "MMM d, y h:mm:ss a",
                    short: "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a",
                    ERANAMES: ["Before Christ", "Anno Domini"],
                    ERAS: ["BC", "AD"]
                },
                pluralCat: function(num) {
                    return 1 === num ? "one" : "other"
                }
            }
        }
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; )
            segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/")
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol,
        locationObj.$$host = parsedUrl.hostname,
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = "/" !== relativeUrl.charAt(0);
        prefixed && (relativeUrl = "/" + relativeUrl);
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname),
        locationObj.$$search = parseKeyValue(match.search),
        locationObj.$$hash = decodeURIComponent(match.hash),
        locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path)
    }
    function beginsWith(begin, whole) {
        if (0 === whole.indexOf(begin))
            return whole.substr(begin.length)
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 == index ? url : url.substr(0, index)
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1")
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1)
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2))
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = !0,
        basePrefix = basePrefix || "",
        parseAbsoluteUrl(appBase, this),
        this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl))
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this),
            this.$$path || (this.$$path = "/"),
            this.$$compose()
        }
        ,
        this.$$compose = function() {
            var search = toKeyValue(this.$$search)
              , hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash,
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1)
        }
        ,
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0])
                return this.hash(relHref.slice(1)),
                !0;
            var appUrl, prevAppUrl, rewrittenUrl;
            return (appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl,
            rewrittenUrl = (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile == url + "/" && (rewrittenUrl = appBaseNoFile),
            rewrittenUrl && this.$$parse(rewrittenUrl),
            !!rewrittenUrl
        }
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this),
        this.$$parse = function(url) {
            var withoutHashUrl, withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "",
            isUndefined(withoutBaseUrl) && (appBase = url,
            this.replace())) : (withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl),
            isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)),
            parseAppUrl(withoutHashUrl, this),
            this.$$path = function(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return 0 === url.indexOf(base) && (url = url.replace(base, "")),
                windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path),
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path)
            }(this.$$path, withoutHashUrl, appBase),
            this.$$compose()
        }
        ,
        this.$$compose = function() {
            var search = toKeyValue(this.$$search)
              , hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash,
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "")
        }
        ,
        this.$$parseLinkUrl = function(url, relHref) {
            return stripHash(appBase) == stripHash(url) && (this.$$parse(url),
            !0)
        }
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = !0,
        LocationHashbangUrl.apply(this, arguments),
        this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0])
                return this.hash(relHref.slice(1)),
                !0;
            var rewrittenUrl, appUrl;
            return appBase == stripHash(url) ? rewrittenUrl = url : (appUrl = beginsWith(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile),
            rewrittenUrl && this.$$parse(rewrittenUrl),
            !!rewrittenUrl
        }
        ,
        this.$$compose = function() {
            var search = toKeyValue(this.$$search)
              , hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash,
            this.$$absUrl = appBase + hashPrefix + this.$$url
        }
    }
    function locationGetter(property) {
        return function() {
            return this[property]
        }
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value),
            this.$$compose(),
            this)
        }
    }
    function $LocationProvider() {
        var hashPrefix = ""
          , html5Mode = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix,
            this) : hashPrefix
        }
        ,
        this.html5Mode = function(mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode,
            this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled),
            isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase),
            isBoolean(mode.rewriteLinks) && (html5Mode.rewriteLinks = mode.rewriteLinks),
            this) : html5Mode
        }
        ,
        this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url()
                  , oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state),
                    $location.$$state = $browser.state()
                } catch (e) {
                    throw $location.url(oldUrl),
                    $location.$$state = oldState,
                    e
                }
            }
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState)
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase)
                    throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                appBase = serverBase(initialUrl) + (baseHref || "/"),
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url
            } else
                appBase = stripHash(initialUrl),
                LocationMode = LocationHashbangUrl;
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase,appBaseNoFile,"#" + hashPrefix),
            $location.$$parseLinkUrl(initialUrl, initialUrl),
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            $rootElement.on("click", function(event) {
                if (html5Mode.rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 != event.which && 2 != event.button) {
                    for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); )
                        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                            return;
                    var absHref = elm.prop("href")
                      , relHref = elm.attr("href") || elm.attr("xlink:href");
                    isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href),
                    IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(),
                    $location.absUrl() != $browser.url() && ($rootScope.$apply(),
                    $window.angular["ff-684208-preventDefault"] = !0))
                }
            }),
            trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl) && $browser.url($location.absUrl(), !0);
            var initializing = !0;
            return $browser.onUrlChange(function(newUrl, newState) {
                if (isUndefined(beginsWith(appBaseNoFile, newUrl)))
                    return void ($window.location.href = newUrl);
                $rootScope.$evalAsync(function() {
                    var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                    $location.$$parse(newUrl),
                    $location.$$state = newState,
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented,
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl),
                    $location.$$state = oldState,
                    setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1,
                    afterLocationChange(oldUrl, oldState)))
                }),
                $rootScope.$$phase || $rootScope.$digest()
            }),
            $rootScope.$watch(function() {
                var oldUrl = trimEmptyHash($browser.url())
                  , newUrl = trimEmptyHash($location.absUrl())
                  , oldState = $browser.state()
                  , currentReplace = $location.$$replace
                  , urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                (initializing || urlOrStateChanged) && (initializing = !1,
                $rootScope.$evalAsync(function() {
                    var newUrl = $location.absUrl()
                      , defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl),
                    $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state),
                    afterLocationChange(oldUrl, oldState)))
                })),
                $location.$$replace = !1
            }),
            $location
        }
        ]
    }
    function $LogProvider() {
        var debug = !0
          , self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag,
            this) : debug
        }
        ,
        this.$get = ["$window", function($window) {
            function formatError(arg) {
                return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)),
                arg
            }
            function consoleLog(type) {
                var console = $window.console || {}
                  , logFn = console[type] || console.log || noop
                  , hasApply = !1;
                try {
                    hasApply = !!logFn.apply
                } catch (e) {}
                return hasApply ? function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg))
                    }),
                    logFn.apply(console, args)
                }
                : function(arg1, arg2) {
                    logFn(arg1, null == arg2 ? "" : arg2)
                }
            }
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments)
                    }
                }()
            }
        }
        ]
    }
    function ensureSafeMemberName(name, fullExpression) {
        if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name)
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
        return name
    }
    function getStringValue(name, fullExpression) {
        if (name += "",
        !isString(name))
            throw $parseMinErr("iseccst", "Cannot convert object to primitive value! Expression: {0}", fullExpression);
        return name
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj)
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.window === obj)
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find))
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === Object)
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression)
        }
        return obj
    }
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj)
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === CALL || obj === APPLY || obj === BIND)
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression)
        }
    }
    function isConstant(exp) {
        return exp.constant
    }
    function setter(obj, locals, path, setValue, fullExp) {
        ensureSafeObject(obj, fullExp),
        ensureSafeObject(locals, fullExp);
        for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = 0 === i && locals && locals[key] || obj[key];
            propertyObj || (propertyObj = {},
            obj[key] = propertyObj),
            obj = ensureSafeObject(propertyObj, fullExp)
        }
        return key = ensureSafeMemberName(element.shift(), fullExp),
        ensureSafeObject(obj[key], fullExp),
        obj[key] = setValue,
        setValue
    }
    function isPossiblyDangerousMemberName(name) {
        return "constructor" == name
    }
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, expensiveChecks) {
        ensureSafeMemberName(key0, fullExp),
        ensureSafeMemberName(key1, fullExp),
        ensureSafeMemberName(key2, fullExp),
        ensureSafeMemberName(key3, fullExp),
        ensureSafeMemberName(key4, fullExp);
        var eso = function(o) {
            return ensureSafeObject(o, fullExp)
        }
          , eso0 = expensiveChecks || isPossiblyDangerousMemberName(key0) ? eso : identity
          , eso1 = expensiveChecks || isPossiblyDangerousMemberName(key1) ? eso : identity
          , eso2 = expensiveChecks || isPossiblyDangerousMemberName(key2) ? eso : identity
          , eso3 = expensiveChecks || isPossiblyDangerousMemberName(key3) ? eso : identity
          , eso4 = expensiveChecks || isPossiblyDangerousMemberName(key4) ? eso : identity;
        return function(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            return null == pathVal ? pathVal : (pathVal = eso0(pathVal[key0]),
            key1 ? null == pathVal ? undefined : (pathVal = eso1(pathVal[key1]),
            key2 ? null == pathVal ? undefined : (pathVal = eso2(pathVal[key2]),
            key3 ? null == pathVal ? undefined : (pathVal = eso3(pathVal[key3]),
            key4 ? null == pathVal ? undefined : pathVal = eso4(pathVal[key4]) : pathVal) : pathVal) : pathVal) : pathVal)
        }
    }
    function getterFnWithEnsureSafeObject(fn, fullExpression) {
        return function(s, l) {
            return fn(s, l, ensureSafeObject, fullExpression)
        }
    }
    function getterFn(path, options, fullExp) {
        var expensiveChecks = options.expensiveChecks
          , getterFnCache = expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault
          , fn = getterFnCache[path];
        if (fn)
            return fn;
        var pathKeys = path.split(".")
          , pathKeysLength = pathKeys.length;
        if (options.csp)
            fn = pathKeysLength < 6 ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, expensiveChecks) : function(scope, locals) {
                var val, i = 0;
                do {
                    val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, expensiveChecks)(scope, locals),
                    locals = undefined,
                    scope = val
                } while (i < pathKeysLength);
                return val
            }
            ;
        else {
            var code = "";
            expensiveChecks && (code += "s = eso(s, fe);\nl = eso(l, fe);\n");
            var needsEnsureSafeObject = expensiveChecks;
            forEach(pathKeys, function(key, index) {
                ensureSafeMemberName(key, fullExp);
                var lookupJs = (index ? "s" : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + "." + key;
                (expensiveChecks || isPossiblyDangerousMemberName(key)) && (lookupJs = "eso(" + lookupJs + ", fe)",
                needsEnsureSafeObject = !0),
                code += "if(s == null) return undefined;\ns=" + lookupJs + ";\n"
            }),
            code += "return s;";
            var evaledFnGetter = new Function("s","l","eso","fe",code);
            evaledFnGetter.toString = valueFn(code),
            needsEnsureSafeObject && (evaledFnGetter = getterFnWithEnsureSafeObject(evaledFnGetter, fullExp)),
            fn = evaledFnGetter
        }
        return fn.sharedGetter = !0,
        fn.assign = function(self, value, locals) {
            return setter(self, locals, path, value, path)
        }
        ,
        getterFnCache[path] = fn,
        fn
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value)
    }
    function $ParseProvider() {
        var cacheDefault = createMap()
          , cacheExpensive = createMap();
        this.$get = ["$filter", "$sniffer", function($filter, $sniffer) {
            function wrapSharedExpression(exp) {
                var wrapped = exp;
                return exp.sharedGetter && (wrapped = function(self, locals) {
                    return exp(self, locals)
                }
                ,
                wrapped.literal = exp.literal,
                wrapped.constant = exp.constant,
                wrapped.assign = exp.assign),
                wrapped
            }
            function collectExpressionInputs(inputs, list) {
                for (var i = 0, ii = inputs.length; i < ii; i++) {
                    var input = inputs[i];
                    input.constant || (input.inputs ? collectExpressionInputs(input.inputs, list) : -1 === list.indexOf(input) && list.push(input))
                }
                return list
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : ("object" != typeof newValue || "object" != typeof (newValue = getValueOf(newValue))) && (newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue)
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var lastResult, inputExpressions = parsedExpression.$$inputs || (parsedExpression.$$inputs = collectExpressionInputs(parsedExpression.inputs, []));
                if (1 === inputExpressions.length) {
                    var oldInputValue = expressionInputDirtyCheck;
                    return inputExpressions = inputExpressions[0],
                    scope.$watch(function(scope) {
                        var newInputValue = inputExpressions(scope);
                        return expressionInputDirtyCheck(newInputValue, oldInputValue) || (lastResult = parsedExpression(scope),
                        oldInputValue = newInputValue && getValueOf(newInputValue)),
                        lastResult
                    }, listener, objectEquality)
                }
                for (var oldInputValueOfValues = [], i = 0, ii = inputExpressions.length; i < ii; i++)
                    oldInputValueOfValues[i] = expressionInputDirtyCheck;
                return scope.$watch(function(scope) {
                    for (var changed = !1, i = 0, ii = inputExpressions.length; i < ii; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) && (oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue))
                    }
                    return changed && (lastResult = parsedExpression(scope)),
                    lastResult
                }, listener, objectEquality)
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope)
                }, function(value, old, scope) {
                    lastValue = value,
                    isFunction(listener) && listener.apply(this, arguments),
                    isDefined(value) && scope.$$postDigest(function() {
                        isDefined(lastValue) && unwatch()
                    })
                }, objectEquality)
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                function isAllDefined(value) {
                    var allDefined = !0;
                    return forEach(value, function(val) {
                        isDefined(val) || (allDefined = !1)
                    }),
                    allDefined
                }
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope)
                }, function(value, old, scope) {
                    lastValue = value,
                    isFunction(listener) && listener.call(this, value, old, scope),
                    isAllDefined(value) && scope.$$postDigest(function() {
                        isAllDefined(lastValue) && unwatch()
                    })
                }, objectEquality)
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope)
                }, function(value, old, scope) {
                    isFunction(listener) && listener.apply(this, arguments),
                    unwatch()
                }, objectEquality)
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn)
                    return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate
                  , regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate
                  , fn = regularWatch ? function(scope, locals) {
                    var value = parsedExpression(scope, locals);
                    return interceptorFn(value, scope, locals)
                }
                : function(scope, locals) {
                    var value = parsedExpression(scope, locals)
                      , result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value
                }
                ;
                return parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate ? fn.$$watchDelegate = parsedExpression.$$watchDelegate : interceptorFn.$stateful || (fn.$$watchDelegate = inputsWatchDelegate,
                fn.inputs = [parsedExpression]),
                fn
            }
            var $parseOptions = {
                csp: $sniffer.csp,
                expensiveChecks: !1
            }
              , $parseOptionsExpensive = {
                csp: $sniffer.csp,
                expensiveChecks: !0
            };
            return function(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                case "string":
                    cacheKey = exp = exp.trim();
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    if (!(parsedExpression = cache[cacheKey])) {
                        ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0,
                        exp = exp.substring(2));
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions
                          , lexer = new Lexer(parseOptions);
                        parsedExpression = new Parser(lexer,$filter,parseOptions).parse(exp),
                        parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : oneTime ? (parsedExpression = wrapSharedExpression(parsedExpression),
                        parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate) : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate),
                        cache[cacheKey] = parsedExpression
                    }
                    return addInterceptor(parsedExpression, interceptorFn);
                case "function":
                    return addInterceptor(exp, interceptorFn);
                default:
                    return addInterceptor(noop, interceptorFn)
                }
            }
        }
        ]
    }
    function $QProvider() {
        this.$get = ["$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback)
            }, $exceptionHandler)
        }
        ]
    }
    function $$QProvider() {
        this.$get = ["$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback)
            }, $exceptionHandler)
        }
        ]
    }
    function qFactory(nextTick, exceptionHandler) {
        function callOnce(self, resolveFn, rejectFn) {
            function wrap(fn) {
                return function(value) {
                    called || (called = !0,
                    fn.call(self, value))
                }
            }
            var called = !1;
            return [wrap(resolveFn), wrap(rejectFn)]
        }
        function Promise() {
            this.$$state = {
                status: 0
            }
        }
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value)
            }
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending,
            state.processScheduled = !1,
            state.pending = undefined;
            for (var i = 0, ii = pending.length; i < ii; ++i) {
                promise = pending[i][0],
                fn = pending[i][state.status];
                try {
                    isFunction(fn) ? promise.resolve(fn(state.value)) : 1 === state.status ? promise.resolve(state.value) : promise.reject(state.value)
                } catch (e) {
                    promise.reject(e),
                    exceptionHandler(e)
                }
            }
        }
        function scheduleProcessQueue(state) {
            !state.processScheduled && state.pending && (state.processScheduled = !0,
            nextTick(function() {
                processQueue(state)
            }))
        }
        function Deferred() {
            this.promise = new Promise,
            this.resolve = simpleBind(this, this.resolve),
            this.reject = simpleBind(this, this.reject),
            this.notify = simpleBind(this, this.notify)
        }
        function all(promises) {
            var deferred = new Deferred
              , counter = 0
              , results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++,
                when(promise).then(function(value) {
                    results.hasOwnProperty(key) || (results[key] = value,
                    --counter || deferred.resolve(results))
                }, function(reason) {
                    results.hasOwnProperty(key) || deferred.reject(reason)
                })
            }),
            0 === counter && deferred.resolve(results),
            deferred.promise
        }
        var $qMinErr = minErr("$q", TypeError)
          , defer = function() {
            return new Deferred
        };
        Promise.prototype = {
            then: function(onFulfilled, onRejected, progressBack) {
                var result = new Deferred;
                return this.$$state.pending = this.$$state.pending || [],
                this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]),
                this.$$state.status > 0 && scheduleProcessQueue(this.$$state),
                result.promise
            },
            catch: function(callback) {
                return this.then(null, callback)
            },
            finally: function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, !0, callback)
                }, function(error) {
                    return handleCallback(error, !1, callback)
                }, progressBack)
            }
        },
        Deferred.prototype = {
            resolve: function(val) {
                this.promise.$$state.status || (val === this.promise ? this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : this.$$resolve(val))
            },
            $$resolve: function(val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    (isObject(val) || isFunction(val)) && (then = val && val.then),
                    isFunction(then) ? (this.promise.$$state.status = -1,
                    then.call(val, fns[0], fns[1], this.notify)) : (this.promise.$$state.value = val,
                    this.promise.$$state.status = 1,
                    scheduleProcessQueue(this.promise.$$state))
                } catch (e) {
                    fns[1](e),
                    exceptionHandler(e)
                }
            },
            reject: function(reason) {
                this.promise.$$state.status || this.$$reject(reason)
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason,
                this.promise.$$state.status = 2,
                scheduleProcessQueue(this.promise.$$state)
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                this.promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                    for (var callback, result, i = 0, ii = callbacks.length; i < ii; i++) {
                        result = callbacks[i][0],
                        callback = callbacks[i][3];
                        try {
                            result.notify(isFunction(callback) ? callback(progress) : progress)
                        } catch (e) {
                            exceptionHandler(e)
                        }
                    }
                })
            }
        };
        var reject = function(reason) {
            var result = new Deferred;
            return result.reject(reason),
            result.promise
        }
          , makePromise = function(value, resolved) {
            var result = new Deferred;
            return resolved ? result.resolve(value) : result.reject(value),
            result.promise
        }
          , handleCallback = function(value, isResolved, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback())
            } catch (e) {
                return makePromise(e, !1)
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                return makePromise(value, isResolved)
            }, function(error) {
                return makePromise(error, !1)
            }) : makePromise(value, isResolved)
        }
          , when = function(value, callback, errback, progressBack) {
            var result = new Deferred;
            return result.resolve(value),
            result.promise.then(callback, errback, progressBack)
        }
          , $Q = function Q(resolver) {
            function resolveFn(value) {
                deferred.resolve(value)
            }
            function rejectFn(reason) {
                deferred.reject(reason)
            }
            if (!isFunction(resolver))
                throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            if (!(this instanceof Q))
                return new Q(resolver);
            var deferred = new Deferred;
            return resolver(resolveFn, rejectFn),
            deferred.promise
        };
        return $Q.defer = defer,
        $Q.reject = reject,
        $Q.when = when,
        $Q.all = all,
        $Q
    }
    function $$RAFProvider() {
        this.$get = ["$window", "$timeout", function($window, $timeout) {
            function flush() {
                for (var i = 0; i < taskQueue.length; i++) {
                    var task = taskQueue[i];
                    task && (taskQueue[i] = null,
                    task())
                }
                taskCount = taskQueue.length = 0
            }
            function queueFn(asyncFn) {
                var index = taskQueue.length;
                return taskCount++,
                taskQueue.push(asyncFn),
                0 === index && (cancelLastRAF = rafFn(flush)),
                function() {
                    index >= 0 && (taskQueue[index] = null,
                    index = null,
                    0 == --taskCount && cancelLastRAF && (cancelLastRAF(),
                    cancelLastRAF = null,
                    taskQueue.length = 0))
                }
            }
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame
              , cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame
              , rafSupported = !!requestAnimationFrame
              , rafFn = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id)
                }
            }
            : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer)
                }
            }
            ;
            queueFn.supported = rafSupported;
            var cancelLastRAF, taskCount = 0, taskQueue = [];
            return queueFn
        }
        ]
    }
    function $RootScopeProvider() {
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null,
                this.$$listeners = {},
                this.$$listenerCount = {},
                this.$id = nextUid(),
                this.$$ChildScope = null
            }
            return ChildScope.prototype = parent,
            ChildScope
        }
        var TTL = 10
          , $rootScopeMinErr = minErr("$rootScope")
          , lastDirtyWatch = null
          , applyAsyncId = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value),
            TTL
        }
        ,
        this.$get = ["$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = !0
            }
            function Scope() {
                this.$id = nextUid(),
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null,
                this.$root = this,
                this.$$destroyed = !1,
                this.$$listeners = {},
                this.$$listenerCount = {},
                this.$$isolateBindings = null
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase)
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase
            }
            function clearPhase() {
                $rootScope.$$phase = null
            }
            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count,
                    0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]
                } while (current = current.$parent)
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                for (; applyAsyncQueue.length; )
                    try {
                        applyAsyncQueue.shift()()
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                applyAsyncId = null
            }
            function scheduleApplyAsync() {
                null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                    $rootScope.$apply(flushApplyAsync)
                }))
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    return parent = parent || this,
                    isolate ? (child = new Scope,
                    child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)),
                    child = new this.$$ChildScope),
                    child.$parent = parent,
                    child.$$prevSibling = parent.$$childTail,
                    parent.$$childHead ? (parent.$$childTail.$$nextSibling = child,
                    parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child,
                    (isolate || parent != this) && child.$on("$destroy", destroyChildScope),
                    child
                },
                $watch: function(watchExp, listener, objectEquality) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate)
                        return get.$$watchDelegate(this, listener, objectEquality, get);
                    var scope = this
                      , array = scope.$$watchers
                      , watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: watchExp,
                        eq: !!objectEquality
                    };
                    return lastDirtyWatch = null,
                    isFunction(listener) || (watcher.fn = noop),
                    array || (array = scope.$$watchers = []),
                    array.unshift(watcher),
                    function() {
                        arrayRemove(array, watcher),
                        lastDirtyWatch = null
                    }
                },
                $watchGroup: function(watchExpressions, listener) {
                    function watchGroupAction() {
                        changeReactionScheduled = !1,
                        firstRun ? (firstRun = !1,
                        listener(newValues, newValues, self)) : listener(newValues, oldValues, self)
                    }
                    var oldValues = new Array(watchExpressions.length)
                      , newValues = new Array(watchExpressions.length)
                      , deregisterFns = []
                      , self = this
                      , changeReactionScheduled = !1
                      , firstRun = !0;
                    if (!watchExpressions.length) {
                        var shouldCall = !0;
                        return self.$evalAsync(function() {
                            shouldCall && listener(newValues, newValues, self)
                        }),
                        function() {
                            shouldCall = !1
                        }
                    }
                    return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                        newValues[0] = value,
                        oldValues[0] = oldValue,
                        listener(newValues, value === oldValue ? newValues : oldValues, scope)
                    }) : (forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function(value, oldValue) {
                            newValues[i] = value,
                            oldValues[i] = oldValue,
                            changeReactionScheduled || (changeReactionScheduled = !0,
                            self.$evalAsync(watchGroupAction))
                        });
                        deregisterFns.push(unwatchFn)
                    }),
                    function() {
                        for (; deregisterFns.length; )
                            deregisterFns.shift()()
                    }
                    )
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, newItem, oldItem;
                        if (!isUndefined(newValue)) {
                            if (isObject(newValue))
                                if (isArrayLike(newValue)) {
                                    oldValue !== internalArray && (oldValue = internalArray,
                                    oldLength = oldValue.length = 0,
                                    changeDetected++),
                                    newLength = newValue.length,
                                    oldLength !== newLength && (changeDetected++,
                                    oldValue.length = oldLength = newLength);
                                    for (var i = 0; i < newLength; i++)
                                        oldItem = oldValue[i],
                                        newItem = newValue[i],
                                        oldItem !== oldItem && newItem !== newItem || oldItem === newItem || (changeDetected++,
                                        oldValue[i] = newItem)
                                } else {
                                    oldValue !== internalObject && (oldValue = internalObject = {},
                                    oldLength = 0,
                                    changeDetected++),
                                    newLength = 0;
                                    for (key in newValue)
                                        newValue.hasOwnProperty(key) && (newLength++,
                                        newItem = newValue[key],
                                        oldItem = oldValue[key],
                                        key in oldValue ? oldItem !== oldItem && newItem !== newItem || oldItem === newItem || (changeDetected++,
                                        oldValue[key] = newItem) : (oldLength++,
                                        oldValue[key] = newItem,
                                        changeDetected++));
                                    if (oldLength > newLength) {
                                        changeDetected++;
                                        for (key in oldValue)
                                            newValue.hasOwnProperty(key) || (oldLength--,
                                            delete oldValue[key])
                                    }
                                }
                            else
                                oldValue !== newValue && (oldValue = newValue,
                                changeDetected++);
                            return changeDetected
                        }
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1,
                        listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self),
                        trackVeryOldValue)
                            if (isObject(newValue))
                                if (isArrayLike(newValue)) {
                                    veryOldValue = new Array(newValue.length);
                                    for (var i = 0; i < newValue.length; i++)
                                        veryOldValue[i] = newValue[i]
                                } else {
                                    veryOldValue = {};
                                    for (var key in newValue)
                                        hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key])
                                }
                            else
                                veryOldValue = newValue
                    }
                    $watchCollectionInterceptor.$stateful = !0;
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch(changeDetector, $watchCollectionAction)
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = this, watchLog = [];
                    beginPhase("$digest"),
                    $browser.$$checkUrlChange(),
                    this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId),
                    flushApplyAsync()),
                    lastDirtyWatch = null;
                    do {
                        for (dirty = !1,
                        current = target; asyncQueue.length; ) {
                            try {
                                asyncTask = asyncQueue.shift(),
                                asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                            lastDirtyWatch = null
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers)
                                for (length = watchers.length; length--; )
                                    try {
                                        if (watch = watchers[length])
                                            if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                                if (watch === lastDirtyWatch) {
                                                    dirty = !1;
                                                    break traverseScopesLoop
                                                }
                                            } else
                                                dirty = !0,
                                                lastDirtyWatch = watch,
                                                watch.last = watch.eq ? copy(value, null) : value,
                                                watch.fn(value, last === initWatchVal ? value : last, current),
                                                ttl < 5 && (logIdx = 4 - ttl,
                                                watchLog[logIdx] || (watchLog[logIdx] = []),
                                                watchLog[logIdx].push({
                                                    msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                    newVal: value,
                                                    oldVal: last
                                                }))
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling))
                                for (; current !== target && !(next = current.$$nextSibling); )
                                    current = current.$parent
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--)
                            throw clearPhase(),
                            $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog)
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueue.length; )
                        try {
                            postDigestQueue.shift()()
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        if (this.$broadcast("$destroy"),
                        this.$$destroyed = !0,
                        this !== $rootScope) {
                            for (var eventName in this.$$listenerCount)
                                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling),
                            parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling),
                            this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling),
                            this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling),
                            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop,
                            this.$on = this.$watch = this.$watchGroup = function() {
                                return noop
                            }
                            ,
                            this.$$listeners = {},
                            this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null
                        }
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals)
                },
                $evalAsync: function(expr, locals) {
                    $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                        asyncQueue.length && $rootScope.$digest()
                    }),
                    asyncQueue.push({
                        scope: this,
                        expression: expr,
                        locals: locals
                    })
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn)
                },
                $apply: function(expr) {
                    try {
                        return beginPhase("$apply"),
                        this.$eval(expr)
                    } catch (e) {
                        $exceptionHandler(e)
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest()
                        } catch (e) {
                            throw $exceptionHandler(e),
                            e
                        }
                    }
                },
                $applyAsync: function(expr) {
                    function $applyAsyncExpression() {
                        scope.$eval(expr)
                    }
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression),
                    scheduleApplyAsync()
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []),
                    namedListeners.push(listener);
                    var current = this;
                    do {
                        current.$$listenerCount[name] || (current.$$listenerCount[name] = 0),
                        current.$$listenerCount[name]++
                    } while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        -1 !== indexOfListener && (namedListeners[indexOfListener] = null,
                        decrementListenerCount(self, 1, name))
                    }
                },
                $emit: function(name, args) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([event], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty,
                        event.currentScope = scope,
                        i = 0,
                        length = namedListeners.length; i < length; i++)
                            if (namedListeners[i])
                                try {
                                    namedListeners[i].apply(null, listenerArgs)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                            else
                                namedListeners.splice(i, 1),
                                i--,
                                length--;
                        if (stopPropagation)
                            return event.currentScope = null,
                            event;
                        scope = scope.$parent
                    } while (scope);
                    return event.currentScope = null,
                    event
                },
                $broadcast: function(name, args) {
                    var target = this
                      , current = target
                      , next = target
                      , event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0
                        },
                        defaultPrevented: !1
                    };
                    if (!target.$$listenerCount[name])
                        return event;
                    for (var listeners, i, length, listenerArgs = concat([event], arguments, 1); current = next; ) {
                        for (event.currentScope = current,
                        listeners = current.$$listeners[name] || [],
                        i = 0,
                        length = listeners.length; i < length; i++)
                            if (listeners[i])
                                try {
                                    listeners[i].apply(null, listenerArgs)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                            else
                                listeners.splice(i, 1),
                                i--,
                                length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling))
                            for (; current !== target && !(next = current.$$nextSibling); )
                                current = current.$parent
                    }
                    return event.currentScope = null,
                    event
                }
            };
            var $rootScope = new Scope
              , asyncQueue = $rootScope.$$asyncQueue = []
              , postDigestQueue = $rootScope.$$postDigestQueue = []
              , applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            return $rootScope
        }
        ]
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/
          , imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp,
            this) : aHrefSanitizationWhitelist
        }
        ,
        this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp,
            this) : imgSrcSanitizationWhitelist
        }
        ,
        this.$get = function() {
            return function(uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return normalizedVal = urlResolve(uri).href,
                "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal
            }
        }
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher)
            return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1)
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"),
            new RegExp("^" + matcher + "$")
        }
        if (isRegExp(matcher))
            return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects')
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher))
        }),
        adjustedMatchers
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ["self"]
          , resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)),
            resourceUrlWhitelist
        }
        ,
        this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)),
            resourceUrlBlacklist
        }
        ,
        this.$get = ["$injector", function($injector) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href)
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0,
                n = resourceUrlWhitelist.length; i < n; i++)
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = !0;
                        break
                    }
                if (allowed)
                    for (i = 0,
                    n = resourceUrlBlacklist.length; i < n; i++)
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = !1;
                            break
                        }
                return allowed
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue
                    }
                };
                return Base && (holderType.prototype = new Base),
                holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue()
                }
                ,
                holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString()
                }
                ,
                holderType
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor)
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || trustedValue === undefined || "" === trustedValue)
                    return trustedValue;
                if ("string" != typeof trustedValue)
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue)
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted)
                    return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor)
                    return maybeTrusted.$$unwrapTrustedValue();
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted))
                        return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString())
                }
                if (type === SCE_CONTEXTS.HTML)
                    return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
            }
            var htmlSanitizer = function(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType()
              , byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase),
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase),
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase),
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase),
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]),
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            }
        }
        ]
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value),
            enabled
        }
        ,
        this.$get = ["$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && msie < 8)
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled
            }
            ,
            sce.trustAs = $sceDelegate.trustAs,
            sce.getTrusted = $sceDelegate.getTrusted,
            sce.valueOf = $sceDelegate.valueOf,
            enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value
            }
            ,
            sce.valueOf = identity),
            sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                    return sce.getTrusted(type, value)
                })
            }
            ;
            var parse = sce.parseAs
              , getTrusted = sce.getTrusted
              , trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr)
                }
                ,
                sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value)
                }
                ,
                sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value)
                }
            }),
            sce
        }
        ]
    }
    function $SnifferProvider() {
        this.$get = ["$window", "$document", function($window, $document) {
            var vendorPrefix, match, eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            if (bodyStyle) {
                for (var prop in bodyStyle)
                    if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0],
                        vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                        break
                    }
                vendorPrefix || (vendorPrefix = "WebkitOpacity"in bodyStyle && "webkit"),
                transitions = !!("transition"in bodyStyle || vendorPrefix + "Transition"in bodyStyle),
                animations = !!("animation"in bodyStyle || vendorPrefix + "Animation"in bodyStyle),
                !android || transitions && animations || (transitions = isString(document.body.style.webkitTransition),
                animations = isString(document.body.style.webkitAnimation))
            }
            return {
                history: !(!$window.history || !$window.history.pushState || android < 4 || boxee),
                hasEvent: function(event) {
                    if ("input" === event && msie <= 11)
                        return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm
                    }
                    return eventSupport[event]
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            }
        }
        ]
    }
    function $TemplateRequestProvider() {
        this.$get = ["$templateCache", "$http", "$q", "$sce", function($templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                function handleError(resp) {
                    if (!ignoreRequestError)
                        throw $compileMinErr("tpload", "Failed to load template: {0}", tpl);
                    return $q.reject(resp)
                }
                handleRequestFn.totalPendingRequests++,
                isString(tpl) && $templateCache.get(tpl) || (tpl = $sce.getTrustedResourceUrl(tpl));
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                    return transformer !== defaultHttpResponseTransform
                }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null);
                var httpOptions = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                return $http.get(tpl, httpOptions).finally(function() {
                    handleRequestFn.totalPendingRequests--
                }).then(function(response) {
                    return response.data
                }, handleError)
            }
            return handleRequestFn.totalPendingRequests = 0,
            handleRequestFn
        }
        ]
    }
    function $$TestabilityProvider() {
        this.$get = ["$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            return testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding")
                  , matches = [];
                return forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    dataBinding && forEach(dataBinding, function(bindingName) {
                        if (opt_exactMatch) {
                            new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)").test(bindingName) && matches.push(binding)
                        } else
                            -1 != bindingName.indexOf(expression) && matches.push(binding)
                    })
                }),
                matches
            }
            ,
            testability.findModels = function(element, expression, opt_exactMatch) {
                for (var prefixes = ["ng-", "data-ng-", "ng\\:"], p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*="
                      , selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]'
                      , elements = element.querySelectorAll(selector);
                    if (elements.length)
                        return elements
                }
            }
            ,
            testability.getLocation = function() {
                return $location.url()
            }
            ,
            testability.setLocation = function(url) {
                url !== $location.url() && ($location.url(url),
                $rootScope.$digest())
            }
            ,
            testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback)
            }
            ,
            testability
        }
        ]
    }
    function $TimeoutProvider() {
        this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                var timeoutId, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn())
                    } catch (e) {
                        deferred.reject(e),
                        $exceptionHandler(e)
                    } finally {
                        delete deferreds[promise.$$timeoutId]
                    }
                    skipApply || $rootScope.$apply()
                }, delay),
                promise.$$timeoutId = timeoutId,
                deferreds[timeoutId] = deferred,
                promise
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                return !!(promise && promise.$$timeoutId in deferreds) && (deferreds[promise.$$timeoutId].reject("canceled"),
                delete deferreds[promise.$$timeoutId],
                $browser.defer.cancel(promise.$$timeoutId))
            }
            ,
            timeout
        }
        ]
    }
    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href),
        href = urlParsingNode.href),
        urlParsingNode.setAttribute("href", href),
        {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        }
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host
    }
    function $WindowProvider() {
        this.$get = valueFn(window)
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter)
                }),
                filters
            }
            return $provide.factory(name + suffix, factory)
        }
        var suffix = "Filter";
        this.register = register,
        this.$get = ["$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix)
            }
        }
        ],
        register("currency", currencyFilter),
        register("date", dateFilter),
        register("filter", filterFilter),
        register("json", jsonFilter),
        register("limitTo", limitToFilter),
        register("lowercase", lowercaseFilter),
        register("number", numberFilter),
        register("orderBy", orderByFilter),
        register("uppercase", uppercaseFilter)
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array))
                return array;
            var predicateFn, matchAgainstAnyProp, expressionType = null !== expression ? typeof expression : "null";
            switch (expressionType) {
            case "function":
                predicateFn = expression;
                break;
            case "boolean":
            case "null":
            case "number":
            case "string":
                matchAgainstAnyProp = !0;
            case "object":
                predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                break;
            default:
                return array
            }
            return array.filter(predicateFn)
        }
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && "$"in expression;
        return !0 === comparator ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
            return !isUndefined(actual) && (null === actual || null === expected ? actual === expected : !isObject(actual) && !isObject(expected) && (actual = lowercase("" + actual),
            expected = lowercase("" + expected),
            -1 !== actual.indexOf(expected)))
        }
        ),
        function(item) {
            return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression.$, comparator, !1) : deepCompare(item, expression, comparator, matchAgainstAnyProp)
        }
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = null !== actual ? typeof actual : "null"
          , expectedType = null !== expected ? typeof expected : "null";
        if ("string" === expectedType && "!" === expected.charAt(0))
            return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        if (isArray(actual))
            return actual.some(function(item) {
                return deepCompare(item, expected, comparator, matchAgainstAnyProp)
            });
        switch (actualType) {
        case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual)
                    if ("$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, !0))
                        return !0;
                return !dontMatchWholeObject && deepCompare(actual, expected, comparator, !1)
            }
            if ("object" === expectedType) {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                        var matchAnyProperty = "$" === key;
                        if (!deepCompare(matchAnyProperty ? actual : actual[key], expectedVal, comparator, matchAnyProperty, matchAnyProperty))
                            return !1
                    }
                }
                return !0
            }
            return comparator(actual, expected);
        case "function":
            return !1;
        default:
            return comparator(actual, expected)
        }
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM),
            isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac),
            null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol)
        }
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize)
        }
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isFinite(number) || isObject(number))
            return "";
        var isNegative = number < 0;
        number = Math.abs(number);
        var numStr = number + ""
          , formatedText = ""
          , parts = []
          , hasExponent = !1;
        if (-1 !== numStr.indexOf("e")) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            match && "-" == match[2] && match[3] > fractionSize + 1 ? number = 0 : (formatedText = numStr,
            hasExponent = !0)
        }
        if (hasExponent)
            fractionSize > 0 && number < 1 && (formatedText = number.toFixed(fractionSize),
            number = parseFloat(formatedText));
        else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)),
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP)
              , whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group)
                for (pos = whole.length - lgroup,
                i = 0; i < pos; i++)
                    (pos - i) % group == 0 && 0 !== i && (formatedText += groupSep),
                    formatedText += whole.charAt(i);
            for (i = pos; i < whole.length; i++)
                (whole.length - i) % lgroup == 0 && 0 !== i && (formatedText += groupSep),
                formatedText += whole.charAt(i);
            for (; fraction.length < fractionSize; )
                fraction += "0";
            fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize))
        }
        return 0 === number && (isNegative = !1),
        parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf),
        parts.join("")
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        for (num < 0 && (neg = "-",
        num = -num),
        num = "" + num; num.length < digits; )
            num = "0" + num;
        return trim && (num = num.substr(num.length - digits)),
        neg + num
    }
    function dateGetter(name, size, offset, trim) {
        return offset = offset || 0,
        function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset),
            0 === value && -12 == offset && (value = 12),
            padNumber(value, size, trim)
        }
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name]();
            return formats[uppercase(shortForm ? "SHORT" + name : name)][value]
        }
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset()
          , paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year,0,1).getDay();
        return new Date(year,0,(dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst)
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(),datetime.getMonth(),datetime.getDate() + (4 - datetime.getDay()))
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear())
              , thisThurs = getThursdayThisWeek(date)
              , diff = +thisThurs - +firstThurs;
            return padNumber(1 + Math.round(diff / 6048e5), size)
        }
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1]
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1]
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0)
                  , tzHour = 0
                  , tzMin = 0
                  , dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear
                  , timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = int(match[9] + match[10]),
                tzMin = int(match[9] + match[11])),
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour
                  , m = int(match[5] || 0) - tzMin
                  , s = int(match[6] || 0)
                  , ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms),
                date
            }
            return string
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate",
            format = $locale.DATETIME_FORMATS[format] || format,
            isString(date) && (date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date)),
            isNumber(date) && (date = new Date(date)),
            !isDate(date))
                return date;
            for (; format; )
                match = DATE_FORMATS_SPLIT.exec(format),
                match ? (parts = concat(parts, match, 1),
                format = parts.pop()) : (parts.push(format),
                format = null);
            return timezone && "UTC" === timezone && (date = new Date(date.getTime()),
            date.setMinutes(date.getMinutes() + date.getTimezoneOffset())),
            forEach(parts, function(value) {
                fn = DATE_FORMATS[value],
                text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
            }),
            text
        }
    }
    function jsonFilter() {
        return function(object, spacing) {
            return isUndefined(spacing) && (spacing = 2),
            toJson(object, spacing)
        }
    }
    function limitToFilter() {
        return function(input, limit) {
            return isNumber(input) && (input = input.toString()),
            isArray(input) || isString(input) ? (limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : int(limit),
            limit ? limit > 0 ? input.slice(0, limit) : input.slice(limit) : isString(input) ? "" : []) : input
        }
    }
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (0 !== comp)
                        return comp
                }
                return 0
            }
            function reverseComparator(comp, descending) {
                return descending ? function(a, b) {
                    return comp(b, a)
                }
                : comp
            }
            function isPrimitive(value) {
                switch (typeof value) {
                case "number":
                case "boolean":
                case "string":
                    return !0;
                default:
                    return !1
                }
            }
            function objectToString(value) {
                return null === value ? "null" : "function" == typeof value.valueOf && (value = value.valueOf(),
                isPrimitive(value)) ? value : "function" == typeof value.toString && (value = value.toString(),
                isPrimitive(value)) ? value : ""
            }
            function compare(v1, v2) {
                var t1 = typeof v1
                  , t2 = typeof v2;
                return t1 === t2 && "object" === t1 && (v1 = objectToString(v1),
                v2 = objectToString(v2)),
                t1 === t2 ? ("string" === t1 && (v1 = v1.toLowerCase(),
                v2 = v2.toLowerCase()),
                v1 === v2 ? 0 : v1 < v2 ? -1 : 1) : t1 < t2 ? -1 : 1
            }
            return isArrayLike(array) ? (sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate],
            0 === sortPredicate.length && (sortPredicate = ["+"]),
            sortPredicate = sortPredicate.map(function(predicate) {
                var descending = !1
                  , get = predicate || identity;
                if (isString(predicate)) {
                    if ("+" != predicate.charAt(0) && "-" != predicate.charAt(0) || (descending = "-" == predicate.charAt(0),
                    predicate = predicate.substring(1)),
                    "" === predicate)
                        return reverseComparator(compare, descending);
                    if (get = $parse(predicate),
                    get.constant) {
                        var key = get();
                        return reverseComparator(function(a, b) {
                            return compare(a[key], b[key])
                        }, descending)
                    }
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b))
                }, descending)
            }),
            slice.call(array).sort(reverseComparator(comparator, reverseOrder))) : array
        }
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }),
        directive.restrict = directive.restrict || "AC",
        valueFn(directive)
    }
    function nullFormRenameControl(control, name) {
        control.$name = name
    }
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this
          , controls = []
          , parentForm = form.$$parentForm = element.parent().controller("form") || nullFormCtrl;
        form.$error = {},
        form.$$success = {},
        form.$pending = undefined,
        form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope),
        form.$dirty = !1,
        form.$pristine = !0,
        form.$valid = !0,
        form.$invalid = !1,
        form.$submitted = !1,
        parentForm.$addControl(form),
        form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue()
            })
        }
        ,
        form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue()
            })
        }
        ,
        form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input"),
            controls.push(control),
            control.$name && (form[control.$name] = control)
        }
        ,
        form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            form[oldName] === control && delete form[oldName],
            form[newName] = control,
            control.$name = newName
        }
        ,
        form.$removeControl = function(control) {
            control.$name && form[control.$name] === control && delete form[control.$name],
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control)
            }),
            forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control)
            }),
            forEach(form.$$success, function(value, name) {
                form.$setValidity(name, null, control)
            }),
            arrayRemove(controls, control)
        }
        ,
        addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, controller) {
                var list = object[property];
                if (list) {
                    -1 === list.indexOf(controller) && list.push(controller)
                } else
                    object[property] = [controller]
            },
            unset: function(object, property, controller) {
                var list = object[property];
                list && (arrayRemove(list, controller),
                0 === list.length && delete object[property])
            },
            parentForm: parentForm,
            $animate: $animate
        }),
        form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS),
            $animate.addClass(element, DIRTY_CLASS),
            form.$dirty = !0,
            form.$pristine = !1,
            parentForm.$setDirty()
        }
        ,
        form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS),
            form.$dirty = !1,
            form.$pristine = !0,
            form.$submitted = !1,
            forEach(controls, function(control) {
                control.$setPristine()
            })
        }
        ,
        form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched()
            })
        }
        ,
        form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS),
            form.$submitted = !0,
            parentForm.$setSubmitted()
        }
    }
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString()
        })
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser),
        stringBasedInputType(ctrl)
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function(data) {
                composing = !0
            }),
            element.on("compositionend", function() {
                composing = !1,
                listener()
            })
        }
        var listener = function(ev) {
            if (timeout && ($browser.defer.cancel(timeout),
            timeout = null),
            !composing) {
                var value = element.val()
                  , event = ev && ev.type;
                "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)),
                (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event)
            }
        };
        if ($sniffer.hasEvent("input"))
            element.on("input", listener);
        else {
            var timeout, deferListener = function(ev, input, origValue) {
                timeout || (timeout = $browser.defer(function() {
                    timeout = null,
                    input && input.value === origValue || listener(ev)
                }))
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || 15 < key && key < 19 || 37 <= key && key <= 40 || deferListener(event, this, this.value)
            }),
            $sniffer.hasEvent("paste") && element.on("paste cut", deferListener)
        }
        element.on("change", listener),
        ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue)
        }
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek))
            return isoWeek;
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1]
                  , week = +parts[2]
                  , hours = 0
                  , minutes = 0
                  , seconds = 0
                  , milliseconds = 0
                  , firstThurs = getFirstThursdayOfYear(year)
                  , addDays = 7 * (week - 1);
                return existingDate && (hours = existingDate.getHours(),
                minutes = existingDate.getMinutes(),
                seconds = existingDate.getSeconds(),
                milliseconds = existingDate.getMilliseconds()),
                new Date(year,0,firstThurs.getDate() + addDays,hours,minutes,seconds,milliseconds)
            }
        }
        return NaN
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso))
                return iso;
            if (isString(iso)) {
                if ('"' == iso.charAt(0) && '"' == iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)),
                ISO_DATE_REGEXP.test(iso))
                    return new Date(iso);
                if (regexp.lastIndex = 0,
                parts = regexp.exec(iso))
                    return parts.shift(),
                    map = date ? {
                        yyyy: date.getFullYear(),
                        MM: date.getMonth() + 1,
                        dd: date.getDate(),
                        HH: date.getHours(),
                        mm: date.getMinutes(),
                        ss: date.getSeconds(),
                        sss: date.getMilliseconds() / 1e3
                    } : {
                        yyyy: 1970,
                        MM: 1,
                        dd: 1,
                        HH: 0,
                        mm: 0,
                        ss: 0,
                        sss: 0
                    },
                    forEach(parts, function(part, index) {
                        index < mapping.length && (map[mapping[index]] = +part)
                    }),
                    new Date(map.yyyy,map.MM - 1,map.dd,map.HH,map.mm,map.ss || 0,1e3 * map.sss || 0)
            }
            return NaN
        }
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime())
            }
            function parseObservedDateValue(val) {
                return isDefined(val) ? isDate(val) ? val : parseDate(val) : undefined
            }
            badInputChecker(scope, element, attr, ctrl),
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var previousDate, timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            if (ctrl.$$parserName = type,
            ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value))
                    return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    return "UTC" === timezone && parsedDate.setMinutes(parsedDate.getMinutes() - parsedDate.getTimezoneOffset()),
                    parsedDate
                }
                return undefined
            }),
            ctrl.$formatters.push(function(value) {
                if (value && !isDate(value))
                    throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                if (isValidDate(value)) {
                    if ((previousDate = value) && "UTC" === timezone) {
                        var timezoneOffset = 6e4 * previousDate.getTimezoneOffset();
                        previousDate = new Date(previousDate.getTime() + timezoneOffset)
                    }
                    return $filter("date")(value, format, timezone)
                }
                return previousDate = null,
                ""
            }),
            isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal
                }
                ,
                attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val),
                    ctrl.$validate()
                })
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal
                }
                ,
                attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val),
                    ctrl.$validate()
                })
            }
        }
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        (ctrl.$$hasNativeValidators = isObject(node.validity)) && ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value
        })
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        if (badInputChecker(scope, element, attr, ctrl),
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser),
        ctrl.$$parserName = "number",
        ctrl.$parsers.push(function(value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : undefined
        }),
        ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value))
                    throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString()
            }
            return value
        }),
        isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal
            }
            ,
            attr.$observe("min", function(val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)),
                minVal = isNumber(val) && !isNaN(val) ? val : undefined,
                ctrl.$validate()
            })
        }
        if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal
            }
            ,
            attr.$observe("max", function(val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)),
                maxVal = isNumber(val) && !isNaN(val) ? val : undefined,
                ctrl.$validate()
            })
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser),
        stringBasedInputType(ctrl),
        ctrl.$$parserName = "url",
        ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value)
        }
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser),
        stringBasedInputType(ctrl),
        ctrl.$$parserName = "email",
        ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value)
        }
    }
    function radioInputType(scope, element, attr, ctrl) {
        isUndefined(attr.name) && element.attr("name", nextUid());
        var listener = function(ev) {
            element[0].checked && ctrl.$setViewValue(attr.value, ev && ev.type)
        };
        element.on("click", listener),
        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue
        }
        ,
        attr.$observe("value", ctrl.$render)
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            if (parseFn = $parse(expression),
            !parseFn.constant)
                throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            return parseFn(context)
        }
        return fallback
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0)
          , falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1)
          , listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type)
        };
        element.on("click", listener),
        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue
        }
        ,
        ctrl.$isEmpty = function(value) {
            return !1 === value
        }
        ,
        ctrl.$formatters.push(function(value) {
            return equals(value, trueValue)
        }),
        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue
        })
    }
    function classDirective(name, selector) {
        return name = "ngClass" + name,
        ["$animate", function($animate) {
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                        if (token == tokens2[j])
                            continue outer;
                    values.push(token)
                }
                return values
            }
            function arrayClasses(classVal) {
                if (isArray(classVal))
                    return classVal;
                if (isString(classVal))
                    return classVal.split(" ");
                if (isObject(classVal)) {
                    var classes = [];
                    return forEach(classVal, function(v, k) {
                        v && (classes = classes.concat(k.split(" ")))
                    }),
                    classes
                }
                return classVal
            }
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses)
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses)
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {}
                          , classesToUpdate = [];
                        return forEach(classes, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count,
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className))
                        }),
                        element.data("$classCounts", classCounts),
                        classesToUpdate.join(" ")
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses)
                          , toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1),
                        toRemove = digestClassCounts(toRemove, -1),
                        toAdd && toAdd.length && $animate.addClass(element, toAdd),
                        toRemove && toRemove.length && $animate.removeClass(element, toRemove)
                    }
                    function ngClassWatchAction(newVal) {
                        if (!0 === selector || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (oldVal) {
                                if (!equals(newVal, oldVal)) {
                                    var oldClasses = arrayClasses(oldVal);
                                    updateClasses(oldClasses, newClasses)
                                }
                            } else
                                addClasses(newClasses)
                        }
                        oldVal = shallowCopy(newVal)
                    }
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, !0),
                    attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]))
                    }),
                    "ngClass" !== name && scope.$watch("$index", function($index, old$index) {
                        var mod = 1 & $index;
                        if (mod !== (1 & old$index)) {
                            var classes = arrayClasses(scope.$eval(attr[name]));
                            mod === selector ? addClasses(classes) : removeClasses(classes)
                        }
                    })
                }
            }
        }
        ]
    }
    function addSetValidityMethod(context) {
        function setValidity(validationErrorKey, state, controller) {
            state === undefined ? createAndSet("$pending", validationErrorKey, controller) : unsetAndCleanup("$pending", validationErrorKey, controller),
            isBoolean(state) ? state ? (unset(ctrl.$error, validationErrorKey, controller),
            set(ctrl.$$success, validationErrorKey, controller)) : (set(ctrl.$error, validationErrorKey, controller),
            unset(ctrl.$$success, validationErrorKey, controller)) : (unset(ctrl.$error, validationErrorKey, controller),
            unset(ctrl.$$success, validationErrorKey, controller)),
            ctrl.$pending ? (cachedToggleClass(PENDING_CLASS, !0),
            ctrl.$valid = ctrl.$invalid = undefined,
            toggleValidationCss("", null)) : (cachedToggleClass(PENDING_CLASS, !1),
            ctrl.$valid = isObjectEmpty(ctrl.$error),
            ctrl.$invalid = !ctrl.$valid,
            toggleValidationCss("", ctrl.$valid));
            var combinedState;
            combinedState = ctrl.$pending && ctrl.$pending[validationErrorKey] ? undefined : !ctrl.$error[validationErrorKey] && (!!ctrl.$$success[validationErrorKey] || null),
            toggleValidationCss(validationErrorKey, combinedState),
            parentForm.$setValidity(validationErrorKey, combinedState, ctrl)
        }
        function createAndSet(name, value, controller) {
            ctrl[name] || (ctrl[name] = {}),
            set(ctrl[name], value, controller)
        }
        function unsetAndCleanup(name, value, controller) {
            ctrl[name] && unset(ctrl[name], value, controller),
            isObjectEmpty(ctrl[name]) && (ctrl[name] = undefined)
        }
        function cachedToggleClass(className, switchValue) {
            switchValue && !classCache[className] ? ($animate.addClass($element, className),
            classCache[className] = !0) : !switchValue && classCache[className] && ($animate.removeClass($element, className),
            classCache[className] = !1)
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "",
            cachedToggleClass(VALID_CLASS + validationErrorKey, !0 === isValid),
            cachedToggleClass(INVALID_CLASS + validationErrorKey, !1 === isValid)
        }
        var ctrl = context.ctrl
          , $element = context.$element
          , classCache = {}
          , set = context.set
          , unset = context.unset
          , parentForm = context.parentForm
          , $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS)),
        ctrl.$setValidity = setValidity
    }
    function isObjectEmpty(obj) {
        if (obj)
            for (var prop in obj)
                return !1;
        return !0
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/
      , VALIDITY_STATE_PROPERTY = "validity"
      , lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string
    }
      , hasOwnProperty = Object.prototype.hasOwnProperty
      , uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string
    }
      , manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0))
        }) : s
    }
      , manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0))
        }) : s
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase,
    uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    msie = document.documentMode,
    noop.$inject = [],
    identity.$inject = [];
    var skipDestroyOnNextJQueryCleanData, isArray = Array.isArray, trim = function(value) {
        return isString(value) ? value.trim() : value
    }, escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
    }, csp = function() {
        if (isDefined(csp.isActive_))
            return csp.isActive_;
        var active = !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"));
        if (!active)
            try {
                new Function("")
            } catch (e) {
                active = !0
            }
        return csp.isActive_ = active
    }, ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"], SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
        full: "1.3.20",
        major: 1,
        minor: 3,
        dot: 20,
        codeName: "shallow-translucence"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}
      , jqId = 1
      , addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, !1)
    }
      , removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, !1)
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {}
    }
    ;
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g
      , MOZ_HACK_REGEXP = /^moz([A-Z])/
      , MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }
      , jqLiteMinErr = minErr("jqLite")
      , SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/
      , HTML_REGEXP = /<|&#?\w+;/
      , TAG_NAME_REGEXP = /<([\w:]+)/
      , XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi
      , wrapMap = {
        option: [1, '<select multiple="multiple">', "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
    };
    wrapMap.optgroup = wrapMap.option,
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead,
    wrapMap.th = wrapMap.td;
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            function trigger() {
                fired || (fired = !0,
                fn())
            }
            var fired = !1;
            "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger),
            JQLite(window).on("load", trigger))
        },
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e)
            }),
            "[" + value.join(", ") + "]"
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index])
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }
      , BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = !0
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData
    }, function(fn, name) {
        JQLite[name] = fn
    }),
    forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"])
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate")
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector")
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name)
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            if (name = camelCase(name),
            !isDefined(value))
                return element.style[name];
            element.style[name] = value
        },
        attr: function(element, name, value) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_TEXT && 2 !== nodeType && nodeType !== NODE_TYPE_COMMENT) {
                var lowercasedName = lowercase(name);
                if (BOOLEAN_ATTR[lowercasedName]) {
                    if (!isDefined(value))
                        return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                    value ? (element[name] = !0,
                    element.setAttribute(name, lowercasedName)) : (element[name] = !1,
                    element.removeAttribute(lowercasedName))
                } else if (isDefined(value))
                    element.setAttribute(name, value);
                else if (element.getAttribute) {
                    var ret = element.getAttribute(name, 2);
                    return null === ret ? undefined : ret
                }
            }
        },
        prop: function(element, name, value) {
            if (!isDefined(value))
                return element[name];
            element[name] = value
        },
        text: function() {
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : ""
                }
                element.textContent = value
            }
            return getText.$dv = "",
            getText
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text)
                    }),
                    0 === result.length ? null : result
                }
                return element.value
            }
            element.value = value
        },
        html: function(element, value) {
            if (isUndefined(value))
                return element.innerHTML;
            jqLiteDealoc(element, !0),
            element.innerHTML = value
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && (2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++)
                        if (fn === jqLiteData)
                            fn(this[i], arg1);
                        else
                            for (key in arg1)
                                fn(this[i], key, arg1[key]);
                    return this
                }
                for (var value = fn.$dv, jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount, j = 0; j < jj; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue
                }
                return value
            }
            for (i = 0; i < nodeCount; i++)
                fn(this[i], arg1, arg2);
            return this
        }
    }),
    forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported))
                throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) {
                var expandoStore = jqLiteExpandoStore(element, !0)
                  , events = expandoStore.events
                  , handle = expandoStore.handle;
                handle || (handle = expandoStore.handle = createEventHandler(element, events));
                for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type], i = types.length; i--; ) {
                    type = types[i];
                    var eventFns = events[type];
                    eventFns || (events[type] = [],
                    "mouseenter" === type || "mouseleave" === type ? jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                        var target = this
                          , related = event.relatedTarget;
                        related && (related === target || target.contains(related)) || handle(event, type)
                    }) : "$destroy" !== type && addEventListenerFn(element, type, handle),
                    eventFns = events[type]),
                    eventFns.push(fn)
                }
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element),
            element.on(type, function onFn() {
                element.off(type, fn),
                element.off(type, onFn)
            }),
            element.on(type, fn)
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element),
            forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element),
                index = node
            })
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element)
            }),
            children
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || []
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                node = new JQLite(node);
                for (var i = 0, ii = node.length; i < ii; i++) {
                    var child = node[i];
                    element.appendChild(child)
                }
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index)
                })
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            parent && parent.replaceChild(wrapNode, element),
            wrapNode.appendChild(element)
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, !0)
        },
        after: function(element, newElement) {
            var index = element
              , parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; i < ii; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling),
                index = node
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)),
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className)
            })
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null
        },
        next: function(element) {
            return element.nextElementSibling
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : []
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
            eventFns && (dummyEvent = {
                preventDefault: function() {
                    this.defaultPrevented = !0
                },
                isDefaultPrevented: function() {
                    return !0 === this.defaultPrevented
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0
                },
                isImmediatePropagationStopped: function() {
                    return !0 === this.immediatePropagationStopped
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            },
            event.type && (dummyEvent = extend(dummyEvent, event)),
            eventFnsCopy = shallowCopy(eventFns),
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent],
            forEach(eventFnsCopy, function(fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs)
            }))
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; i < ii; i++)
                isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3),
                isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this
        }
        ,
        JQLite.prototype.bind = JQLite.prototype.on,
        JQLite.prototype.unbind = JQLite.prototype.off
    }),
    HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)]
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            return delete this[key],
            value
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m
      , FN_ARG_SPLIT = /,/
      , FN_ARG = /^\s*(_?)(\S+?)\1\s*$/
      , STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm
      , $injectorMinErr = minErr("$injector");
    createInjector.$$annotate = annotate;
    var $animateMinErr = minErr("$animate")
      , $AnimateProvider = ["$provide", function($provide) {
        this.$$selectors = {},
        this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && "." != name.charAt(0))
                throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key,
            $provide.factory(key, factory)
        }
        ,
        this.classNameFilter = function(expression) {
            return 1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null),
            this.$$classNameFilter
        }
        ,
        this.$get = ["$$q", "$$asyncCallback", "$rootScope", function($$q, $$asyncCallback, $rootScope) {
            function runAnimationPostDigest(fn) {
                var cancelFn, defer = $$q.defer();
                return defer.promise.$$cancelFn = function() {
                    cancelFn && cancelFn()
                }
                ,
                $rootScope.$$postDigest(function() {
                    cancelFn = fn(function() {
                        defer.resolve()
                    })
                }),
                defer.promise
            }
            function resolveElementClasses(element, classes) {
                var toAdd = []
                  , toRemove = []
                  , hasClasses = createMap();
                return forEach((element.attr("class") || "").split(/\s+/), function(className) {
                    hasClasses[className] = !0
                }),
                forEach(classes, function(status, className) {
                    var hasClass = hasClasses[className];
                    !1 === status && hasClass ? toRemove.push(className) : !0 !== status || hasClass || toAdd.push(className)
                }),
                toAdd.length + toRemove.length > 0 && [toAdd.length ? toAdd : null, toRemove.length ? toRemove : null]
            }
            function cachedClassManipulation(cache, classes, op) {
                for (var i = 0, ii = classes.length; i < ii; ++i) {
                    cache[classes[i]] = op
                }
            }
            function asyncPromise() {
                return currentDefer || (currentDefer = $$q.defer(),
                $$asyncCallback(function() {
                    currentDefer.resolve(),
                    currentDefer = null
                })),
                currentDefer.promise
            }
            function applyStyles(element, options) {
                if (angular.isObject(options)) {
                    var styles = extend(options.from || {}, options.to || {});
                    element.css(styles)
                }
            }
            var currentDefer;
            return {
                animate: function(element, from, to) {
                    return applyStyles(element, {
                        from: from,
                        to: to
                    }),
                    asyncPromise()
                },
                enter: function(element, parent, after, options) {
                    return applyStyles(element, options),
                    after ? after.after(element) : parent.prepend(element),
                    asyncPromise()
                },
                leave: function(element, options) {
                    return applyStyles(element, options),
                    element.remove(),
                    asyncPromise()
                },
                move: function(element, parent, after, options) {
                    return this.enter(element, parent, after, options)
                },
                addClass: function(element, className, options) {
                    return this.setClass(element, className, [], options)
                },
                $$addClassImmediately: function(element, className, options) {
                    return element = jqLite(element),
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "",
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className)
                    }),
                    applyStyles(element, options),
                    asyncPromise()
                },
                removeClass: function(element, className, options) {
                    return this.setClass(element, [], className, options)
                },
                $$removeClassImmediately: function(element, className, options) {
                    return element = jqLite(element),
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "",
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className)
                    }),
                    applyStyles(element, options),
                    asyncPromise()
                },
                setClass: function(element, add, remove, options) {
                    var self = this
                      , createdCache = !1;
                    element = jqLite(element);
                    var cache = element.data("$$animateClasses");
                    cache ? options && cache.options && (cache.options = angular.extend(cache.options || {}, options)) : (cache = {
                        classes: {},
                        options: options
                    },
                    createdCache = !0);
                    var classes = cache.classes;
                    return add = isArray(add) ? add : add.split(" "),
                    remove = isArray(remove) ? remove : remove.split(" "),
                    cachedClassManipulation(classes, add, !0),
                    cachedClassManipulation(classes, remove, !1),
                    createdCache && (cache.promise = runAnimationPostDigest(function(done) {
                        var cache = element.data("$$animateClasses");
                        if (element.removeData("$$animateClasses"),
                        cache) {
                            var classes = resolveElementClasses(element, cache.classes);
                            classes && self.$$setClassImmediately(element, classes[0], classes[1], cache.options)
                        }
                        done()
                    }),
                    element.data("$$animateClasses", cache)),
                    cache.promise
                },
                $$setClassImmediately: function(element, add, remove, options) {
                    return add && this.$$addClassImmediately(element, add),
                    remove && this.$$removeClassImmediately(element, remove),
                    applyStyles(element, options),
                    asyncPromise()
                },
                enabled: noop,
                cancel: noop
            }
        }
        ]
    }
    ]
      , $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i
      , $controllerMinErr = minErr("$controller")
      , APPLICATION_JSON = "application/json"
      , CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    }
      , JSON_START = /^\[|^\{(?!\{)/
      , JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    }
      , JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/
      , $interpolateMinErr = minErr("$interpolate")
      , PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/
      , DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }
      , $locationMinErr = minErr("$location")
      , locationPrototype = {
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url))
                return this.$$url;
            var match = PATH_MATCH.exec(url);
            return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])),
            (match[2] || match[1] || "" === url) && this.search(match[3] || ""),
            this.hash(match[5] || ""),
            this
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return path = null !== path ? path.toString() : "",
            "/" == path.charAt(0) ? path : "/" + path
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
            case 0:
                return this.$$search;
            case 1:
                if (isString(search) || isNumber(search))
                    search = search.toString(),
                    this.$$search = parseKeyValue(search);
                else {
                    if (!isObject(search))
                        throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    search = copy(search, {}),
                    forEach(search, function(value, key) {
                        null == value && delete search[key]
                    }),
                    this.$$search = search
                }
                break;
            default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue
            }
            return this.$$compose(),
            this
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return null !== hash ? hash.toString() : ""
        }),
        replace: function() {
            return this.$$replace = !0,
            this
        }
    };
    forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype),
        Location.prototype.state = function(state) {
            if (!arguments.length)
                return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5)
                throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = isUndefined(state) ? null : state,
            this
        }
    });
    var $parseMinErr = minErr("$parse")
      , CALL = Function.prototype.call
      , APPLY = Function.prototype.apply
      , BIND = Function.prototype.bind
      , CONSTANTS = createMap();
    forEach({
        null: function() {
            return null
        },
        true: function() {
            return !0
        },
        false: function() {
            return !1
        },
        undefined: function() {}
    }, function(constantGetter, name) {
        constantGetter.constant = constantGetter.literal = constantGetter.sharedGetter = !0,
        CONSTANTS[name] = constantGetter
    }),
    CONSTANTS.this = function(self) {
        return self
    }
    ,
    CONSTANTS.this.sharedGetter = !0;
    var OPERATORS = extend(createMap(), {
        "+": function(self, locals, a, b) {
            return a = a(self, locals),
            b = b(self, locals),
            isDefined(a) ? isDefined(b) ? a + b : a : isDefined(b) ? b : undefined
        },
        "-": function(self, locals, a, b) {
            return a = a(self, locals),
            b = b(self, locals),
            (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0)
        },
        "*": function(self, locals, a, b) {
            return a(self, locals) * b(self, locals)
        },
        "/": function(self, locals, a, b) {
            return a(self, locals) / b(self, locals)
        },
        "%": function(self, locals, a, b) {
            return a(self, locals) % b(self, locals)
        },
        "===": function(self, locals, a, b) {
            return a(self, locals) === b(self, locals)
        },
        "!==": function(self, locals, a, b) {
            return a(self, locals) !== b(self, locals)
        },
        "==": function(self, locals, a, b) {
            return a(self, locals) == b(self, locals)
        },
        "!=": function(self, locals, a, b) {
            return a(self, locals) != b(self, locals)
        },
        "<": function(self, locals, a, b) {
            return a(self, locals) < b(self, locals)
        },
        ">": function(self, locals, a, b) {
            return a(self, locals) > b(self, locals)
        },
        "<=": function(self, locals, a, b) {
            return a(self, locals) <= b(self, locals)
        },
        ">=": function(self, locals, a, b) {
            return a(self, locals) >= b(self, locals)
        },
        "&&": function(self, locals, a, b) {
            return a(self, locals) && b(self, locals)
        },
        "||": function(self, locals, a, b) {
            return a(self, locals) || b(self, locals)
        },
        "!": function(self, locals, a) {
            return !a(self, locals)
        },
        "=": !0,
        "|": !0
    })
      , ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "\t",
        v: "\v",
        "'": "'",
        '"': '"'
    }
      , Lexer = function(options) {
        this.options = options
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text,
            this.index = 0,
            this.tokens = []; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if ('"' === ch || "'" === ch)
                    this.readString(ch);
                else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek()))
                    this.readNumber();
                else if (this.isIdent(ch))
                    this.readIdent();
                else if (this.is(ch, "(){}[].,;:?"))
                    this.tokens.push({
                        index: this.index,
                        text: ch
                    }),
                    this.index++;
                else if (this.isWhitespace(ch))
                    this.index++;
                else {
                    var ch2 = ch + this.peek()
                      , ch3 = ch2 + this.peek(2)
                      , op1 = OPERATORS[ch]
                      , op2 = OPERATORS[ch2]
                      , op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: !0
                        }),
                        this.index += token.length
                    } else
                        this.throwError("Unexpected next character ", this.index, this.index + 1)
                }
            }
            return this.tokens
        },
        is: function(ch, chars) {
            return -1 !== chars.indexOf(ch)
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length && this.text.charAt(this.index + num)
        },
        isNumber: function(ch) {
            return "0" <= ch && ch <= "9" && "string" == typeof ch
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "\t" === ch || "\n" === ch || "\v" === ch || " " === ch
        },
        isIdent: function(ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || "$" === ch
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch)
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text)
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." == ch || this.isNumber(ch))
                    number += ch;
                else {
                    var peekCh = this.peek();
                    if ("e" == ch && this.isExpOperator(peekCh))
                        number += ch;
                    else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1))
                        number += ch;
                    else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1))
                            break;
                        this.throwError("Invalid exponent")
                    }
                }
                this.index++
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: !0,
                value: Number(number)
            })
        },
        readIdent: function() {
            for (var start = this.index; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (!this.isIdent(ch) && !this.isNumber(ch))
                    break;
                this.index++
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: !0
            })
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch,
                escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"),
                        this.index += 4,
                        string += String.fromCharCode(parseInt(hex, 16))
                    } else {
                        string += ESCAPE[ch] || ch
                    }
                    escape = !1
                } else if ("\\" === ch)
                    escape = !0;
                else {
                    if (ch === quote)
                        return this.index++,
                        void this.tokens.push({
                            index: start,
                            text: rawString,
                            constant: !0,
                            value: string
                        });
                    string += ch
                }
                this.index++
            }
            this.throwError("Unterminated quote", start)
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer,
        this.$filter = $filter,
        this.options = options
    };
    Parser.ZERO = extend(function() {
        return 0
    }, {
        sharedGetter: !0,
        constant: !0
    }),
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            this.text = text,
            this.tokens = this.lexer.lex(text);
            var value = this.statements();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]),
            value.literal = !!value.literal,
            value.constant = !!value.constant,
            value
        },
        primary: function() {
            var primary;
            this.expect("(") ? (primary = this.filterChain(),
            this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.peek().identifier && this.peek().text in CONSTANTS ? primary = CONSTANTS[this.consume().text] : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var next, context; next = this.expect("(", "[", "."); )
                "(" === next.text ? (primary = this.functionCall(primary, context),
                context = null) : "[" === next.text ? (context = primary,
                primary = this.objectIndex(primary)) : "." === next.text ? (context = primary,
                primary = this.fieldAccess(primary)) : this.throwError("IMPOSSIBLE");
            return primary
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index))
        },
        peekToken: function() {
            if (0 === this.tokens.length)
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0]
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4)
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i]
                  , t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4)
                    return token
            }
            return !1
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return !!token && (this.tokens.shift(),
            token)
        },
        consume: function(e1) {
            if (0 === this.tokens.length)
                throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()),
            token
        },
        unaryFn: function(op, right) {
            var fn = OPERATORS[op];
            return extend(function(self, locals) {
                return fn(self, locals, right)
            }, {
                constant: right.constant,
                inputs: [right]
            })
        },
        binaryFn: function(left, op, right, isBranching) {
            var fn = OPERATORS[op];
            return extend(function(self, locals) {
                return fn(self, locals, left, right)
            }, {
                constant: left.constant && right.constant,
                inputs: !isBranching && [left, right]
            })
        },
        identifier: function() {
            for (var id = this.consume().text; this.peek(".") && this.peekAhead(1).identifier && !this.peekAhead(2, "("); )
                id += this.consume().text + this.consume().text;
            return getterFn(id, this.options, this.text)
        },
        constant: function() {
            var value = this.consume().value;
            return extend(function() {
                return value
            }, {
                constant: !0,
                literal: !0
            })
        },
        statements: function() {
            for (var statements = []; ; )
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && statements.push(this.filterChain()),
                !this.expect(";"))
                    return 1 === statements.length ? statements[0] : function(self, locals) {
                        for (var value, i = 0, ii = statements.length; i < ii; i++)
                            value = statements[i](self, locals);
                        return value
                    }
        },
        filterChain: function() {
            for (var left = this.expression(); this.expect("|"); )
                left = this.filter(left);
            return left
        },
        filter: function(inputFn) {
            var argsFn, args, fn = this.$filter(this.consume().text);
            if (this.peek(":"))
                for (argsFn = [],
                args = []; this.expect(":"); )
                    argsFn.push(this.expression());
            var inputs = [inputFn].concat(argsFn || []);
            return extend(function(self, locals) {
                var input = inputFn(self, locals);
                if (args) {
                    args[0] = input;
                    for (var i = argsFn.length; i--; )
                        args[i + 1] = argsFn[i](self, locals);
                    return fn.apply(undefined, args)
                }
                return fn(input)
            }, {
                constant: !fn.$stateful && inputs.every(isConstant),
                inputs: !fn.$stateful && inputs
            })
        },
        expression: function() {
            return this.assignment()
        },
        assignment: function() {
            var right, token, left = this.ternary();
            return (token = this.expect("=")) ? (left.assign || this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token),
            right = this.ternary(),
            extend(function(scope, locals) {
                return left.assign(scope, right(scope, locals), locals)
            }, {
                inputs: [left, right]
            })) : left
        },
        ternary: function() {
            var middle, left = this.logicalOR();
            if (this.expect("?") && (middle = this.assignment(),
            this.consume(":"))) {
                var right = this.assignment();
                return extend(function(self, locals) {
                    return left(self, locals) ? middle(self, locals) : right(self, locals)
                }, {
                    constant: left.constant && middle.constant && right.constant
                })
            }
            return left
        },
        logicalOR: function() {
            for (var token, left = this.logicalAND(); token = this.expect("||"); )
                left = this.binaryFn(left, token.text, this.logicalAND(), !0);
            return left
        },
        logicalAND: function() {
            for (var token, left = this.equality(); token = this.expect("&&"); )
                left = this.binaryFn(left, token.text, this.equality(), !0);
            return left
        },
        equality: function() {
            for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); )
                left = this.binaryFn(left, token.text, this.relational());
            return left
        },
        relational: function() {
            for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); )
                left = this.binaryFn(left, token.text, this.additive());
            return left
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); )
                left = this.binaryFn(left, token.text, this.multiplicative());
            return left
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); )
                left = this.binaryFn(left, token.text, this.unary());
            return left
        },
        unary: function() {
            var token;
            return this.expect("+") ? this.primary() : (token = this.expect("-")) ? this.binaryFn(Parser.ZERO, token.text, this.unary()) : (token = this.expect("!")) ? this.unaryFn(token.text, this.unary()) : this.primary()
        },
        fieldAccess: function(object) {
            var getter = this.identifier();
            return extend(function(scope, locals, self) {
                var o = self || object(scope, locals);
                return null == o ? undefined : getter(o)
            }, {
                assign: function(scope, value, locals) {
                    var o = object(scope, locals);
                    return o || object.assign(scope, o = {}, locals),
                    getter.assign(o, value)
                }
            })
        },
        objectIndex: function(obj) {
            var expression = this.text
              , indexFn = this.expression();
            return this.consume("]"),
            extend(function(self, locals) {
                var o = obj(self, locals)
                  , i = getStringValue(indexFn(self, locals), expression);
                return ensureSafeMemberName(i, expression),
                o ? ensureSafeObject(o[i], expression) : undefined
            }, {
                assign: function(self, value, locals) {
                    var key = ensureSafeMemberName(getStringValue(indexFn(self, locals), expression), expression)
                      , o = ensureSafeObject(obj(self, locals), expression);
                    return o || obj.assign(self, o = {}, locals),
                    o[key] = value
                }
            })
        },
        functionCall: function(fnGetter, contextGetter) {
            var argsFn = [];
            if (")" !== this.peekToken().text)
                do {
                    argsFn.push(this.expression())
                } while (this.expect(","));
            this.consume(")");
            var expressionText = this.text
              , args = argsFn.length ? [] : null;
            return function(scope, locals) {
                var context = contextGetter ? contextGetter(scope, locals) : isDefined(contextGetter) ? undefined : scope
                  , fn = fnGetter(scope, locals, context) || noop;
                if (args)
                    for (var i = argsFn.length; i--; )
                        args[i] = ensureSafeObject(argsFn[i](scope, locals), expressionText);
                ensureSafeObject(context, expressionText),
                ensureSafeFunction(fn, expressionText);
                var v = fn.apply ? fn.apply(context, args) : fn(args[0], args[1], args[2], args[3], args[4]);
                return args && (args.length = 0),
                ensureSafeObject(v, expressionText)
            }
        },
        arrayDeclaration: function() {
            var elementFns = [];
            if ("]" !== this.peekToken().text)
                do {
                    if (this.peek("]"))
                        break;
                    elementFns.push(this.expression())
                } while (this.expect(","));
            return this.consume("]"),
            extend(function(self, locals) {
                for (var array = [], i = 0, ii = elementFns.length; i < ii; i++)
                    array.push(elementFns[i](self, locals));
                return array
            }, {
                literal: !0,
                constant: elementFns.every(isConstant),
                inputs: elementFns
            })
        },
        object: function() {
            var keys = []
              , valueFns = [];
            if ("}" !== this.peekToken().text)
                do {
                    if (this.peek("}"))
                        break;
                    var token = this.consume();
                    token.constant ? keys.push(token.value) : token.identifier ? keys.push(token.text) : this.throwError("invalid key", token),
                    this.consume(":"),
                    valueFns.push(this.expression())
                } while (this.expect(","));
            return this.consume("}"),
            extend(function(self, locals) {
                for (var object = {}, i = 0, ii = valueFns.length; i < ii; i++)
                    object[keys[i]] = valueFns[i](self, locals);
                return object
            }, {
                literal: !0,
                constant: valueFns.every(isConstant),
                inputs: valueFns
            })
        }
    };
    var getterFnCacheDefault = createMap()
      , getterFnCacheExpensive = createMap()
      , objectValueOf = Object.prototype.valueOf
      , $sceMinErr = minErr("$sce")
      , SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }
      , $compileMinErr = minErr("$compile")
      , urlParsingNode = document.createElement("a")
      , originUrl = urlResolve(window.location.href);
    $FilterProvider.$inject = ["$provide"],
    currencyFilter.$inject = ["$locale"],
    numberFilter.$inject = ["$locale"];
    var DECIMAL_SEP = "."
      , DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, !0),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    }
      , DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/
      , NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = ["$locale"];
    var lowercaseFilter = valueFn(lowercase)
      , uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = ["$parse"];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            if (!attr.href && !attr.xlinkHref && !attr.name)
                return function(scope, element) {
                    if ("a" === element[0].nodeName.toLowerCase()) {
                        var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                        element.on("click", function(event) {
                            element.attr(href) || event.preventDefault()
                        })
                    }
                }
        }
    })
      , ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if ("multiple" != propName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: function(scope, element, attr) {
                        scope.$watch(attr[normalized], function(value) {
                            attr.$set(attrName, !!value)
                        })
                    }
                }
            }
        }
    }),
    forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" == attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match)
                            return void attr.$set("ngPattern", new RegExp(match[1],match[2]))
                    }
                    scope.$watch(attr[ngAttr], function(value) {
                        attr.$set(ngAttr, value)
                    })
                }
            }
        }
    }),
    forEach(["src", "srcset", "href"], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName
                      , name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref",
                    attr.$attr[name] = "xlink:href",
                    propName = null),
                    attr.$observe(normalized, function(value) {
                        if (!value)
                            return void ("href" === attrName && attr.$set(name, null));
                        attr.$set(name, value),
                        msie && propName && element.prop(propName, attr[name])
                    })
                }
            }
        }
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }
      , SUBMITTED_CLASS = "ng-submitted";
    FormController.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"];
    var formDirectiveFactory = function(isNgForm) {
        return ["$timeout", function($timeout) {
            return {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : !(!isNgForm || !attr.ngForm) && "ngForm";
                    return {
                        pre: function(scope, formElement, attr, controller) {
                            if (!("action"in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue(),
                                        controller.$setSubmitted()
                                    }),
                                    event.preventDefault()
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission),
                                formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission)
                                    }, 0, !1)
                                })
                            }
                            var parentFormCtrl = controller.$$parentForm;
                            nameAttr && (setter(scope, null, controller.$name, controller, controller.$name),
                            attr.$observe(nameAttr, function(newValue) {
                                controller.$name !== newValue && (setter(scope, null, controller.$name, undefined, controller.$name),
                                parentFormCtrl.$$renameControl(controller, newValue),
                                setter(scope, null, controller.$name, controller, controller.$name))
                            })),
                            formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller),
                                nameAttr && setter(scope, null, attr[nameAttr], undefined, controller.$name),
                                extend(controller, nullFormCtrl)
                            })
                        }
                    }
                }
            }
        }
        ]
    }
      , formDirective = formDirectiveFactory()
      , ngFormDirective = formDirectiveFactory(!0)
      , ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/
      , URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/
      , EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i
      , NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/
      , DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/
      , DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/
      , WEEK_REGEXP = /^(\d{4})-W(\d\d)$/
      , MONTH_REGEXP = /^(\d{4})-(\d\d)$/
      , TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/
      , inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ["yyyy", "MM", "dd", "HH", "mm", "ss", "sss"]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, ["yyyy", "MM"]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }
      , inputDirective = ["$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: ["?ngModel"],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse)
                }
            }
        }
    }
    ]
      , CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/
      , ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    attr.$set("value", scope.$eval(attr.ngValue))
                }
                : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        attr.$set("value", value)
                    })
                }
            }
        }
    }
      , ngBindDirective = ["$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement),
                function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind),
                    element = element[0],
                    scope.$watch(attr.ngBind, function(value) {
                        element.textContent = value === undefined ? "" : value
                    })
                }
            }
        }
    }
    ]
      , ngBindTemplateDirective = ["$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement),
                function(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions),
                    element = element[0],
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = value === undefined ? "" : value
                    })
                }
            }
        }
    }
    ]
      , ngBindHtmlDirective = ["$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml)
                  , ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(value) {
                    return (value || "").toString()
                });
                return $compile.$$addBindingClass(tElement),
                function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml),
                    scope.$watch(ngBindHtmlWatch, function() {
                        element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "")
                    })
                }
            }
        }
    }
    ]
      , ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange)
            })
        }
    })
      , ngClassDirective = classDirective("", !0)
      , ngClassOddDirective = classDirective("Odd", 0)
      , ngClassEvenDirective = classDirective("Even", 1)
      , ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined),
            element.removeClass("ng-cloak")
        }
    })
      , ngControllerDirective = [function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        }
    }
    ]
      , ngEventDirectives = {}
      , forceAsyncEvents = {
        blur: !0,
        focus: !0
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = ["$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, !0);
                    return function(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                })
                            };
                            forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback)
                        })
                    }
                }
            }
        }
        ]
    });
    var ngIfDirective = ["$animate", function($animate) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    value ? childScope || $transclude(function(clone, newScope) {
                        childScope = newScope,
                        clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "),
                        block = {
                            clone: clone
                        },
                        $animate.enter(clone, $element.parent(), $element)
                    }) : (previousElements && (previousElements.remove(),
                    previousElements = null),
                    childScope && (childScope.$destroy(),
                    childScope = null),
                    block && (previousElements = getBlockNodes(block.clone),
                    $animate.leave(previousElements).then(function() {
                        previousElements = null
                    }),
                    block = null))
                })
            }
        }
    }
    ]
      , ngIncludeDirective = ["$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src
                  , onloadExp = attr.onload || ""
                  , autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(),
                        previousElement = null),
                        currentScope && (currentScope.$destroy(),
                        currentScope = null),
                        currentElement && ($animate.leave(currentElement).then(function() {
                            previousElement = null
                        }),
                        previousElement = currentElement,
                        currentElement = null)
                    };
                    scope.$watch(srcExp, function(src) {
                        var afterAnimation = function() {
                            !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                        }
                          , thisChangeId = ++changeCounter;
                        src ? ($templateRequest(src, !0).then(function(response) {
                            if (thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(),
                                    $animate.enter(clone, null, $element).then(afterAnimation)
                                });
                                currentScope = newScope,
                                currentElement = clone,
                                currentScope.$emit("$includeContentLoaded", src),
                                scope.$eval(onloadExp)
                            }
                        }, function() {
                            thisChangeId === changeCounter && (cleanupLastIncludeContent(),
                            scope.$emit("$includeContentError", src))
                        }),
                        scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(),
                        ctrl.template = null)
                    })
                }
            }
        }
    }
    ]
      , ngIncludeFillContentDirective = ["$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                if (/SVG/.test($element[0].toString()))
                    return $element.empty(),
                    void $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function(clone) {
                        $element.append(clone)
                    }, {
                        futureParentElement: $element
                    });
                $element.html(ctrl.template),
                $compile($element.contents())(scope)
            }
        }
    }
    ]
      , ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit)
                }
            }
        }
    })
      , ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", "
                  , trimValues = "false" !== attr.ngTrim
                  , separator = trimValues ? trim(ngList) : ngList
                  , parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trimValues ? trim(value) : value)
                        }),
                        list
                    }
                };
                ctrl.$parsers.push(parse),
                ctrl.$formatters.push(function(value) {
                    return isArray(value) ? value.join(ngList) : undefined
                }),
                ctrl.$isEmpty = function(value) {
                    return !value || !value.length
                }
            }
        }
    }
      , VALID_CLASS = "ng-valid"
      , INVALID_CLASS = "ng-invalid"
      , PRISTINE_CLASS = "ng-pristine"
      , DIRTY_CLASS = "ng-dirty"
      , PENDING_CLASS = "ng-pending"
      , ngModelMinErr = minErr("ngModel")
      , NgModelController = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN,
        this.$modelValue = Number.NaN,
        this.$$rawModelValue = undefined,
        this.$validators = {},
        this.$asyncValidators = {},
        this.$parsers = [],
        this.$formatters = [],
        this.$viewChangeListeners = [],
        this.$untouched = !0,
        this.$touched = !1,
        this.$pristine = !0,
        this.$dirty = !1,
        this.$valid = !0,
        this.$invalid = !1,
        this.$error = {},
        this.$$success = {},
        this.$pending = undefined,
        this.$name = $interpolate($attr.name || "", !1)($scope);
        var parserValid, parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, ctrl = this;
        this.$$setOptions = function(options) {
            if (ctrl.$options = options,
            options && options.getterSetter) {
                var invokeModelGetter = $parse($attr.ngModel + "()")
                  , invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                ngModelGet = function($scope) {
                    var modelValue = parsedNgModel($scope);
                    return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)),
                    modelValue
                }
                ,
                ngModelSet = function($scope, newValue) {
                    isFunction(parsedNgModel($scope)) ? invokeModelSetter($scope, {
                        $$$p: ctrl.$modelValue
                    }) : parsedNgModelAssign($scope, ctrl.$modelValue)
                }
            } else if (!parsedNgModel.assign)
                throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element))
        }
        ,
        this.$render = noop,
        this.$isEmpty = function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value
        }
        ;
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl
          , currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = !0
            },
            unset: function(object, property) {
                delete object[property]
            },
            parentForm: parentForm,
            $animate: $animate
        }),
        this.$setPristine = function() {
            ctrl.$dirty = !1,
            ctrl.$pristine = !0,
            $animate.removeClass($element, DIRTY_CLASS),
            $animate.addClass($element, PRISTINE_CLASS)
        }
        ,
        this.$setDirty = function() {
            ctrl.$dirty = !0,
            ctrl.$pristine = !1,
            $animate.removeClass($element, PRISTINE_CLASS),
            $animate.addClass($element, DIRTY_CLASS),
            parentForm.$setDirty()
        }
        ,
        this.$setUntouched = function() {
            ctrl.$touched = !1,
            ctrl.$untouched = !0,
            $animate.setClass($element, "ng-untouched", "ng-touched")
        }
        ,
        this.$setTouched = function() {
            ctrl.$touched = !0,
            ctrl.$untouched = !1,
            $animate.setClass($element, "ng-touched", "ng-untouched")
        }
        ,
        this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce),
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue,
            ctrl.$render()
        }
        ,
        this.$validate = function() {
            if (!isNumber(ctrl.$modelValue) || !isNaN(ctrl.$modelValue)) {
                var viewValue = ctrl.$$lastCommittedViewValue
                  , modelValue = ctrl.$$rawModelValue
                  , prevValid = ctrl.$valid
                  , prevModelValue = ctrl.$modelValue
                  , allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
                    allowInvalid || prevValid === allValid || (ctrl.$modelValue = allValid ? modelValue : undefined,
                    ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope())
                })
            }
        }
        ,
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
            function setValidity(name, isValid) {
                localValidationRunId === currentValidationRunId && ctrl.$setValidity(name, isValid)
            }
            function validationDone(allValid) {
                localValidationRunId === currentValidationRunId && doneCallback(allValid)
            }
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            return function() {
                var errorKey = ctrl.$$parserName || "parse";
                return parserValid !== undefined ? (parserValid || (forEach(ctrl.$validators, function(v, name) {
                    setValidity(name, null)
                }),
                forEach(ctrl.$asyncValidators, function(v, name) {
                    setValidity(name, null)
                })),
                setValidity(errorKey, parserValid),
                parserValid) : (setValidity(errorKey, null),
                !0)
            }() && function() {
                var syncValidatorsValid = !0;
                return forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result,
                    setValidity(name, result)
                }),
                !!syncValidatorsValid || (forEach(ctrl.$asyncValidators, function(v, name) {
                    setValidity(name, null)
                }),
                !1)
            }() ? void function() {
                var validatorPromises = []
                  , allValid = !0;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise))
                        throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    setValidity(name, undefined),
                    validatorPromises.push(promise.then(function() {
                        setValidity(name, !0)
                    }, function(error) {
                        allValid = !1,
                        setValidity(name, !1)
                    }))
                }),
                validatorPromises.length ? $q.all(validatorPromises).then(function() {
                    validationDone(allValid)
                }, noop) : validationDone(!0)
            }() : void validationDone(!1)
        }
        ,
        this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce),
            (ctrl.$$lastCommittedViewValue !== viewValue || "" === viewValue && ctrl.$$hasNativeValidators) && (ctrl.$$lastCommittedViewValue = viewValue,
            ctrl.$pristine && this.$setDirty(),
            this.$$parseAndValidate())
        }
        ,
        this.$$parseAndValidate = function() {
            function writeToModelIfNeeded() {
                ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope()
            }
            var viewValue = ctrl.$$lastCommittedViewValue
              , modelValue = viewValue;
            if (parserValid = !isUndefined(modelValue) || undefined)
                for (var i = 0; i < ctrl.$parsers.length; i++)
                    if (modelValue = ctrl.$parsers[i](modelValue),
                    isUndefined(modelValue)) {
                        parserValid = !1;
                        break
                    }
            isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue) && (ctrl.$modelValue = ngModelGet($scope));
            var prevModelValue = ctrl.$modelValue
              , allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$rawModelValue = modelValue,
            allowInvalid && (ctrl.$modelValue = modelValue,
            writeToModelIfNeeded()),
            ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
                allowInvalid || (ctrl.$modelValue = allValid ? modelValue : undefined,
                writeToModelIfNeeded())
            })
        }
        ,
        this.$$writeModelToScope = function() {
            ngModelSet($scope, ctrl.$modelValue),
            forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener()
                } catch (e) {
                    $exceptionHandler(e)
                }
            })
        }
        ,
        this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value,
            ctrl.$options && !ctrl.$options.updateOnDefault || ctrl.$$debounceViewValueCommit(trigger)
        }
        ,
        this.$$debounceViewValueCommit = function(trigger) {
            var debounce, debounceDelay = 0, options = ctrl.$options;
            options && isDefined(options.debounce) && (debounce = options.debounce,
            isNumber(debounce) ? debounceDelay = debounce : isNumber(debounce[trigger]) ? debounceDelay = debounce[trigger] : isNumber(debounce.default) && (debounceDelay = debounce.default)),
            $timeout.cancel(pendingDebounce),
            debounceDelay ? pendingDebounce = $timeout(function() {
                ctrl.$commitViewValue()
            }, debounceDelay) : $rootScope.$$phase ? ctrl.$commitViewValue() : $scope.$apply(function() {
                ctrl.$commitViewValue()
            })
        }
        ,
        $scope.$watch(function() {
            var modelValue = ngModelGet($scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue,
                parserValid = undefined;
                for (var formatters = ctrl.$formatters, idx = formatters.length, viewValue = modelValue; idx--; )
                    viewValue = formatters[idx](viewValue);
                ctrl.$viewValue !== viewValue && (ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue,
                ctrl.$render(),
                ctrl.$$runValidators(modelValue, viewValue, noop))
            }
            return modelValue
        })
    }
    ]
      , ngModelDirective = ["$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: ["ngModel", "^?form", "^?ngModelOptions"],
            controller: NgModelController,
            priority: 1,
            compile: function(element) {
                return element.addClass(PRISTINE_CLASS).addClass("ng-untouched").addClass(VALID_CLASS),
                {
                    pre: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0]
                          , formCtrl = ctrls[1] || nullFormCtrl;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options),
                        formCtrl.$addControl(modelCtrl),
                        attr.$observe("name", function(newValue) {
                            modelCtrl.$name !== newValue && formCtrl.$$renameControl(modelCtrl, newValue)
                        }),
                        scope.$on("$destroy", function() {
                            formCtrl.$removeControl(modelCtrl)
                        })
                    },
                    post: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        modelCtrl.$options && modelCtrl.$options.updateOn && element.on(modelCtrl.$options.updateOn, function(ev) {
                            modelCtrl.$$debounceViewValueCommit(ev && ev.type)
                        }),
                        element.on("blur", function(ev) {
                            modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(modelCtrl.$setTouched) : scope.$apply(modelCtrl.$setTouched))
                        })
                    }
                }
            }
        }
    }
    ]
      , DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/
      , ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: ["$scope", "$attrs", function($scope, $attrs) {
                var that = this;
                this.$options = $scope.$eval($attrs.ngModelOptions),
                this.$options.updateOn !== undefined ? (this.$options.updateOnDefault = !1,
                this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                    return that.$options.updateOnDefault = !0,
                    " "
                }))) : this.$options.updateOnDefault = !0
            }
            ]
        }
    }
      , ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    })
      , ngPluralizeDirective = ["$locale", "$interpolate", function($locale, $interpolate) {
        var BRACE = /{}/g
          , IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                function updateElementText(newText) {
                    element.text(newText || "")
                }
                var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName])
                    }
                }),
                forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement))
                }),
                scope.$watch(numberExp, function(newVal) {
                    var count = parseFloat(newVal)
                      , countIsNaN = isNaN(count);
                    countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)),
                    count === lastCount || countIsNaN && isNaN(lastCount) || (watchRemover(),
                    watchRemover = scope.$watch(whensExpFns[count], updateElementText),
                    lastCount = count)
                })
            }
        }
    }
    ]
      , ngRepeatDirective = ["$parse", "$animate", function($parse, $animate) {
        var ngRepeatMinErr = minErr("ngRepeat")
          , updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value,
            keyIdentifier && (scope[keyIdentifier] = key),
            scope.$index = index,
            scope.$first = 0 === index,
            scope.$last = index === arrayLength - 1,
            scope.$middle = !(scope.$first || scope.$last),
            scope.$odd = !(scope.$even = 0 == (1 & index))
        }
          , getBlockStart = function(block) {
            return block.clone[0]
        }
          , getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1]
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function($element, $attr) {
                var expression = $attr.ngRepeat
                  , ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " ")
                  , match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match)
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                var lhs = match[1]
                  , rhs = match[2]
                  , aliasAs = match[3]
                  , trackByExp = match[4];
                if (!(match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/)))
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                var valueIdentifier = match[3] || match[1]
                  , keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs)))
                    throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {
                    $id: hashKey
                };
                return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value)
                }
                ,
                trackByIdObjFn = function(key) {
                    return key
                }
                ),
                function($scope, $element, $attr, ctrl, $transclude) {
                    trackByExpGetter && (trackByIdExpFn = function(key, value, index) {
                        return keyIdentifier && (hashFnLocals[keyIdentifier] = key),
                        hashFnLocals[valueIdentifier] = value,
                        hashFnLocals.$index = index,
                        trackByExpGetter($scope, hashFnLocals)
                    }
                    );
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function(collection) {
                        var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                        if (aliasAs && ($scope[aliasAs] = collection),
                        isArrayLike(collection))
                            collectionKeys = collection,
                            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                        else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn,
                            collectionKeys = [];
                            for (var itemKey in collection)
                                collection.hasOwnProperty(itemKey) && "$" != itemKey.charAt(0) && collectionKeys.push(itemKey);
                            collectionKeys.sort()
                        }
                        for (collectionLength = collectionKeys.length,
                        nextBlockOrder = new Array(collectionLength),
                        index = 0; index < collectionLength; index++)
                            if (key = collection === collectionKeys ? index : collectionKeys[index],
                            value = collection[key],
                            trackById = trackByIdFn(key, value, index),
                            lastBlockMap[trackById])
                                block = lastBlockMap[trackById],
                                delete lastBlockMap[trackById],
                                nextBlockMap[trackById] = block,
                                nextBlockOrder[index] = block;
                            else {
                                if (nextBlockMap[trackById])
                                    throw forEach(nextBlockOrder, function(block) {
                                        block && block.scope && (lastBlockMap[block.id] = block)
                                    }),
                                    ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: undefined,
                                    clone: undefined
                                },
                                nextBlockMap[trackById] = !0
                            }
                        for (var blockKey in lastBlockMap) {
                            if (block = lastBlockMap[blockKey],
                            elementsToRemove = getBlockNodes(block.clone),
                            $animate.leave(elementsToRemove),
                            elementsToRemove[0].parentNode)
                                for (index = 0,
                                length = elementsToRemove.length; index < length; index++)
                                    elementsToRemove[index].$$NG_REMOVED = !0;
                            block.scope.$destroy()
                        }
                        for (index = 0; index < collectionLength; index++)
                            if (key = collection === collectionKeys ? index : collectionKeys[index],
                            value = collection[key],
                            block = nextBlockOrder[index],
                            block.scope) {
                                nextNode = previousNode;
                                do {
                                    nextNode = nextNode.nextSibling
                                } while (nextNode && nextNode.$$NG_REMOVED);
                                getBlockStart(block) != nextNode && $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode)),
                                previousNode = getBlockEnd(block),
                                updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                            } else
                                $transclude(function(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(!1);
                                    clone[clone.length++] = endNode,
                                    $animate.enter(clone, null, jqLite(previousNode)),
                                    previousNode = endNode,
                                    block.clone = clone,
                                    nextBlockMap[block.id] = block,
                                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                                });
                        lastBlockMap = nextBlockMap
                    })
                }
            }
        }
    }
    ]
      , ngShowDirective = ["$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function(value) {
                    $animate[value ? "removeClass" : "addClass"](element, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    })
                })
            }
        }
    }
    ]
      , ngHideDirective = ["$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function(value) {
                    $animate[value ? "addClass" : "removeClass"](element, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    })
                })
            }
        }
    }
    ]
      , ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "")
            }),
            newStyles && element.css(newStyles)
        }, !0)
    })
      , ngSwitchDirective = ["$animate", function($animate) {
        return {
            restrict: "EA",
            require: "ngSwitch",
            controller: ["$scope", function() {
                this.cases = {}
            }
            ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on
                  , selectedTranscludes = []
                  , selectedElements = []
                  , previousLeaveAnimations = []
                  , selectedScopes = []
                  , spliceFactory = function(array, index) {
                    return function() {
                        array.splice(index, 1)
                    }
                };
                scope.$watch(watchExpr, function(value) {
                    var i, ii;
                    for (i = 0,
                    ii = previousLeaveAnimations.length; i < ii; ++i)
                        $animate.cancel(previousLeaveAnimations[i]);
                    for (previousLeaveAnimations.length = 0,
                    i = 0,
                    ii = selectedScopes.length; i < ii; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        (previousLeaveAnimations[i] = $animate.leave(selected)).then(spliceFactory(previousLeaveAnimations, i))
                    }
                    selectedElements.length = 0,
                    selectedScopes.length = 0,
                    (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                        selectedTransclude.transclude(function(caseElement, selectedScope) {
                            selectedScopes.push(selectedScope);
                            var anchor = selectedTransclude.element;
                            caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                            var block = {
                                clone: caseElement
                            };
                            selectedElements.push(block),
                            $animate.enter(caseElement, anchor.parent(), anchor)
                        })
                    })
                })
            }
        }
    }
    ]
      , ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [],
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            })
        }
    })
      , ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [],
            ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            })
        }
    })
      , ngTranscludeDirective = ngDirective({
        restrict: "EAC",
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude)
                throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
            $transclude(function(clone) {
                $element.empty(),
                $element.append(clone)
            })
        }
    })
      , scriptDirective = ["$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" == attr.type) {
                    var templateUrl = attr.id
                      , text = element[0].text;
                    $templateCache.put(templateUrl, text)
                }
            }
        }
    }
    ]
      , ngOptionsMinErr = minErr("ngOptions")
      , ngOptionsDirective = valueFn({
        restrict: "A",
        terminal: !0
    })
      , selectDirective = ["$compile", "$parse", function($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/
          , nullModelCtrl = {
            $setViewValue: noop
        };
        return {
            restrict: "E",
            require: ["select", "?ngModel"],
            controller: ["$element", "$scope", "$attrs", function($element, $scope, $attrs) {
                var nullOption, unknownOption, self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl;
                self.databound = $attrs.ngModel,
                self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_,
                    nullOption = nullOption_,
                    unknownOption = unknownOption_
                }
                ,
                self.addOption = function(value, element) {
                    assertNotHasOwnProperty(value, '"option value"'),
                    optionsMap[value] = !0,
                    ngModelCtrl.$viewValue == value && ($element.val(value),
                    unknownOption.parent() && unknownOption.remove()),
                    element && element[0].hasAttribute("selected") && (element[0].selected = !0)
                }
                ,
                self.removeOption = function(value) {
                    this.hasOption(value) && (delete optionsMap[value],
                    ngModelCtrl.$viewValue === value && this.renderUnknownOption(value))
                }
                ,
                self.renderUnknownOption = function(val) {
                    var unknownVal = "? " + hashKey(val) + " ?";
                    unknownOption.val(unknownVal),
                    $element.prepend(unknownOption),
                    $element.val(unknownVal),
                    unknownOption.prop("selected", !0)
                }
                ,
                self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value)
                }
                ,
                $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop
                })
            }
            ],
            link: function(scope, element, attr, ctrls) {
                if (ctrls[1]) {
                    for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = !1, renderScheduled = !1, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone(), i = 0, children = element.children(), ii = children.length; i < ii; i++)
                        if ("" === children[i].value) {
                            emptyOption = nullOption = children.eq(i);
                            break
                        }
                    selectCtrl.init(ngModelCtrl, nullOption, unknownOption),
                    multiple && (ngModelCtrl.$isEmpty = function(value) {
                        return !value || 0 === value.length
                    }
                    ),
                    optionsExp ? function(scope, selectElement, ctrl) {
                        function callExpression(exprFn, key, value) {
                            return locals[valueName] = value,
                            keyName && (locals[keyName] = key),
                            exprFn(scope, locals)
                        }
                        function selectionChanged() {
                            scope.$apply(function() {
                                var viewValue, collection = valuesFn(scope) || [];
                                if (multiple)
                                    viewValue = [],
                                    forEach(selectElement.val(), function(selectedKey) {
                                        selectedKey = trackFn ? trackKeysCache[selectedKey] : selectedKey,
                                        viewValue.push(getViewValue(selectedKey, collection[selectedKey]))
                                    });
                                else {
                                    var selectedKey = trackFn ? trackKeysCache[selectElement.val()] : selectElement.val();
                                    viewValue = getViewValue(selectedKey, collection[selectedKey])
                                }
                                ctrl.$setViewValue(viewValue),
                                render()
                            })
                        }
                        function getViewValue(key, value) {
                            return "?" === key ? undefined : "" === key ? null : callExpression(selectAsFn || valueFn, key, value)
                        }
                        function getLabels() {
                            var toDisplay, values = valuesFn(scope);
                            if (values && isArray(values)) {
                                toDisplay = new Array(values.length);
                                for (var i = 0, ii = values.length; i < ii; i++)
                                    toDisplay[i] = callExpression(displayFn, i, values[i]);
                                return toDisplay
                            }
                            if (values) {
                                toDisplay = {};
                                for (var prop in values)
                                    values.hasOwnProperty(prop) && (toDisplay[prop] = callExpression(displayFn, prop, values[prop]))
                            }
                            return toDisplay
                        }
                        function createIsSelectedFn(viewValue) {
                            var selectedSet;
                            if (multiple)
                                if (trackFn && isArray(viewValue)) {
                                    selectedSet = new HashMap([]);
                                    for (var trackIndex = 0; trackIndex < viewValue.length; trackIndex++)
                                        selectedSet.put(callExpression(trackFn, null, viewValue[trackIndex]), !0)
                                } else
                                    selectedSet = new HashMap(viewValue);
                            else
                                trackFn && (viewValue = callExpression(trackFn, null, viewValue));
                            return function(key, value) {
                                var compareValueFn;
                                return compareValueFn = trackFn || selectAsFn || valueFn,
                                multiple ? isDefined(selectedSet.remove(callExpression(compareValueFn, key, value))) : viewValue === callExpression(compareValueFn, key, value)
                            }
                        }
                        function scheduleRendering() {
                            renderScheduled || (scope.$$postDigest(render),
                            renderScheduled = !0)
                        }
                        function updateLabelMap(labelMap, label, added) {
                            labelMap[label] = labelMap[label] || 0,
                            labelMap[label] += added ? 1 : -1
                        }
                        function render() {
                            renderScheduled = !1;
                            var optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, key, value, groupLength, length, groupIndex, index, selected, lastElement, element, label, optionId, optionGroups = {
                                "": []
                            }, optionGroupNames = [""], viewValue = ctrl.$viewValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, labelMap = {}, isSelected = createIsSelectedFn(viewValue), anySelected = !1;
                            for (trackKeysCache = {},
                            index = 0; length = keys.length,
                            index < length; index++)
                                key = index,
                                keyName && (key = keys[index],
                                "$" === key.charAt(0)) || (value = values[key],
                                optionGroupName = callExpression(groupByFn, key, value) || "",
                                (optionGroup = optionGroups[optionGroupName]) || (optionGroup = optionGroups[optionGroupName] = [],
                                optionGroupNames.push(optionGroupName)),
                                selected = isSelected(key, value),
                                anySelected = anySelected || selected,
                                label = callExpression(displayFn, key, value),
                                label = isDefined(label) ? label : "",
                                optionId = trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index,
                                trackFn && (trackKeysCache[optionId] = key),
                                optionGroup.push({
                                    id: optionId,
                                    label: label,
                                    selected: selected
                                }));
                            for (multiple || (nullOption || null === viewValue ? optionGroups[""].unshift({
                                id: "",
                                label: "",
                                selected: !anySelected
                            }) : anySelected || optionGroups[""].unshift({
                                id: "?",
                                label: "",
                                selected: !0
                            })),
                            groupIndex = 0,
                            groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                                for (optionGroupName = optionGroupNames[groupIndex],
                                optionGroup = optionGroups[optionGroupName],
                                optionGroupsCache.length <= groupIndex ? (existingParent = {
                                    element: optGroupTemplate.clone().attr("label", optionGroupName),
                                    label: optionGroup.label
                                },
                                existingOptions = [existingParent],
                                optionGroupsCache.push(existingOptions),
                                selectElement.append(existingParent.element)) : (existingOptions = optionGroupsCache[groupIndex],
                                existingParent = existingOptions[0],
                                existingParent.label != optionGroupName && existingParent.element.attr("label", existingParent.label = optionGroupName)),
                                lastElement = null,
                                index = 0,
                                length = optionGroup.length; index < length; index++)
                                    option = optionGroup[index],
                                    (existingOption = existingOptions[index + 1]) ? (lastElement = existingOption.element,
                                    existingOption.label !== option.label && (updateLabelMap(labelMap, existingOption.label, !1),
                                    updateLabelMap(labelMap, option.label, !0),
                                    lastElement.text(existingOption.label = option.label),
                                    lastElement.prop("label", existingOption.label)),
                                    existingOption.id !== option.id && lastElement.val(existingOption.id = option.id),
                                    lastElement[0].selected !== option.selected && (lastElement.prop("selected", existingOption.selected = option.selected),
                                    msie && lastElement.prop("selected", existingOption.selected))) : ("" === option.id && nullOption ? element = nullOption : (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).prop("label", option.label).text(option.label),
                                    existingOptions.push(existingOption = {
                                        element: element,
                                        label: option.label,
                                        id: option.id,
                                        selected: option.selected
                                    }),
                                    updateLabelMap(labelMap, option.label, !0),
                                    lastElement ? lastElement.after(element) : existingParent.element.append(element),
                                    lastElement = element);
                                for (index++; existingOptions.length > index; )
                                    option = existingOptions.pop(),
                                    updateLabelMap(labelMap, option.label, !1),
                                    option.element.remove()
                            }
                            for (; optionGroupsCache.length > groupIndex; ) {
                                for (optionGroup = optionGroupsCache.pop(),
                                index = 1; index < optionGroup.length; ++index)
                                    updateLabelMap(labelMap, optionGroup[index].label, !1);
                                optionGroup[0].element.remove()
                            }
                            forEach(labelMap, function(count, label) {
                                count > 0 ? selectCtrl.addOption(label) : count < 0 && selectCtrl.removeOption(label)
                            })
                        }
                        var match;
                        if (!(match = optionsExp.match(NG_OPTIONS_REGEXP)))
                            throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                        var displayFn = $parse(match[2] || match[1])
                          , valueName = match[4] || match[6]
                          , selectAs = / as /.test(match[0]) && match[1]
                          , selectAsFn = selectAs ? $parse(selectAs) : null
                          , keyName = match[5]
                          , groupByFn = $parse(match[3] || "")
                          , valueFn = $parse(match[2] ? match[1] : valueName)
                          , valuesFn = $parse(match[7])
                          , track = match[8]
                          , trackFn = track ? $parse(match[8]) : null
                          , trackKeysCache = {}
                          , optionGroupsCache = [[{
                            element: selectElement,
                            label: ""
                        }]]
                          , locals = {};
                        nullOption && ($compile(nullOption)(scope),
                        nullOption.removeClass("ng-scope"),
                        nullOption.remove()),
                        selectElement.empty(),
                        selectElement.on("change", selectionChanged),
                        ctrl.$render = render,
                        scope.$watchCollection(valuesFn, scheduleRendering),
                        scope.$watchCollection(getLabels, scheduleRendering),
                        multiple && scope.$watchCollection(function() {
                            return ctrl.$modelValue
                        }, scheduleRendering)
                    }(scope, element, ngModelCtrl) : multiple ? function(scope, selectElement, ctrl) {
                        var lastView;
                        ctrl.$render = function() {
                            var items = new HashMap(ctrl.$viewValue);
                            forEach(selectElement.find("option"), function(option) {
                                option.selected = isDefined(items.get(option.value))
                            })
                        }
                        ,
                        scope.$watch(function() {
                            equals(lastView, ctrl.$viewValue) || (lastView = shallowCopy(ctrl.$viewValue),
                            ctrl.$render())
                        }),
                        selectElement.on("change", function() {
                            scope.$apply(function() {
                                var array = [];
                                forEach(selectElement.find("option"), function(option) {
                                    option.selected && array.push(option.value)
                                }),
                                ctrl.$setViewValue(array)
                            })
                        })
                    }(scope, element, ngModelCtrl) : function(scope, selectElement, ngModelCtrl, selectCtrl) {
                        ngModelCtrl.$render = function() {
                            var viewValue = ngModelCtrl.$viewValue;
                            selectCtrl.hasOption(viewValue) ? (unknownOption.parent() && unknownOption.remove(),
                            selectElement.val(viewValue),
                            "" === viewValue && emptyOption.prop("selected", !0)) : null == viewValue && emptyOption ? selectElement.val("") : selectCtrl.renderUnknownOption(viewValue)
                        }
                        ,
                        selectElement.on("change", function() {
                            scope.$apply(function() {
                                unknownOption.parent() && unknownOption.remove(),
                                ngModelCtrl.$setViewValue(selectElement.val())
                            })
                        })
                    }(scope, element, ngModelCtrl, selectCtrl)
                }
            }
        }
    }
    ]
      , optionDirective = ["$interpolate", function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), !0);
                    interpolateFn || attr.$set("value", element.text())
                }
                return function(scope, element, attr) {
                    var parent = element.parent()
                      , selectCtrl = parent.data("$selectController") || parent.parent().data("$selectController");
                    selectCtrl && selectCtrl.databound || (selectCtrl = nullSelectCtrl),
                    interpolateFn ? scope.$watch(interpolateFn, function(newVal, oldVal) {
                        attr.$set("value", newVal),
                        oldVal !== newVal && selectCtrl.removeOption(oldVal),
                        selectCtrl.addOption(newVal, element)
                    }) : selectCtrl.addOption(attr.value, element),
                    element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value)
                    })
                }
            }
        }
    }
    ]
      , styleDirective = valueFn({
        restrict: "E",
        terminal: !1
    })
      , requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                ctrl && (attr.required = !0,
                ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue)
                }
                ,
                attr.$observe("required", function() {
                    ctrl.$validate()
                }))
            }
        }
    }
      , patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function(regex) {
                        if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")),
                        regex && !regex.test)
                            throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        regexp = regex || undefined,
                        ctrl.$validate()
                    }),
                    ctrl.$validators.pattern = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue)
                    }
                }
            }
        }
    }
      , maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var maxlength = -1;
                    attr.$observe("maxlength", function(value) {
                        var intVal = int(value);
                        maxlength = isNaN(intVal) ? -1 : intVal,
                        ctrl.$validate()
                    }),
                    ctrl.$validators.maxlength = function(modelValue, viewValue) {
                        return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength
                    }
                }
            }
        }
    }
      , minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var minlength = 0;
                    attr.$observe("minlength", function(value) {
                        minlength = int(value) || 0,
                        ctrl.$validate()
                    }),
                    ctrl.$validators.minlength = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength
                    }
                }
            }
        }
    };
    if (window.angular.bootstrap)
        return void console.log("WARNING: Tried to load angular more than once.");
    !function() {
        var originalCleanData;
        bindJQueryFired || (jQuery = window.jQuery,
        jQuery && jQuery.fn.on ? (jqLite = jQuery,
        extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
        }),
        originalCleanData = jQuery.cleanData,
        jQuery.cleanData = function(elems) {
            var events;
            if (skipDestroyOnNextJQueryCleanData)
                skipDestroyOnNextJQueryCleanData = !1;
            else
                for (var elem, i = 0; null != (elem = elems[i]); i++)
                    (events = jQuery._data(elem, "events")) && events.$destroy && jQuery(elem).triggerHandler("$destroy");
            originalCleanData(elems)
        }
        ) : jqLite = JQLite,
        angular.element = jqLite,
        bindJQueryFired = !0)
    }(),
    function(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        }),
        angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale")
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider)
        }
        angularModule("ng", ["ngLocale"], ["$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }),
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives),
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider,
                $$jqLite: $$jqLiteProvider
            })
        }
        ])
    }(angular),
    jqLite(document).ready(function() {
        angularInit(document, bootstrap)
    })
}(window, document),
!window.angular.$$csp() && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}</style>'),
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.transition", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]),
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html"]),
angular.module("ui.bootstrap.transition", []).factory("$transition", ["$q", "$timeout", "$rootScope", function($q, $timeout, $rootScope) {
    function findEndEventName(endEventNames) {
        for (var name in endEventNames)
            if (void 0 !== transElement.style[name])
                return endEventNames[name]
    }
    var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer()
          , endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"]
          , transitionEndHandler = function(event) {
            $rootScope.$apply(function() {
                element.unbind(endEventName, transitionEndHandler),
                deferred.resolve(element)
            })
        };
        return endEventName && element.bind(endEventName, transitionEndHandler),
        $timeout(function() {
            angular.isString(trigger) ? element.addClass(trigger) : angular.isFunction(trigger) ? trigger(element) : angular.isObject(trigger) && element.css(trigger),
            endEventName || deferred.resolve(element)
        }),
        deferred.promise.cancel = function() {
            endEventName && element.unbind(endEventName, transitionEndHandler),
            deferred.reject("Transition cancelled")
        }
        ,
        deferred.promise
    }
      , transElement = document.createElement("trans")
      , transitionEndEventNames = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
    }
      , animationEndEventNames = {
        WebkitTransition: "webkitAnimationEnd",
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        transition: "animationend"
    };
    return $transition.transitionEndEventName = findEndEventName(transitionEndEventNames),
    $transition.animationEndEventName = findEndEventName(animationEndEventNames),
    $transition
}
]),
angular.module("ui.bootstrap.collapse", ["ui.bootstrap.transition"]).directive("collapse", ["$transition", function($transition) {
    return {
        link: function(scope, element, attrs) {
            function doTransition(change) {
                function newTransitionDone() {
                    currentTransition === newTransition && (currentTransition = void 0)
                }
                var newTransition = $transition(element, change);
                return currentTransition && currentTransition.cancel(),
                currentTransition = newTransition,
                newTransition.then(newTransitionDone, newTransitionDone),
                newTransition
            }
            function expand() {
                initialAnimSkip ? (initialAnimSkip = !1,
                expandDone()) : (element.removeClass("collapse").addClass("collapsing"),
                doTransition({
                    height: element[0].scrollHeight + "px"
                }).then(expandDone))
            }
            function expandDone() {
                element.removeClass("collapsing"),
                element.addClass("collapse in"),
                element.css({
                    height: "auto"
                })
            }
            function collapse() {
                if (initialAnimSkip)
                    initialAnimSkip = !1,
                    collapseDone(),
                    element.css({
                        height: 0
                    });
                else {
                    element.css({
                        height: element[0].scrollHeight + "px"
                    });
                    element[0].offsetWidth;
                    element.removeClass("collapse in").addClass("collapsing"),
                    doTransition({
                        height: 0
                    }).then(collapseDone)
                }
            }
            function collapseDone() {
                element.removeClass("collapsing"),
                element.addClass("collapse")
            }
            var currentTransition, initialAnimSkip = !0;
            scope.$watch(attrs.collapse, function(shouldCollapse) {
                shouldCollapse ? collapse() : expand()
            })
        }
    }
}
]),
angular.module("ui.bootstrap.accordion", ["ui.bootstrap.collapse"]).constant("accordionConfig", {
    closeOthers: !0
}).controller("AccordionController", ["$scope", "$attrs", "accordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [],
    this.closeOthers = function(openGroup) {
        (angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers) && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1)
        })
    }
    ,
    this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope),
        groupScope.$on("$destroy", function(event) {
            that.removeGroup(groupScope)
        })
    }
    ,
    this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        -1 !== index && this.groups.splice(index, 1)
    }
}
]).directive("accordion", function() {
    return {
        restrict: "EA",
        controller: "AccordionController",
        transclude: !0,
        replace: !1,
        templateUrl: "template/accordion/accordion.html"
    }
}).directive("accordionGroup", function() {
    return {
        require: "^accordion",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/accordion/accordion-group.html",
        scope: {
            heading: "@",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element
            }
        },
        link: function(scope, element, attrs, accordionCtrl) {
            accordionCtrl.addGroup(scope),
            scope.$watch("isOpen", function(value) {
                value && accordionCtrl.closeOthers(scope)
            }),
            scope.toggleOpen = function() {
                scope.isDisabled || (scope.isOpen = !scope.isOpen)
            }
        }
    }
}).directive("accordionHeading", function() {
    return {
        restrict: "EA",
        transclude: !0,
        template: "",
        replace: !0,
        require: "^accordionGroup",
        link: function(scope, element, attr, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, function() {}))
        }
    }
}).directive("accordionTransclude", function() {
    return {
        require: "^accordionGroup",
        link: function(scope, element, attr, controller) {
            scope.$watch(function() {
                return controller[attr.accordionTransclude]
            }, function(heading) {
                heading && (element.html(""),
                element.append(heading))
            })
        }
    }
}),
angular.module("ui.bootstrap.alert", []).controller("AlertController", ["$scope", "$attrs", function($scope, $attrs) {
    $scope.closeable = "close"in $attrs,
    this.close = $scope.close
}
]).directive("alert", function() {
    return {
        restrict: "EA",
        controller: "AlertController",
        templateUrl: "template/alert/alert.html",
        transclude: !0,
        replace: !0,
        scope: {
            type: "@",
            close: "&"
        }
    }
}).directive("dismissOnTimeout", ["$timeout", function($timeout) {
    return {
        require: "alert",
        link: function(scope, element, attrs, alertCtrl) {
            $timeout(function() {
                alertCtrl.close()
            }, parseInt(attrs.dismissOnTimeout, 10))
        }
    }
}
]),
angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function() {
    return function(scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe),
        scope.$watch(attr.bindHtmlUnsafe, function(value) {
            element.html(value || "")
        })
    }
}),
angular.module("ui.bootstrap.buttons", []).constant("buttonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("ButtonsController", ["buttonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active",
    this.toggleEvent = buttonConfig.toggleEvent || "click"
}
]).directive("btnRadio", function() {
    return {
        require: ["btnRadio", "ngModel"],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0]
              , ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)))
            }
            ,
            element.bind(buttonsCtrl.toggleEvent, function() {
                var isActive = element.hasClass(buttonsCtrl.activeClass);
                isActive && !angular.isDefined(attrs.uncheckable) || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio)),
                    ngModelCtrl.$render()
                })
            })
        }
    }
}).directive("btnCheckbox", function() {
    return {
        require: ["btnCheckbox", "ngModel"],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0)
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1)
            }
            function getCheckboxValue(attributeValue, defaultValue) {
                var val = scope.$eval(attributeValue);
                return angular.isDefined(val) ? val : defaultValue
            }
            var buttonsCtrl = ctrls[0]
              , ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()))
            }
            ,
            element.bind(buttonsCtrl.toggleEvent, function() {
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()),
                    ngModelCtrl.$render()
                })
            })
        }
    }
}),
angular.module("ui.bootstrap.carousel", ["ui.bootstrap.transition"]).controller("CarouselController", ["$scope", "$timeout", "$interval", "$transition", function($scope, $timeout, $interval, $transition) {
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        !isNaN(interval) && interval > 0 && (currentInterval = $interval(timerFn, interval))
    }
    function resetTimer() {
        currentInterval && ($interval.cancel(currentInterval),
        currentInterval = null)
    }
    function timerFn() {
        var interval = +$scope.interval;
        isPlaying && !isNaN(interval) && interval > 0 ? $scope.next() : $scope.pause()
    }
    var currentInterval, isPlaying, self = this, slides = self.slides = $scope.slides = [], currentIndex = -1;
    self.currentSlide = null;
    var destroyed = !1;
    self.select = $scope.select = function(nextSlide, direction) {
        function goNext() {
            if (!destroyed) {
                if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
                    nextSlide.$element.addClass(direction);
                    nextSlide.$element[0].offsetWidth;
                    angular.forEach(slides, function(slide) {
                        angular.extend(slide, {
                            direction: "",
                            entering: !1,
                            leaving: !1,
                            active: !1
                        })
                    }),
                    angular.extend(nextSlide, {
                        direction: direction,
                        active: !0,
                        entering: !0
                    }),
                    angular.extend(self.currentSlide || {}, {
                        direction: direction,
                        leaving: !0
                    }),
                    $scope.$currentTransition = $transition(nextSlide.$element, {}),
                    function(next, current) {
                        $scope.$currentTransition.then(function() {
                            transitionDone(next, current)
                        }, function() {
                            transitionDone(next, current)
                        })
                    }(nextSlide, self.currentSlide)
                } else
                    transitionDone(nextSlide, self.currentSlide);
                self.currentSlide = nextSlide,
                currentIndex = nextIndex,
                restartTimer()
            }
        }
        function transitionDone(next, current) {
            angular.extend(next, {
                direction: "",
                active: !0,
                leaving: !1,
                entering: !1
            }),
            angular.extend(current || {}, {
                direction: "",
                active: !1,
                leaving: !1,
                entering: !1
            }),
            $scope.$currentTransition = null
        }
        var nextIndex = slides.indexOf(nextSlide);
        void 0 === direction && (direction = nextIndex > currentIndex ? "next" : "prev"),
        nextSlide && nextSlide !== self.currentSlide && ($scope.$currentTransition ? ($scope.$currentTransition.cancel(),
        $timeout(goNext)) : goNext())
    }
    ,
    $scope.$on("$destroy", function() {
        destroyed = !0
    }),
    self.indexOfSlide = function(slide) {
        return slides.indexOf(slide)
    }
    ,
    $scope.next = function() {
        var newIndex = (currentIndex + 1) % slides.length;
        if (!$scope.$currentTransition)
            return self.select(slides[newIndex], "next")
    }
    ,
    $scope.prev = function() {
        var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;
        if (!$scope.$currentTransition)
            return self.select(slides[newIndex], "prev")
    }
    ,
    $scope.isActive = function(slide) {
        return self.currentSlide === slide
    }
    ,
    $scope.$watch("interval", restartTimer),
    $scope.$on("$destroy", resetTimer),
    $scope.play = function() {
        isPlaying || (isPlaying = !0,
        restartTimer())
    }
    ,
    $scope.pause = function() {
        $scope.noPause || (isPlaying = !1,
        resetTimer())
    }
    ,
    self.addSlide = function(slide, element) {
        slide.$element = element,
        slides.push(slide),
        1 === slides.length || slide.active ? (self.select(slides[slides.length - 1]),
        1 == slides.length && $scope.play()) : slide.active = !1
    }
    ,
    self.removeSlide = function(slide) {
        var index = slides.indexOf(slide);
        slides.splice(index, 1),
        slides.length > 0 && slide.active ? index >= slides.length ? self.select(slides[index - 1]) : self.select(slides[index]) : currentIndex > index && currentIndex--
    }
}
]).directive("carousel", [function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        controller: "CarouselController",
        require: "carousel",
        templateUrl: "template/carousel/carousel.html",
        scope: {
            interval: "=",
            noTransition: "=",
            noPause: "="
        }
    }
}
]).directive("slide", function() {
    return {
        require: "^carousel",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/carousel/slide.html",
        scope: {
            active: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            carouselCtrl.addSlide(scope, element),
            scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope)
            }),
            scope.$watch("active", function(active) {
                active && carouselCtrl.select(scope)
            })
        }
    }
}),
angular.module("ui.bootstrap.dateparser", []).service("dateParser", ["$locale", "orderByFilter", function($locale, orderByFilter) {
    function createParser(format) {
        var map = []
          , regex = format.split("");
        return angular.forEach(formatCodeToRegex, function(data, code) {
            var index = format.indexOf(code);
            if (index > -1) {
                format = format.split(""),
                regex[index] = "(" + data.regex + ")",
                format[index] = "$";
                for (var i = index + 1, n = index + code.length; i < n; i++)
                    regex[i] = "",
                    format[i] = "$";
                format = format.join(""),
                map.push({
                    index: index,
                    apply: data.apply
                })
            }
        }),
        {
            regex: new RegExp("^" + regex.join("") + "$"),
            map: orderByFilter(map, "index")
        }
    }
    function isValid(year, month, date) {
        return 1 === month && date > 28 ? 29 === date && (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) : 3 !== month && 5 !== month && 8 !== month && 10 !== month || date < 31
    }
    this.parsers = {};
    var formatCodeToRegex = {
        yyyy: {
            regex: "\\d{4}",
            apply: function(value) {
                this.year = +value
            }
        },
        yy: {
            regex: "\\d{2}",
            apply: function(value) {
                this.year = +value + 2e3
            }
        },
        y: {
            regex: "\\d{1,4}",
            apply: function(value) {
                this.year = +value
            }
        },
        MMMM: {
            regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value)
            }
        },
        MMM: {
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value)
            }
        },
        MM: {
            regex: "0[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1
            }
        },
        M: {
            regex: "[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1
            }
        },
        dd: {
            regex: "[0-2][0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value
            }
        },
        d: {
            regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value
            }
        },
        EEEE: {
            regex: $locale.DATETIME_FORMATS.DAY.join("|")
        },
        EEE: {
            regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|")
        }
    };
    this.parse = function(input, format) {
        if (!angular.isString(input) || !format)
            return input;
        format = $locale.DATETIME_FORMATS[format] || format,
        this.parsers[format] || (this.parsers[format] = createParser(format));
        var parser = this.parsers[format]
          , regex = parser.regex
          , map = parser.map
          , results = input.match(regex);
        if (results && results.length) {
            for (var dt, fields = {
                year: 1900,
                month: 0,
                date: 1,
                hours: 0
            }, i = 1, n = results.length; i < n; i++) {
                var mapper = map[i - 1];
                mapper.apply && mapper.apply.call(fields, results[i])
            }
            return isValid(fields.year, fields.month, fields.date) && (dt = new Date(fields.year,fields.month,fields.date,fields.hours)),
            dt
        }
    }
}
]),
angular.module("ui.bootstrap.position", []).factory("$position", ["$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
        return el.currentStyle ? el.currentStyle[cssprop] : $window.getComputedStyle ? $window.getComputedStyle(el)[cssprop] : el.style[cssprop]
    }
    function isStaticPositioned(element) {
        return "static" === (getStyle(element, "position") || "static")
    }
    var parentOffsetEl = function(element) {
        for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent); )
            offsetParent = offsetParent.offsetParent;
        return offsetParent || docDomEl
    };
    return {
        position: function(element) {
            var elBCR = this.offset(element)
              , offsetParentBCR = {
                top: 0,
                left: 0
            }
              , offsetParentEl = parentOffsetEl(element[0]);
            offsetParentEl != $document[0] && (offsetParentBCR = this.offset(angular.element(offsetParentEl)),
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop,
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft);
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            }
        },
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            }
        },
        positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
            var hostElPos, targetElWidth, targetElHeight, targetElPos, positionStrParts = positionStr.split("-"), pos0 = positionStrParts[0], pos1 = positionStrParts[1] || "center";
            hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl),
            targetElWidth = targetEl.prop("offsetWidth"),
            targetElHeight = targetEl.prop("offsetHeight");
            var shiftWidth = {
                center: function() {
                    return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2
                },
                left: function() {
                    return hostElPos.left
                },
                right: function() {
                    return hostElPos.left + hostElPos.width
                }
            }
              , shiftHeight = {
                center: function() {
                    return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2
                },
                top: function() {
                    return hostElPos.top
                },
                bottom: function() {
                    return hostElPos.top + hostElPos.height
                }
            };
            switch (pos0) {
            case "right":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: shiftWidth[pos0]()
                };
                break;
            case "left":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: hostElPos.left - targetElWidth
                };
                break;
            case "bottom":
                targetElPos = {
                    top: shiftHeight[pos0](),
                    left: shiftWidth[pos1]()
                };
                break;
            default:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth[pos1]()
                }
            }
            return targetElPos
        }
    }
}
]),
angular.module("ui.bootstrap.datepicker", ["ui.bootstrap.dateparser", "ui.bootstrap.position"]).constant("datepickerConfig", {
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    datepickerMode: "day",
    minMode: "day",
    maxMode: "year",
    showWeeks: !0,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null
}).controller("DatepickerController", ["$scope", "$attrs", "$parse", "$interpolate", "$timeout", "$log", "dateFilter", "datepickerConfig", function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
    var self = this
      , ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.modes = ["day", "month", "year"],
    angular.forEach(["formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "minMode", "maxMode", "showWeeks", "startingDay", "yearRange"], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key]
    }),
    angular.forEach(["minDate", "maxDate"], function(key) {
        $attrs[key] ? $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = value ? new Date(value) : null,
            self.refreshView()
        }) : self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null
    }),
    $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode,
    $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(1e4 * Math.random()),
    this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date,
    $scope.isActive = function(dateObject) {
        return 0 === self.compare(dateObject.date, self.activeDate) && ($scope.activeDateId = dateObject.uid,
        !0)
    }
    ,
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_,
        ngModelCtrl.$render = function() {
            self.render()
        }
    }
    ,
    this.render = function() {
        if (ngModelCtrl.$modelValue) {
            var date = new Date(ngModelCtrl.$modelValue)
              , isValid = !isNaN(date);
            isValid ? this.activeDate = date : $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.'),
            ngModelCtrl.$setValidity("date", isValid)
        }
        this.refreshView()
    }
    ,
    this.refreshView = function() {
        if (this.element) {
            this._refreshView();
            var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
            ngModelCtrl.$setValidity("date-disabled", !date || this.element && !this.isDisabled(date))
        }
    }
    ,
    this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
        return {
            date: date,
            label: dateFilter(date, format),
            selected: model && 0 === this.compare(date, model),
            disabled: this.isDisabled(date),
            current: 0 === this.compare(date, new Date)
        }
    }
    ,
    this.isDisabled = function(date) {
        return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        })
    }
    ,
    this.split = function(arr, size) {
        for (var arrays = []; arr.length > 0; )
            arrays.push(arr.splice(0, size));
        return arrays
    }
    ,
    $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date(0,0,0,0,0,0,0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()),
            ngModelCtrl.$setViewValue(dt),
            ngModelCtrl.$render()
        } else
            self.activeDate = date,
            $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1]
    }
    ,
    $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0)
          , month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1),
        self.refreshView()
    }
    ,
    $scope.toggleMode = function(direction) {
        direction = direction || 1,
        $scope.datepickerMode === self.maxMode && 1 === direction || $scope.datepickerMode === self.minMode && -1 === direction || ($scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction])
    }
    ,
    $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        $timeout(function() {
            self.element[0].focus()
        }, 0, !1)
    };
    $scope.$on("datepicker.focus", focusElement),
    $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (key && !evt.shiftKey && !evt.altKey)
            if (evt.preventDefault(),
            evt.stopPropagation(),
            "enter" === key || "space" === key) {
                if (self.isDisabled(self.activeDate))
                    return;
                $scope.select(self.activeDate),
                focusElement()
            } else
                !evt.ctrlKey || "up" !== key && "down" !== key ? (self.handleKeyDown(key, evt),
                self.refreshView()) : ($scope.toggleMode("up" === key ? 1 : -1),
                focusElement())
    }
}
]).directive("datepicker", function() {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/datepicker.html",
        scope: {
            datepickerMode: "=?",
            dateDisabled: "&"
        },
        require: ["datepicker", "?^ngModel"],
        controller: "DatepickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0]
              , ngModelCtrl = ctrls[1];
            ngModelCtrl && datepickerCtrl.init(ngModelCtrl)
        }
    }
}).directive("daypicker", ["dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/day.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            function getDaysInMonth(year, month) {
                return 1 !== month || year % 4 != 0 || year % 100 == 0 && year % 400 != 0 ? DAYS_IN_MONTH[month] : 29
            }
            function getDates(startDate, n) {
                var dates = new Array(n)
                  , current = new Date(startDate)
                  , i = 0;
                for (current.setHours(12); i < n; )
                    dates[i++] = new Date(current),
                    current.setDate(current.getDate() + 1);
                return dates
            }
            function getISO8601WeekNumber(date) {
                var checkDate = new Date(date);
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                var time = checkDate.getTime();
                return checkDate.setMonth(0),
                checkDate.setDate(1),
                Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1
            }
            scope.showWeeks = ctrl.showWeeks,
            ctrl.step = {
                months: 1
            },
            ctrl.element = element;
            var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            ctrl._refreshView = function() {
                var year = ctrl.activeDate.getFullYear()
                  , month = ctrl.activeDate.getMonth()
                  , firstDayOfMonth = new Date(year,month,1)
                  , difference = ctrl.startingDay - firstDayOfMonth.getDay()
                  , numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference
                  , firstDate = new Date(firstDayOfMonth);
                numDisplayedFromPreviousMonth > 0 && firstDate.setDate(1 - numDisplayedFromPreviousMonth);
                for (var days = getDates(firstDate, 42), i = 0; i < 42; i++)
                    days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
                        secondary: days[i].getMonth() !== month,
                        uid: scope.uniqueId + "-" + i
                    });
                scope.labels = new Array(7);
                for (var j = 0; j < 7; j++)
                    scope.labels[j] = {
                        abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
                        full: dateFilter(days[j].date, "EEEE")
                    };
                if (scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle),
                scope.rows = ctrl.split(days, 7),
                scope.showWeeks) {
                    scope.weekNumbers = [];
                    for (var weekNumber = getISO8601WeekNumber(scope.rows[0][0].date), numWeeks = scope.rows.length; scope.weekNumbers.push(weekNumber++) < numWeeks; )
                        ;
                }
            }
            ,
            ctrl.compare = function(date1, date2) {
                return new Date(date1.getFullYear(),date1.getMonth(),date1.getDate()) - new Date(date2.getFullYear(),date2.getMonth(),date2.getDate())
            }
            ,
            ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getDate();
                if ("left" === key)
                    date -= 1;
                else if ("up" === key)
                    date -= 7;
                else if ("right" === key)
                    date += 1;
                else if ("down" === key)
                    date += 7;
                else if ("pageup" === key || "pagedown" === key) {
                    var month = ctrl.activeDate.getMonth() + ("pageup" === key ? -1 : 1);
                    ctrl.activeDate.setMonth(month, 1),
                    date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date)
                } else
                    "home" === key ? date = 1 : "end" === key && (date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()));
                ctrl.activeDate.setDate(date)
            }
            ,
            ctrl.refreshView()
        }
    }
}
]).directive("monthpicker", ["dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/month.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            ctrl.step = {
                years: 1
            },
            ctrl.element = element,
            ctrl._refreshView = function() {
                for (var months = new Array(12), year = ctrl.activeDate.getFullYear(), i = 0; i < 12; i++)
                    months[i] = angular.extend(ctrl.createDateObject(new Date(year,i,1), ctrl.formatMonth), {
                        uid: scope.uniqueId + "-" + i
                    });
                scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle),
                scope.rows = ctrl.split(months, 3)
            }
            ,
            ctrl.compare = function(date1, date2) {
                return new Date(date1.getFullYear(),date1.getMonth()) - new Date(date2.getFullYear(),date2.getMonth())
            }
            ,
            ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getMonth();
                if ("left" === key)
                    date -= 1;
                else if ("up" === key)
                    date -= 3;
                else if ("right" === key)
                    date += 1;
                else if ("down" === key)
                    date += 3;
                else if ("pageup" === key || "pagedown" === key) {
                    var year = ctrl.activeDate.getFullYear() + ("pageup" === key ? -1 : 1);
                    ctrl.activeDate.setFullYear(year)
                } else
                    "home" === key ? date = 0 : "end" === key && (date = 11);
                ctrl.activeDate.setMonth(date)
            }
            ,
            ctrl.refreshView()
        }
    }
}
]).directive("yearpicker", ["dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/year.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            function getStartingYear(year) {
                return parseInt((year - 1) / range, 10) * range + 1
            }
            var range = ctrl.yearRange;
            ctrl.step = {
                years: range
            },
            ctrl.element = element,
            ctrl._refreshView = function() {
                for (var years = new Array(range), i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++)
                    years[i] = angular.extend(ctrl.createDateObject(new Date(start + i,0,1), ctrl.formatYear), {
                        uid: scope.uniqueId + "-" + i
                    });
                scope.title = [years[0].label, years[range - 1].label].join(" - "),
                scope.rows = ctrl.split(years, 5)
            }
            ,
            ctrl.compare = function(date1, date2) {
                return date1.getFullYear() - date2.getFullYear()
            }
            ,
            ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getFullYear();
                "left" === key ? date -= 1 : "up" === key ? date -= 5 : "right" === key ? date += 1 : "down" === key ? date += 5 : "pageup" === key || "pagedown" === key ? date += ("pageup" === key ? -1 : 1) * ctrl.step.years : "home" === key ? date = getStartingYear(ctrl.activeDate.getFullYear()) : "end" === key && (date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1),
                ctrl.activeDate.setFullYear(date)
            }
            ,
            ctrl.refreshView()
        }
    }
}
]).constant("datepickerPopupConfig", {
    datepickerPopup: "yyyy-MM-dd",
    currentText: "Today",
    clearText: "Clear",
    closeText: "Done",
    closeOnDateSelection: !0,
    appendToBody: !1,
    showButtonBar: !0
}).directive("datepickerPopup", ["$compile", "$parse", "$document", "$position", "dateFilter", "dateParser", "datepickerPopupConfig", function($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
    return {
        restrict: "EA",
        require: "ngModel",
        scope: {
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@",
            dateDisabled: "&"
        },
        link: function(scope, element, attrs, ngModel) {
            function cameltoDash(string) {
                return string.replace(/([A-Z])/g, function($1) {
                    return "-" + $1.toLowerCase()
                })
            }
            function parseDate(viewValue) {
                if (viewValue) {
                    if (angular.isDate(viewValue) && !isNaN(viewValue))
                        return ngModel.$setValidity("date", !0),
                        viewValue;
                    if (angular.isString(viewValue)) {
                        var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);
                        return isNaN(date) ? void ngModel.$setValidity("date", !1) : (ngModel.$setValidity("date", !0),
                        date)
                    }
                    return void ngModel.$setValidity("date", !1)
                }
                return ngModel.$setValidity("date", !0),
                null
            }
            var dateFormat, closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
            scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar,
            scope.getText = function(key) {
                return scope[key + "Text"] || datepickerPopupConfig[key + "Text"]
            }
            ,
            attrs.$observe("datepickerPopup", function(value) {
                dateFormat = value || datepickerPopupConfig.datepickerPopup,
                ngModel.$render()
            });
            var popupEl = angular.element("<div datepicker-popup-wrap><div datepicker></div></div>");
            popupEl.attr({
                "ng-model": "date",
                "ng-change": "dateSelection()"
            });
            var datepickerEl = angular.element(popupEl.children()[0]);
            attrs.datepickerOptions && angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function(value, option) {
                datepickerEl.attr(cameltoDash(option), value)
            }),
            scope.watchData = {},
            angular.forEach(["minDate", "maxDate", "datepickerMode"], function(key) {
                if (attrs[key]) {
                    var getAttribute = $parse(attrs[key]);
                    if (scope.$parent.$watch(getAttribute, function(value) {
                        scope.watchData[key] = value
                    }),
                    datepickerEl.attr(cameltoDash(key), "watchData." + key),
                    "datepickerMode" === key) {
                        var setAttribute = getAttribute.assign;
                        scope.$watch("watchData." + key, function(value, oldvalue) {
                            value !== oldvalue && setAttribute(scope.$parent, value)
                        })
                    }
                }
            }),
            attrs.dateDisabled && datepickerEl.attr("date-disabled", "dateDisabled({ date: date, mode: mode })"),
            ngModel.$parsers.unshift(parseDate),
            scope.dateSelection = function(dt) {
                angular.isDefined(dt) && (scope.date = dt),
                ngModel.$setViewValue(scope.date),
                ngModel.$render(),
                closeOnDateSelection && (scope.isOpen = !1,
                element[0].focus())
            }
            ,
            element.bind("input change keyup", function() {
                scope.$apply(function() {
                    scope.date = ngModel.$modelValue
                })
            }),
            ngModel.$render = function() {
                var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : "";
                element.val(date),
                scope.date = parseDate(ngModel.$modelValue)
            }
            ;
            var documentClickBind = function(event) {
                scope.isOpen && event.target !== element[0] && scope.$apply(function() {
                    scope.isOpen = !1
                })
            }
              , keydown = function(evt, noApply) {
                scope.keydown(evt)
            };
            element.bind("keydown", keydown),
            scope.keydown = function(evt) {
                27 === evt.which ? (evt.preventDefault(),
                evt.stopPropagation(),
                scope.close()) : 40 !== evt.which || scope.isOpen || (scope.isOpen = !0)
            }
            ,
            scope.$watch("isOpen", function(value) {
                value ? (scope.$broadcast("datepicker.focus"),
                scope.position = appendToBody ? $position.offset(element) : $position.position(element),
                scope.position.top = scope.position.top + element.prop("offsetHeight"),
                $document.bind("click", documentClickBind)) : $document.unbind("click", documentClickBind)
            }),
            scope.select = function(date) {
                if ("today" === date) {
                    var today = new Date;
                    angular.isDate(ngModel.$modelValue) ? (date = new Date(ngModel.$modelValue),
                    date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate())) : date = new Date(today.setHours(0, 0, 0, 0))
                }
                scope.dateSelection(date)
            }
            ,
            scope.close = function() {
                scope.isOpen = !1,
                element[0].focus()
            }
            ;
            var $popup = $compile(popupEl)(scope);
            popupEl.remove(),
            appendToBody ? $document.find("body").append($popup) : element.after($popup),
            scope.$on("$destroy", function() {
                $popup.remove(),
                element.unbind("keydown", keydown),
                $document.unbind("click", documentClickBind)
            })
        }
    }
}
]).directive("datepickerPopupWrap", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        templateUrl: "template/datepicker/popup.html",
        link: function(scope, element, attrs) {
            element.bind("click", function(event) {
                event.preventDefault(),
                event.stopPropagation()
            })
        }
    }
}),
angular.module("ui.bootstrap.dropdown", []).constant("dropdownConfig", {
    openClass: "open"
}).service("dropdownService", ["$document", function($document) {
    var openScope = null;
    this.open = function(dropdownScope) {
        openScope || ($document.bind("click", closeDropdown),
        $document.bind("keydown", escapeKeyBind)),
        openScope && openScope !== dropdownScope && (openScope.isOpen = !1),
        openScope = dropdownScope
    }
    ,
    this.close = function(dropdownScope) {
        openScope === dropdownScope && (openScope = null,
        $document.unbind("click", closeDropdown),
        $document.unbind("keydown", escapeKeyBind))
    }
    ;
    var closeDropdown = function(evt) {
        if (openScope) {
            var toggleElement = openScope.getToggleElement();
            evt && toggleElement && toggleElement[0].contains(evt.target) || openScope.$apply(function() {
                openScope.isOpen = !1
            })
        }
    }
      , escapeKeyBind = function(evt) {
        27 === evt.which && (openScope.focusToggleElement(),
        closeDropdown())
    }
}
]).controller("DropdownController", ["$scope", "$attrs", "$parse", "dropdownConfig", "dropdownService", "$animate", function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {
    var getIsOpen, self = this, scope = $scope.$new(), openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;
    this.init = function(element) {
        self.$element = element,
        $attrs.isOpen && (getIsOpen = $parse($attrs.isOpen),
        setIsOpen = getIsOpen.assign,
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value
        }))
    }
    ,
    this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen
    }
    ,
    this.isOpen = function() {
        return scope.isOpen
    }
    ,
    scope.getToggleElement = function() {
        return self.toggleElement
    }
    ,
    scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus()
    }
    ,
    scope.$watch("isOpen", function(isOpen, wasOpen) {
        $animate[isOpen ? "addClass" : "removeClass"](self.$element, openClass),
        isOpen ? (scope.focusToggleElement(),
        dropdownService.open(scope)) : dropdownService.close(scope),
        setIsOpen($scope, isOpen),
        angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
            open: !!isOpen
        })
    }),
    $scope.$on("$locationChangeSuccess", function() {
        scope.isOpen = !1
    }),
    $scope.$on("$destroy", function() {
        scope.$destroy()
    })
}
]).directive("dropdown", function() {
    return {
        controller: "DropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init(element)
        }
    }
}).directive("dropdownToggle", function() {
    return {
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(),
                    element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle()
                    })
                };
                element.bind("click", toggleDropdown),
                element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }),
                scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen)
                }),
                scope.$on("$destroy", function() {
                    element.unbind("click", toggleDropdown)
                })
            }
        }
    }
}),
angular.module("ui.bootstrap.modal", ["ui.bootstrap.transition"]).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    })
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++)
                        if (key == stack[i].key)
                            return stack[i]
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++)
                        keys.push(stack[i].key);
                    return keys
                },
                top: function() {
                    return stack[stack.length - 1]
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++)
                        if (key == stack[i].key) {
                            idx = i;
                            break
                        }
                    return stack.splice(idx, 1)[0]
                },
                removeTop: function() {
                    return stack.splice(stack.length - 1, 1)[0]
                },
                length: function() {
                    return stack.length
                }
            }
        }
    }
}).directive("modalBackdrop", ["$timeout", function($timeout) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/modal/backdrop.html",
        link: function(scope, element, attrs) {
            scope.backdropClass = attrs.backdropClass || "",
            scope.animate = !1,
            $timeout(function() {
                scope.animate = !0
            })
        }
    }
}
]).directive("modalWindow", ["$modalStack", "$timeout", function($modalStack, $timeout) {
    return {
        restrict: "EA",
        scope: {
            index: "@",
            animate: "="
        },
        replace: !0,
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "template/modal/window.html"
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowClass || ""),
            scope.size = attrs.size,
            $timeout(function() {
                scope.animate = !0,
                element[0].querySelectorAll("[autofocus]").length || element[0].focus()
            }),
            scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" != modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(),
                evt.stopPropagation(),
                $modalStack.dismiss(modal.key, "backdrop click"))
            }
        }
    }
}
]).directive("modalTransclude", function() {
    return {
        link: function($scope, $element, $attrs, controller, $transclude) {
            $transclude($scope.$parent, function(clone) {
                $element.empty(),
                $element.append(clone)
            })
        }
    }
}).factory("$modalStack", ["$transition", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++)
            openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex
    }
    function removeModalWindow(modalInstance) {
        var body = $document.find("body").eq(0)
          , modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance),
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {
            modalWindow.modalScope.$destroy(),
            body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0),
            checkRemoveBackdrop()
        })
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && -1 == backdropIndex()) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, 150, function() {
                backdropScopeRef.$destroy(),
                backdropScopeRef = null
            }),
            backdropDomEl = void 0,
            backdropScope = void 0
        }
    }
    function removeAfterAnimate(domEl, scope, emulateTime, done) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0,
            domEl.remove(),
            done && done())
        }
        scope.animate = !1;
        var transitionEndEventName = $transition.transitionEndEventName;
        if (transitionEndEventName) {
            var timeout = $timeout(afterAnimating, emulateTime);
            domEl.bind(transitionEndEventName, function() {
                $timeout.cancel(timeout),
                afterAnimating(),
                scope.$apply()
            })
        } else
            $timeout(afterAnimating)
    }
    var backdropDomEl, backdropScope, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), $modalStack = {};
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex)
    }),
    $document.bind("keydown", function(evt) {
        var modal;
        27 === evt.which && (modal = openedWindows.top()) && modal.value.keyboard && (evt.preventDefault(),
        $rootScope.$apply(function() {
            $modalStack.dismiss(modal.key, "escape key press")
        }))
    }),
    $modalStack.open = function(modalInstance, modal) {
        openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard
        });
        var body = $document.find("body").eq(0)
          , currBackdropIndex = backdropIndex();
        if (currBackdropIndex >= 0 && !backdropDomEl) {
            backdropScope = $rootScope.$new(!0),
            backdropScope.index = currBackdropIndex;
            var angularBackgroundDomEl = angular.element("<div modal-backdrop></div>");
            angularBackgroundDomEl.attr("backdrop-class", modal.backdropClass),
            backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope),
            body.append(backdropDomEl)
        }
        var angularDomEl = angular.element("<div modal-window></div>");
        angularDomEl.attr({
            "template-url": modal.windowTemplateUrl,
            "window-class": modal.windowClass,
            size: modal.size,
            index: openedWindows.length() - 1,
            animate: "animate"
        }).html(modal.content);
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl,
        body.append(modalDomEl),
        body.addClass(OPENED_MODAL_CLASS)
    }
    ,
    $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        modalWindow && (modalWindow.value.deferred.resolve(result),
        removeModalWindow(modalInstance))
    }
    ,
    $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        modalWindow && (modalWindow.value.deferred.reject(reason),
        removeModalWindow(modalInstance))
    }
    ,
    $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal; )
            this.dismiss(topModal.key, reason),
            topModal = this.getTop()
    }
    ,
    $modalStack.getTop = function() {
        return openedWindows.top()
    }
    ,
    $modalStack
}
]).provider("$modal", function() {
    var $modalProvider = {
        options: {
            backdrop: !0,
            keyboard: !0
        },
        $get: ["$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $http.get(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl, {
                    cache: $templateCache
                }).then(function(result) {
                    return result.data
                })
            }
            function getResolvePromises(resolves) {
                var promisesArr = [];
                return angular.forEach(resolves, function(value) {
                    (angular.isFunction(value) || angular.isArray(value)) && promisesArr.push($q.when($injector.invoke(value)))
                }),
                promisesArr
            }
            var $modal = {};
            return $modal.open = function(modalOptions) {
                var modalResultDeferred = $q.defer()
                  , modalOpenedDeferred = $q.defer()
                  , modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    close: function(result) {
                        $modalStack.close(modalInstance, result)
                    },
                    dismiss: function(reason) {
                        $modalStack.dismiss(modalInstance, reason)
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions),
                modalOptions.resolve = modalOptions.resolve || {},
                !modalOptions.template && !modalOptions.templateUrl)
                    throw new Error("One of template or templateUrl options is required.");
                var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
                return templateAndResolvePromise.then(function(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new();
                    modalScope.$close = modalInstance.close,
                    modalScope.$dismiss = modalInstance.dismiss;
                    var ctrlInstance, ctrlLocals = {}, resolveIter = 1;
                    modalOptions.controller && (ctrlLocals.$scope = modalScope,
                    ctrlLocals.$modalInstance = modalInstance,
                    angular.forEach(modalOptions.resolve, function(value, key) {
                        ctrlLocals[key] = tplAndVars[resolveIter++]
                    }),
                    ctrlInstance = $controller(modalOptions.controller, ctrlLocals),
                    modalOptions.controllerAs && (modalScope[modalOptions.controllerAs] = ctrlInstance)),
                    $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        content: tplAndVars[0],
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        backdropClass: modalOptions.backdropClass,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        size: modalOptions.size
                    })
                }, function(reason) {
                    modalResultDeferred.reject(reason)
                }),
                templateAndResolvePromise.then(function() {
                    modalOpenedDeferred.resolve(!0)
                }, function() {
                    modalOpenedDeferred.reject(!1)
                }),
                modalInstance
            }
            ,
            $modal
        }
        ]
    };
    return $modalProvider
}),
angular.module("ui.bootstrap.pagination", []).controller("PaginationController", ["$scope", "$attrs", "$parse", function($scope, $attrs, $parse) {
    var self = this
      , ngModelCtrl = {
        $setViewValue: angular.noop
    }
      , setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_,
        this.config = config,
        ngModelCtrl.$render = function() {
            self.render()
        }
        ,
        $attrs.itemsPerPage ? $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10),
            $scope.totalPages = self.calculateTotalPages()
        }) : this.itemsPerPage = config.itemsPerPage
    }
    ,
    this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1)
    }
    ,
    this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1
    }
    ,
    $scope.selectPage = function(page) {
        $scope.page !== page && page > 0 && page <= $scope.totalPages && (ngModelCtrl.$setViewValue(page),
        ngModelCtrl.$render())
    }
    ,
    $scope.getText = function(key) {
        return $scope[key + "Text"] || self.config[key + "Text"]
    }
    ,
    $scope.noPrevious = function() {
        return 1 === $scope.page
    }
    ,
    $scope.noNext = function() {
        return $scope.page === $scope.totalPages
    }
    ,
    $scope.$watch("totalItems", function() {
        $scope.totalPages = self.calculateTotalPages()
    }),
    $scope.$watch("totalPages", function(value) {
        setNumPages($scope.$parent, value),
        $scope.page > value ? $scope.selectPage(value) : ngModelCtrl.$render()
    })
}
]).constant("paginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0
}).directive("pagination", ["$parse", "paginationConfig", function($parse, paginationConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@"
        },
        require: ["pagination", "?ngModel"],
        controller: "PaginationController",
        templateUrl: "template/pagination/pagination.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            function makePage(number, text, isActive) {
                return {
                    number: number,
                    text: text,
                    active: isActive
                }
            }
            function getPages(currentPage, totalPages) {
                var pages = []
                  , startPage = 1
                  , endPage = totalPages
                  , isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
                isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1),
                (endPage = startPage + maxSize - 1) > totalPages && (endPage = totalPages,
                startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1,
                endPage = Math.min(startPage + maxSize - 1, totalPages)));
                for (var number = startPage; number <= endPage; number++) {
                    var page = makePage(number, number, number === currentPage);
                    pages.push(page)
                }
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", !1);
                        pages.unshift(previousPageSet)
                    }
                    if (endPage < totalPages) {
                        var nextPageSet = makePage(endPage + 1, "...", !1);
                        pages.push(nextPageSet)
                    }
                }
                return pages
            }
            var paginationCtrl = ctrls[0]
              , ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize
                  , rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
                scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks,
                scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks,
                paginationCtrl.init(ngModelCtrl, paginationConfig),
                attrs.maxSize && scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                    maxSize = parseInt(value, 10),
                    paginationCtrl.render()
                });
                var originalRender = paginationCtrl.render;
                paginationCtrl.render = function() {
                    originalRender(),
                    scope.page > 0 && scope.page <= scope.totalPages && (scope.pages = getPages(scope.page, scope.totalPages))
                }
            }
        }
    }
}
]).constant("pagerConfig", {
    itemsPerPage: 10,
    previousText: "« Previous",
    nextText: "Next »",
    align: !0
}).directive("pager", ["pagerConfig", function(pagerConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@"
        },
        require: ["pager", "?ngModel"],
        controller: "PaginationController",
        templateUrl: "template/pagination/pager.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0]
              , ngModelCtrl = ctrls[1];
            ngModelCtrl && (scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align,
            paginationCtrl.init(ngModelCtrl, pagerConfig))
        }
    }
}
]),
angular.module("ui.bootstrap.tooltip", ["ui.bootstrap.position", "ui.bootstrap.bindHtml"]).provider("$tooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g;
        return name.replace(regexp, function(letter, pos) {
            return (pos ? "-" : "") + letter.toLowerCase()
        })
    }
    var defaultOptions = {
        placement: "top",
        animation: !0,
        popupDelay: 0
    }
      , triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        focus: "blur"
    }
      , globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value)
    }
    ,
    this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers)
    }
    ,
    this.$get = ["$window", "$compile", "$timeout", "$document", "$position", "$interpolate", function($window, $compile, $timeout, $document, $position, $interpolate) {
        return function(type, prefix, defaultTriggerShow) {
            function getTriggers(trigger) {
                var show = trigger || options.trigger || defaultTriggerShow;
                return {
                    show: show,
                    hide: triggerMap[show] || show
                }
            }
            var options = angular.extend({}, defaultOptions, globalOptions)
              , directiveName = snake_case(type)
              , startSym = $interpolate.startSymbol()
              , endSym = $interpolate.endSymbol()
              , template = "<div " + directiveName + '-popup title="' + startSym + "title" + endSym + '" content="' + startSym + "content" + endSym + '" placement="' + startSym + "placement" + endSym + '" animation="animation" is-open="isOpen"></div>';
            return {
                restrict: "EA",
                compile: function(tElem, tAttrs) {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs) {
                        function toggleTooltipBind() {
                            ttScope.isOpen ? hideTooltipBind() : showTooltipBind()
                        }
                        function showTooltipBind() {
                            hasEnableExp && !scope.$eval(attrs[prefix + "Enable"]) || (prepareTooltip(),
                            ttScope.popupDelay ? popupTimeout || (popupTimeout = $timeout(show, ttScope.popupDelay, !1),
                            popupTimeout.then(function(reposition) {
                                reposition()
                            })) : show()())
                        }
                        function hideTooltipBind() {
                            scope.$apply(function() {
                                hide()
                            })
                        }
                        function show() {
                            return popupTimeout = null,
                            transitionTimeout && ($timeout.cancel(transitionTimeout),
                            transitionTimeout = null),
                            ttScope.content ? (createTooltip(),
                            tooltip.css({
                                top: 0,
                                left: 0,
                                display: "block"
                            }),
                            ttScope.$digest(),
                            positionTooltip(),
                            ttScope.isOpen = !0,
                            ttScope.$digest(),
                            positionTooltip) : angular.noop
                        }
                        function hide() {
                            ttScope.isOpen = !1,
                            $timeout.cancel(popupTimeout),
                            popupTimeout = null,
                            ttScope.animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 500)) : removeTooltip()
                        }
                        function createTooltip() {
                            tooltip && removeTooltip(),
                            tooltipLinkedScope = ttScope.$new(),
                            tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                                appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip)
                            })
                        }
                        function removeTooltip() {
                            transitionTimeout = null,
                            tooltip && (tooltip.remove(),
                            tooltip = null),
                            tooltipLinkedScope && (tooltipLinkedScope.$destroy(),
                            tooltipLinkedScope = null)
                        }
                        function prepareTooltip() {
                            prepPlacement(),
                            prepPopupDelay()
                        }
                        function prepPlacement() {
                            var val = attrs[prefix + "Placement"];
                            ttScope.placement = angular.isDefined(val) ? val : options.placement
                        }
                        function prepPopupDelay() {
                            var val = attrs[prefix + "PopupDelay"]
                              , delay = parseInt(val, 10);
                            ttScope.popupDelay = isNaN(delay) ? options.popupDelay : delay
                        }
                        var tooltip, tooltipLinkedScope, transitionTimeout, popupTimeout, appendToBody = !!angular.isDefined(options.appendToBody) && options.appendToBody, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), ttScope = scope.$new(!0), positionTooltip = function() {
                            var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                            ttPosition.top += "px",
                            ttPosition.left += "px",
                            tooltip.css(ttPosition)
                        };
                        ttScope.isOpen = !1,
                        attrs.$observe(type, function(val) {
                            ttScope.content = val,
                            !val && ttScope.isOpen && hide()
                        }),
                        attrs.$observe(prefix + "Title", function(val) {
                            ttScope.title = val
                        });
                        var unregisterTriggers = function() {
                            element.unbind(triggers.show, showTooltipBind),
                            element.unbind(triggers.hide, hideTooltipBind)
                        };
                        !function() {
                            var val = attrs[prefix + "Trigger"];
                            unregisterTriggers(),
                            triggers = getTriggers(val),
                            triggers.show === triggers.hide ? element.bind(triggers.show, toggleTooltipBind) : (element.bind(triggers.show, showTooltipBind),
                            element.bind(triggers.hide, hideTooltipBind))
                        }();
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                        var appendToBodyVal = scope.$eval(attrs[prefix + "AppendToBody"]);
                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody,
                        appendToBody && scope.$on("$locationChangeSuccess", function() {
                            ttScope.isOpen && hide()
                        }),
                        scope.$on("$destroy", function() {
                            $timeout.cancel(transitionTimeout),
                            $timeout.cancel(popupTimeout),
                            unregisterTriggers(),
                            removeTooltip(),
                            ttScope = null
                        })
                    }
                }
            }
        }
    }
    ]
}).directive("tooltipPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html"
    }
}).directive("tooltip", ["$tooltip", function($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter")
}
]).directive("tooltipHtmlUnsafePopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
    }
}).directive("tooltipHtmlUnsafe", ["$tooltip", function($tooltip) {
    return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter")
}
]),
angular.module("ui.bootstrap.popover", ["ui.bootstrap.tooltip"]).directive("popoverPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html"
    }
}).directive("popover", ["$tooltip", function($tooltip) {
    return $tooltip("popover", "popover", "click")
}
]),
angular.module("ui.bootstrap.progressbar", []).constant("progressConfig", {
    animate: !0,
    max: 100
}).controller("ProgressController", ["$scope", "$attrs", "progressConfig", function($scope, $attrs, progressConfig) {
    var self = this
      , animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [],
    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max,
    this.addBar = function(bar, element) {
        animate || element.css({
            transition: "none"
        }),
        this.bars.push(bar),
        bar.$watch("value", function(value) {
            bar.percent = +(100 * value / $scope.max).toFixed(2)
        }),
        bar.$on("$destroy", function() {
            element = null,
            self.removeBar(bar)
        })
    }
    ,
    this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1)
    }
}
]).directive("progress", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        require: "progress",
        scope: {},
        templateUrl: "template/progressbar/progress.html"
    }
}).directive("bar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        require: "^progress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element)
        }
    }
}).directive("progressbar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]))
        }
    }
}),
angular.module("ui.bootstrap.rating", []).constant("ratingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null
}).controller("RatingController", ["$scope", "$attrs", "ratingConfig", function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_,
        ngModelCtrl.$render = this.render,
        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn,
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates)
    }
    ,
    this.buildTemplateObjects = function(states) {
        for (var i = 0, n = states.length; i < n; i++)
            states[i] = angular.extend({
                index: i
            }, {
                stateOn: this.stateOn,
                stateOff: this.stateOff
            }, states[i]);
        return states
    }
    ,
    $scope.rate = function(value) {
        !$scope.readonly && value >= 0 && value <= $scope.range.length && (ngModelCtrl.$setViewValue(value),
        ngModelCtrl.$render())
    }
    ,
    $scope.enter = function(value) {
        $scope.readonly || ($scope.value = value),
        $scope.onHover({
            value: value
        })
    }
    ,
    $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue,
        $scope.onLeave()
    }
    ,
    $scope.onKeydown = function(evt) {
        /(37|38|39|40)/.test(evt.which) && (evt.preventDefault(),
        evt.stopPropagation(),
        $scope.rate($scope.value + (38 === evt.which || 39 === evt.which ? 1 : -1)))
    }
    ,
    this.render = function() {
        $scope.value = ngModelCtrl.$viewValue
    }
}
]).directive("rating", function() {
    return {
        restrict: "EA",
        require: ["rating", "ngModel"],
        scope: {
            readonly: "=?",
            onHover: "&",
            onLeave: "&"
        },
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0]
              , ngModelCtrl = ctrls[1];
            ngModelCtrl && ratingCtrl.init(ngModelCtrl)
        }
    }
}),
angular.module("ui.bootstrap.tabs", []).controller("TabsetController", ["$scope", function($scope) {
    var ctrl = this
      , tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(selectedTab) {
        angular.forEach(tabs, function(tab) {
            tab.active && tab !== selectedTab && (tab.active = !1,
            tab.onDeselect())
        }),
        selectedTab.active = !0,
        selectedTab.onSelect()
    }
    ,
    ctrl.addTab = function(tab) {
        tabs.push(tab),
        1 === tabs.length ? tab.active = !0 : tab.active && ctrl.select(tab)
    }
    ,
    ctrl.removeTab = function(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1 && !destroyed) {
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex])
        }
        tabs.splice(index, 1)
    }
    ;
    var destroyed;
    $scope.$on("$destroy", function() {
        destroyed = !0
    })
}
]).directive("tabset", function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        scope: {
            type: "@"
        },
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            scope.vertical = !!angular.isDefined(attrs.vertical) && scope.$parent.$eval(attrs.vertical),
            scope.justified = !!angular.isDefined(attrs.justified) && scope.$parent.$eval(attrs.justified)
        }
    }
}).directive("tab", ["$parse", function($parse) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: !0,
        templateUrl: "template/tabs/tab.html",
        transclude: !0,
        scope: {
            active: "=?",
            heading: "@",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        compile: function(elm, attrs, transclude) {
            return function(scope, elm, attrs, tabsetCtrl) {
                scope.$watch("active", function(active) {
                    active && tabsetCtrl.select(scope)
                }),
                scope.disabled = !1,
                attrs.disabled && scope.$parent.$watch($parse(attrs.disabled), function(value) {
                    scope.disabled = !!value
                }),
                scope.select = function() {
                    scope.disabled || (scope.active = !0)
                }
                ,
                tabsetCtrl.addTab(scope),
                scope.$on("$destroy", function() {
                    tabsetCtrl.removeTab(scope)
                }),
                scope.$transcludeFn = transclude
            }
        }
    }
}
]).directive("tabHeadingTransclude", [function() {
    return {
        restrict: "A",
        require: "^tab",
        link: function(scope, elm, attrs, tabCtrl) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""),
                elm.append(heading))
            })
        }
    }
}
]).directive("tabContentTransclude", function() {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase())
    }
    return {
        restrict: "A",
        require: "^tabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node)
                })
            })
        }
    }
}),
angular.module("ui.bootstrap.timepicker", []).constant("timepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: !0,
    meridians: null,
    readonlyInput: !1,
    mousewheel: !0
}).controller("TimepickerController", ["$scope", "$attrs", "$parse", "$log", "$locale", "timepickerConfig", function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
    function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10);
        if ($scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24)
            return $scope.showMeridian && (12 === hours && (hours = 0),
            $scope.meridian === meridians[1] && (hours += 12)),
            hours
    }
    function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10);
        return minutes >= 0 && minutes < 60 ? minutes : void 0
    }
    function pad(value) {
        return angular.isDefined(value) && value.toString().length < 2 ? "0" + value : value
    }
    function refresh(keyboardChange) {
        makeValid(),
        ngModelCtrl.$setViewValue(new Date(selected)),
        updateTemplate(keyboardChange)
    }
    function makeValid() {
        ngModelCtrl.$setValidity("time", !0),
        $scope.invalidHours = !1,
        $scope.invalidMinutes = !1
    }
    function updateTemplate(keyboardChange) {
        var hours = selected.getHours()
          , minutes = selected.getMinutes();
        $scope.showMeridian && (hours = 0 === hours || 12 === hours ? 12 : hours % 12),
        $scope.hours = "h" === keyboardChange ? hours : pad(hours),
        $scope.minutes = "m" === keyboardChange ? minutes : pad(minutes),
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1]
    }
    function addMinutes(minutes) {
        var dt = new Date(selected.getTime() + 6e4 * minutes);
        selected.setHours(dt.getHours(), dt.getMinutes()),
        refresh()
    }
    var selected = new Date
      , ngModelCtrl = {
        $setViewValue: angular.noop
    }
      , meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
    this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_,
        ngModelCtrl.$render = this.render;
        var hoursInputEl = inputs.eq(0)
          , minutesInputEl = inputs.eq(1);
        (angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel) && this.setupMousewheelEvents(hoursInputEl, minutesInputEl),
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput,
        this.setupInputEvents(hoursInputEl, minutesInputEl)
    }
    ;
    var hourStep = timepickerConfig.hourStep;
    $attrs.hourStep && $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = parseInt(value, 10)
    });
    var minuteStep = timepickerConfig.minuteStep;
    $attrs.minuteStep && $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = parseInt(value, 10)
    }),
    $scope.showMeridian = timepickerConfig.showMeridian,
    $attrs.showMeridian && $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        if ($scope.showMeridian = !!value,
        ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate()
              , minutes = getMinutesFromTemplate();
            angular.isDefined(hours) && angular.isDefined(minutes) && (selected.setHours(hours),
            refresh())
        } else
            updateTemplate()
    }),
    this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
        var isScrollingUp = function(e) {
            e.originalEvent && (e = e.originalEvent);
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0
        };
        hoursInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours()),
            e.preventDefault()
        }),
        minutesInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes()),
            e.preventDefault()
        })
    }
    ,
    this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
        if ($scope.readonlyInput)
            return $scope.updateHours = angular.noop,
            void ($scope.updateMinutes = angular.noop);
        var invalidate = function(invalidHours, invalidMinutes) {
            ngModelCtrl.$setViewValue(null),
            ngModelCtrl.$setValidity("time", !1),
            angular.isDefined(invalidHours) && ($scope.invalidHours = invalidHours),
            angular.isDefined(invalidMinutes) && ($scope.invalidMinutes = invalidMinutes)
        };
        $scope.updateHours = function() {
            var hours = getHoursFromTemplate();
            angular.isDefined(hours) ? (selected.setHours(hours),
            refresh("h")) : invalidate(!0)
        }
        ,
        hoursInputEl.bind("blur", function(e) {
            !$scope.invalidHours && $scope.hours < 10 && $scope.$apply(function() {
                $scope.hours = pad($scope.hours)
            })
        }),
        $scope.updateMinutes = function() {
            var minutes = getMinutesFromTemplate();
            angular.isDefined(minutes) ? (selected.setMinutes(minutes),
            refresh("m")) : invalidate(void 0, !0)
        }
        ,
        minutesInputEl.bind("blur", function(e) {
            !$scope.invalidMinutes && $scope.minutes < 10 && $scope.$apply(function() {
                $scope.minutes = pad($scope.minutes)
            })
        })
    }
    ,
    this.render = function() {
        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
        isNaN(date) ? (ngModelCtrl.$setValidity("time", !1),
        $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (date && (selected = date),
        makeValid(),
        updateTemplate())
    }
    ,
    $scope.incrementHours = function() {
        addMinutes(60 * hourStep)
    }
    ,
    $scope.decrementHours = function() {
        addMinutes(60 * -hourStep)
    }
    ,
    $scope.incrementMinutes = function() {
        addMinutes(minuteStep)
    }
    ,
    $scope.decrementMinutes = function() {
        addMinutes(-minuteStep)
    }
    ,
    $scope.toggleMeridian = function() {
        addMinutes(720 * (selected.getHours() < 12 ? 1 : -1))
    }
}
]).directive("timepicker", function() {
    return {
        restrict: "EA",
        require: ["timepicker", "?^ngModel"],
        controller: "TimepickerController",
        replace: !0,
        scope: {},
        templateUrl: "template/timepicker/timepicker.html",
        link: function(scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0]
              , ngModelCtrl = ctrls[1];
            ngModelCtrl && timepickerCtrl.init(ngModelCtrl, element.find("input"))
        }
    }
}),
angular.module("ui.bootstrap.typeahead", ["ui.bootstrap.position", "ui.bootstrap.bindHtml"]).factory("typeaheadParser", ["$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match)
                throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + input + '".');
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            }
        }
    }
}
]).directive("typeahead", ["$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    return {
        require: "ngModel",
        link: function(originalScope, element, attrs, modelCtrl) {
            var hasFocus, minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1, waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = !1 !== originalScope.$eval(attrs.typeaheadEditable), isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, onSelectCallback = $parse(attrs.typeaheadOnSelect), inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = !!attrs.typeaheadAppendToBody && originalScope.$eval(attrs.typeaheadAppendToBody), focusFirst = !1 !== originalScope.$eval(attrs.typeaheadFocusFirst), $setModelValue = $parse(attrs.ngModel).assign, parserResult = typeaheadParser.parse(attrs.typeahead), scope = originalScope.$new();
            originalScope.$on("$destroy", function() {
                scope.$destroy()
            });
            var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
            element.attr({
                "aria-autocomplete": "list",
                "aria-expanded": !1,
                "aria-owns": popupId
            });
            var popUpEl = angular.element("<div typeahead-popup></div>");
            popUpEl.attr({
                id: popupId,
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                query: "query",
                position: "position"
            }),
            angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl);
            var resetMatches = function() {
                scope.matches = [],
                scope.activeIdx = -1,
                element.attr("aria-expanded", !1)
            }
              , getMatchId = function(index) {
                return popupId + "-option-" + index
            };
            scope.$watch("activeIdx", function(index) {
                index < 0 ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index))
            });
            var getMatchesAsync = function(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, !0),
                $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                    if (onCurrentRequest && hasFocus)
                        if (matches.length > 0) {
                            scope.activeIdx = focusFirst ? 0 : -1,
                            scope.matches.length = 0;
                            for (var i = 0; i < matches.length; i++)
                                locals[parserResult.itemName] = matches[i],
                                scope.matches.push({
                                    id: getMatchId(i),
                                    label: parserResult.viewMapper(scope, locals),
                                    model: matches[i]
                                });
                            scope.query = inputValue,
                            scope.position = appendToBody ? $position.offset(element) : $position.position(element),
                            scope.position.top = scope.position.top + element.prop("offsetHeight"),
                            element.attr("aria-expanded", !0)
                        } else
                            resetMatches();
                    onCurrentRequest && isLoadingSetter(originalScope, !1)
                }, function() {
                    resetMatches(),
                    isLoadingSetter(originalScope, !1)
                })
            };
            resetMatches(),
            scope.query = void 0;
            var timeoutPromise, scheduleSearchWithTimeout = function(inputValue) {
                timeoutPromise = $timeout(function() {
                    getMatchesAsync(inputValue)
                }, waitTime)
            }, cancelPreviousTimeout = function() {
                timeoutPromise && $timeout.cancel(timeoutPromise)
            };
            modelCtrl.$parsers.unshift(function(inputValue) {
                return hasFocus = !0,
                inputValue && inputValue.length >= minSearch ? waitTime > 0 ? (cancelPreviousTimeout(),
                scheduleSearchWithTimeout(inputValue)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1),
                cancelPreviousTimeout(),
                resetMatches()),
                isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0),
                inputValue)
            }),
            modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, emptyViewValue, locals = {};
                return inputFormatter ? (locals.$model = modelValue,
                inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue,
                candidateViewValue = parserResult.viewMapper(originalScope, locals),
                locals[parserResult.itemName] = void 0,
                emptyViewValue = parserResult.viewMapper(originalScope, locals),
                candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue)
            }),
            scope.select = function(activeIdx) {
                var model, item, locals = {};
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model,
                model = parserResult.modelMapper(originalScope, locals),
                $setModelValue(originalScope, model),
                modelCtrl.$setValidity("editable", !0),
                onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                }),
                resetMatches(),
                $timeout(function() {
                    element[0].focus()
                }, 0, !1)
            }
            ,
            element.bind("keydown", function(evt) {
                0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which) && (-1 != scope.activeIdx || 13 !== evt.which && 9 !== evt.which) && (evt.preventDefault(),
                40 === evt.which ? (scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length,
                scope.$digest()) : 38 === evt.which ? (scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1,
                scope.$digest()) : 13 === evt.which || 9 === evt.which ? scope.$apply(function() {
                    scope.select(scope.activeIdx)
                }) : 27 === evt.which && (evt.stopPropagation(),
                resetMatches(),
                scope.$digest()))
            }),
            element.bind("blur", function(evt) {
                hasFocus = !1
            });
            var dismissClickHandler = function(evt) {
                element[0] !== evt.target && (resetMatches(),
                scope.$digest())
            };
            $document.bind("click", dismissClickHandler),
            originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler),
                appendToBody && $popup.remove()
            });
            var $popup = $compile(popUpEl)(scope);
            appendToBody ? $document.find("body").append($popup) : element.after($popup)
        }
    }
}
]).directive("typeaheadPopup", function() {
    return {
        restrict: "EA",
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "=",
            select: "&"
        },
        replace: !0,
        templateUrl: "template/typeahead/typeahead-popup.html",
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl,
            scope.isOpen = function() {
                return scope.matches.length > 0
            }
            ,
            scope.isActive = function(matchIdx) {
                return scope.active == matchIdx
            }
            ,
            scope.selectActive = function(matchIdx) {
                scope.active = matchIdx
            }
            ,
            scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                })
            }
        }
    }
}).directive("typeaheadMatch", ["$http", "$templateCache", "$compile", "$parse", function($http, $templateCache, $compile, $parse) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $http.get(tplUrl, {
                cache: $templateCache
            }).success(function(tplContent) {
                element.replaceWith($compile(tplContent.trim())(scope))
            })
        }
    }
}
]).filter("typeaheadHighlight", function() {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1")
    }
    return function(matchItem, query) {
        return query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query),"gi"), "<strong>$&</strong>") : matchItem
    }
}),
angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html", '<div class="panel panel-default">\n  <div class="panel-heading">\n    <h4 class="panel-title">\n      <a href class="accordion-toggle" ng-click="toggleOpen()" accordion-transclude="heading"><span ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n    </h4>\n  </div>\n  <div class="panel-collapse" collapse="!isOpen">\n\t  <div class="panel-body" ng-transclude></div>\n  </div>\n</div>\n')
}
]),
angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion.html", '<div class="panel-group" ng-transclude></div>')
}
]),
angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/alert/alert.html", '<div class="alert" ng-class="[\'alert-\' + (type || \'warning\'), closeable ? \'alert-dismissable\' : null]" role="alert">\n    <button ng-show="closeable" type="button" class="close" ng-click="close()">\n        <span aria-hidden="true">&times;</span>\n        <span class="sr-only">Close</span>\n    </button>\n    <div ng-transclude></div>\n</div>\n')
}
]),
angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n    <ol class="carousel-indicators" ng-show="slides.length > 1">\n        <li ng-repeat="slide in slides track by $index" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n    </ol>\n    <div class="carousel-inner" ng-transclude></div>\n    <a class="left carousel-control" ng-click="prev()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-left"></span></a>\n    <a class="right carousel-control" ng-click="next()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-right"></span></a>\n</div>\n')
}
]),
angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/slide.html", "<div ng-class=\"{\n    'active': leaving || (active && !entering),\n    'prev': (next || active) && direction=='prev',\n    'next': (next || active) && direction=='next',\n    'right': direction=='prev',\n    'left': direction=='next'\n  }\" class=\"item text-center\" ng-transclude></div>\n")
}
]),
angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html", '<div ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n  <daypicker ng-switch-when="day" tabindex="0"></daypicker>\n  <monthpicker ng-switch-when="month" tabindex="0"></monthpicker>\n  <yearpicker ng-switch-when="year" tabindex="0"></yearpicker>\n</div>')
}
]),
angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/day.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{5 + showWeeks}}"><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr>\n      <th ng-show="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in labels track by $index" class="text-center"><small aria-label="{{label.full}}">{{label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-show="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n        <button type="button" style="width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n')
}
]),
angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/month.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n        <button type="button" style="width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n')
}
]),
angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/popup.html", '<ul class="dropdown-menu" ng-style="{display: (isOpen && \'block\') || \'none\', top: position.top+\'px\', left: position.left+\'px\'}" ng-keydown="keydown($event)">\n\t<li ng-transclude></li>\n\t<li ng-if="showButtonBar" style="padding:10px 9px 2px">\n\t\t<span class="btn-group pull-left">\n\t\t\t<button type="button" class="btn btn-sm btn-info" ng-click="select(\'today\')">{{ getText(\'current\') }}</button>\n\t\t\t<button type="button" class="btn btn-sm btn-danger" ng-click="select(null)">{{ getText(\'clear\') }}</button>\n\t\t</span>\n\t\t<button type="button" class="btn btn-sm btn-success pull-right" ng-click="close()">{{ getText(\'close\') }}</button>\n\t</li>\n</ul>\n')
}
]),
angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/year.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="3"><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n        <button type="button" style="width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n')
}
]),
angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/modal/backdrop.html", '<div class="modal-backdrop fade {{ backdropClass }}"\n     ng-class="{in: animate}"\n     ng-style="{\'z-index\': 1040 + (index && 1 || 0) + index*10}"\n></div>\n')
}
]),
angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/modal/window.html", '<div tabindex="-1" role="dialog" class="modal fade" ng-class="{in: animate}" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)">\n    <div class="modal-dialog" ng-class="{\'modal-sm\': size == \'sm\', \'modal-lg\': size == \'lg\'}"><div class="modal-content" modal-transclude></div></div>\n</div>')
}
]),
angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pager.html", '<ul class="pager">\n  <li ng-class="{disabled: noPrevious(), previous: align}"><a href ng-click="selectPage(page - 1)">{{getText(\'previous\')}}</a></li>\n  <li ng-class="{disabled: noNext(), next: align}"><a href ng-click="selectPage(page + 1)">{{getText(\'next\')}}</a></li>\n</ul>')
}
]),
angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pagination.html", '<ul class="pagination">\n  <li ng-if="boundaryLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(1)">{{getText(\'first\')}}</a></li>\n  <li ng-if="directionLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(page - 1)">{{getText(\'previous\')}}</a></li>\n  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active}"><a href ng-click="selectPage(page.number)">{{page.text}}</a></li>\n  <li ng-if="directionLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(page + 1)">{{getText(\'next\')}}</a></li>\n  <li ng-if="boundaryLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(totalPages)">{{getText(\'last\')}}</a></li>\n</ul>')
}
]),
angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n</div>\n')
}
]),
angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind="content"></div>\n</div>\n')
}
]),
angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover.html", '<div class="popover {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n      <div class="popover-content" ng-bind="content"></div>\n  </div>\n</div>\n')
}
]),
angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: percent + \'%\'}" aria-valuetext="{{percent | number:0}}%" ng-transclude></div>')
}
]),
angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progress.html", '<div class="progress" ng-transclude></div>')
}
]),
angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progressbar.html", '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: percent + \'%\'}" aria-valuetext="{{percent | number:0}}%" ng-transclude></div>\n</div>')
}
]),
angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}">\n    <i ng-repeat="r in range track by $index" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')">\n        <span class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    </i>\n</span>')
}
]),
angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}">\n  <a href ng-click="select()" tab-heading-transclude>{{heading}}</a>\n</li>\n')
}
]),
angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset.html", '<div>\n  <ul class="nav nav-{{type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane" \n         ng-repeat="tab in tabs" \n         ng-class="{active: tab.active}"\n         tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n')
}
]),
angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html", '<table>\n\t<tbody>\n\t\t<tr class="text-center">\n\t\t\t<td><a ng-click="incrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td><a ng-click="incrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n\t\t\t<td ng-show="showMeridian"></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidHours}">\n\t\t\t\t<input type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-mousewheel="incrementHours()" ng-readonly="readonlyInput" maxlength="2">\n\t\t\t</td>\n\t\t\t<td>:</td>\n\t\t\t<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n\t\t\t\t<input type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n\t\t\t</td>\n\t\t\t<td ng-show="showMeridian"><button type="button" class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n\t\t</tr>\n\t\t<tr class="text-center">\n\t\t\t<td><a ng-click="decrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n\t\t\t<td>&nbsp;</td>\n\t\t\t<td><a ng-click="decrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n\t\t\t<td ng-show="showMeridian"></td>\n\t\t</tr>\n\t</tbody>\n</table>\n')
}
]),
angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html", '<a tabindex="-1" bind-html-unsafe="match.label | typeaheadHighlight:query"></a>')
}
]),
angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen()" ng-style="{top: position.top+\'px\', left: position.left+\'px\'}" style="display: block;" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)" role="option" id="{{match.id}}">\n        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n')
}
]),
function(mod) {
    if ("object" == typeof exports && "object" == typeof module)
        module.exports = mod();
    else {
        if ("function" == typeof define && define.amd)
            return define([], mod);
        this.CodeMirror = mod()
    }
}(function() {
    "use strict";
    function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror))
            return new CodeMirror(place,options);
        this.options = options = options ? copyObj(options) : {},
        copyObj(defaults, options, !1),
        setGuttersForLineNumbers(options);
        var doc = options.value;
        "string" == typeof doc && (doc = new Doc(doc,options.mode)),
        this.doc = doc;
        var display = this.display = new Display(place,doc);
        display.wrapper.CodeMirror = this,
        updateGutters(this),
        themeChanged(this),
        options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"),
        options.autofocus && !mobile && focusInput(this),
        this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: !1,
            focused: !1,
            suppressEdits: !1,
            pasteIncoming: !1,
            cutIncoming: !1,
            draggingText: !1,
            highlight: new Delayed,
            keySeq: null
        },
        ie && ie_version < 11 && setTimeout(bind(resetInput, this, !0), 20),
        registerEventHandlers(this),
        ensureGlobalHandlers(),
        startOperation(this),
        this.curOp.forceUpdate = !0,
        attachDoc(this, doc),
        options.autofocus && !mobile || activeElt() == display.input ? setTimeout(bind(onFocus, this), 20) : onBlur(this);
        for (var opt in optionHandlers)
            optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this, options[opt], Init);
        maybeUpdateLineNumberWidth(this);
        for (var i = 0; i < initHooks.length; ++i)
            initHooks[i](this);
        endOperation(this)
    }
    function Display(place, doc) {
        var d = this
          , input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
        webkit ? input.style.width = "1000px" : input.setAttribute("wrap", "off"),
        ios && (input.style.border = "1px solid black"),
        input.setAttribute("autocorrect", "off"),
        input.setAttribute("autocapitalize", "off"),
        input.setAttribute("spellcheck", "false"),
        d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"),
        d.scrollbarH = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar"),
        d.scrollbarV = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"),
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"),
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"),
        d.lineDiv = elt("div", null, "CodeMirror-code"),
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"),
        d.cursorDiv = elt("div", null, "CodeMirror-cursors"),
        d.measure = elt("div", null, "CodeMirror-measure"),
        d.lineMeasure = elt("div", null, "CodeMirror-measure"),
        d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none"),
        d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative"),
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer"),
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;"),
        d.gutters = elt("div", null, "CodeMirror-gutters"),
        d.lineGutter = null,
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll"),
        d.scroller.setAttribute("tabIndex", "-1"),
        d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV, d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"),
        ie && ie_version < 8 && (d.gutters.style.zIndex = -1,
        d.scroller.style.paddingRight = 0),
        ios && (input.style.width = "0px"),
        webkit || (d.scroller.draggable = !0),
        khtml && (d.inputDiv.style.height = "1px",
        d.inputDiv.style.position = "absolute"),
        ie && ie_version < 8 && (d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = "18px"),
        place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper)),
        d.viewFrom = d.viewTo = doc.first,
        d.view = [],
        d.externalMeasured = null,
        d.viewOffset = 0,
        d.lastWrapHeight = d.lastWrapWidth = 0,
        d.updateLineNumbers = null,
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null,
        d.prevInput = "",
        d.alignWidgets = !1,
        d.pollingFast = !1,
        d.poll = new Delayed,
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null,
        d.inaccurateSelection = !1,
        d.maxLine = null,
        d.maxLineLength = 0,
        d.maxLineChanged = !1,
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null,
        d.shift = !1,
        d.selForContextMenu = null
    }
    function loadMode(cm) {
        cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption),
        resetModeState(cm)
    }
    function resetModeState(cm) {
        cm.doc.iter(function(line) {
            line.stateAfter && (line.stateAfter = null),
            line.styles && (line.styles = null)
        }),
        cm.doc.frontier = cm.doc.first,
        startWorker(cm, 100),
        cm.state.modeGen++,
        cm.curOp && regChange(cm)
    }
    function wrappingChanged(cm) {
        cm.options.lineWrapping ? (addClass(cm.display.wrapper, "CodeMirror-wrap"),
        cm.display.sizer.style.minWidth = "") : (rmClass(cm.display.wrapper, "CodeMirror-wrap"),
        findMaxLine(cm)),
        estimateLineHeights(cm),
        regChange(cm),
        clearCaches(cm),
        setTimeout(function() {
            updateScrollbars(cm)
        }, 100)
    }
    function estimateHeight(cm) {
        var th = textHeight(cm.display)
          , wrapping = cm.options.lineWrapping
          , perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
            if (lineIsHidden(cm.doc, line))
                return 0;
            var widgetsHeight = 0;
            if (line.widgets)
                for (var i = 0; i < line.widgets.length; i++)
                    line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
            return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th
        }
    }
    function estimateLineHeights(cm) {
        var doc = cm.doc
          , est = estimateHeight(cm);
        doc.iter(function(line) {
            var estHeight = est(line);
            estHeight != line.height && updateLineHeight(line, estHeight)
        })
    }
    function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"),
        clearCaches(cm)
    }
    function guttersChanged(cm) {
        updateGutters(cm),
        regChange(cm),
        setTimeout(function() {
            alignHorizontally(cm)
        }, 20)
    }
    function updateGutters(cm) {
        var gutters = cm.display.gutters
          , specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
            var gutterClass = specs[i]
              , gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
            "CodeMirror-linenumbers" == gutterClass && (cm.display.lineGutter = gElt,
            gElt.style.width = (cm.display.lineNumWidth || 1) + "px")
        }
        gutters.style.display = i ? "" : "none",
        updateGutterSpace(cm)
    }
    function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + "px",
        cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + "px" : 0
    }
    function lineLength(line) {
        if (0 == line.height)
            return 0;
        for (var merged, len = line.text.length, cur = line; merged = collapsedSpanAtStart(cur); ) {
            var found = merged.find(0, !0);
            cur = found.from.line,
            len += found.from.ch - found.to.ch
        }
        for (cur = line; merged = collapsedSpanAtEnd(cur); ) {
            var found = merged.find(0, !0);
            len -= cur.text.length - found.from.ch,
            cur = found.to.line,
            len += cur.text.length - found.to.ch
        }
        return len
    }
    function findMaxLine(cm) {
        var d = cm.display
          , doc = cm.doc;
        d.maxLine = getLine(doc, doc.first),
        d.maxLineLength = lineLength(d.maxLine),
        d.maxLineChanged = !0,
        doc.iter(function(line) {
            var len = lineLength(line);
            len > d.maxLineLength && (d.maxLineLength = len,
            d.maxLine = line)
        })
    }
    function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        -1 == found && options.lineNumbers ? options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]) : found > -1 && !options.lineNumbers && (options.gutters = options.gutters.slice(0),
        options.gutters.splice(found, 1))
    }
    function hScrollbarTakesSpace(cm) {
        return cm.display.scroller.clientHeight - cm.display.wrapper.clientHeight < scrollerCutOff - 3
    }
    function measureForScrollbars(cm) {
        var scroll = cm.display.scroller;
        return {
            clientHeight: scroll.clientHeight,
            barHeight: cm.display.scrollbarV.clientHeight,
            scrollWidth: scroll.scrollWidth,
            clientWidth: scroll.clientWidth,
            hScrollbarTakesSpace: hScrollbarTakesSpace(cm),
            barWidth: cm.display.scrollbarH.clientWidth,
            docHeight: Math.round(cm.doc.height + paddingVert(cm.display))
        }
    }
    function updateScrollbars(cm, measure) {
        measure || (measure = measureForScrollbars(cm));
        var d = cm.display
          , sWidth = scrollbarWidth(d.measure)
          , scrollHeight = measure.docHeight + scrollerCutOff
          , needsH = measure.scrollWidth > measure.clientWidth;
        needsH && measure.scrollWidth <= measure.clientWidth + 1 && sWidth > 0 && !measure.hScrollbarTakesSpace && (needsH = !1);
        var needsV = scrollHeight > measure.clientHeight;
        if (needsV ? (d.scrollbarV.style.display = "block",
        d.scrollbarV.style.bottom = needsH ? sWidth + "px" : "0",
        d.scrollbarV.firstChild.style.height = Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + "px") : (d.scrollbarV.style.display = "",
        d.scrollbarV.firstChild.style.height = "0"),
        needsH ? (d.scrollbarH.style.display = "block",
        d.scrollbarH.style.right = needsV ? sWidth + "px" : "0",
        d.scrollbarH.firstChild.style.width = measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth) + "px") : (d.scrollbarH.style.display = "",
        d.scrollbarH.firstChild.style.width = "0"),
        needsH && needsV ? (d.scrollbarFiller.style.display = "block",
        d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = sWidth + "px") : d.scrollbarFiller.style.display = "",
        needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block",
        d.gutterFiller.style.height = sWidth + "px",
        d.gutterFiller.style.width = d.gutters.offsetWidth + "px") : d.gutterFiller.style.display = "",
        !cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {
            if (0 === sWidth) {
                var w = mac && !mac_geMountainLion ? "12px" : "18px";
                d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;
                var barMouseDown = function(e) {
                    e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH && operation(cm, onMouseDown)(e)
                };
                on(d.scrollbarV, "mousedown", barMouseDown),
                on(d.scrollbarH, "mousedown", barMouseDown)
            }
            cm.state.checkedOverlayScrollbar = !0
        }
    }
    function visibleLines(display, doc, viewport) {
        var top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight
          , from = lineAtHeight(doc, top)
          , to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line
              , ensureTo = viewport.ensure.to.line;
            if (ensureFrom < from)
                return {
                    from: ensureFrom,
                    to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)
                };
            if (Math.min(ensureTo, doc.lastLine()) >= to)
                return {
                    from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),
                    to: ensureTo
                }
        }
        return {
            from: from,
            to: Math.max(to, from + 1)
        }
    }
    function alignHorizontally(cm) {
        var display = cm.display
          , view = display.view;
        if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
            for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, left = comp + "px", i = 0; i < view.length; i++)
                if (!view[i].hidden) {
                    cm.options.fixedGutter && view[i].gutter && (view[i].gutter.style.left = left);
                    var align = view[i].alignable;
                    if (align)
                        for (var j = 0; j < align.length; j++)
                            align[j].style.left = left
                }
            cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px")
        }
    }
    function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers)
            return !1;
        var doc = cm.doc
          , last = lineNumberFor(cm.options, doc.first + doc.size - 1)
          , display = cm.display;
        if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"))
              , innerW = test.firstChild.offsetWidth
              , padding = test.offsetWidth - innerW;
            return display.lineGutter.style.width = "",
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding),
            display.lineNumWidth = display.lineNumInnerWidth + padding,
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1,
            display.lineGutter.style.width = display.lineNumWidth + "px",
            updateGutterSpace(cm),
            !0
        }
        return !1
    }
    function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber))
    }
    function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
    }
    function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport,
        this.visible = visibleLines(display, cm.doc, viewport),
        this.editorIsHidden = !display.wrapper.offsetWidth,
        this.wrapperHeight = display.wrapper.clientHeight,
        this.wrapperWidth = display.wrapper.clientWidth,
        this.oldViewFrom = display.viewFrom,
        this.oldViewTo = display.viewTo,
        this.oldScrollerWidth = display.scroller.clientWidth,
        this.force = force,
        this.dims = getDimensions(cm)
    }
    function updateDisplayIfNeeded(cm, update) {
        var display = cm.display
          , doc = cm.doc;
        if (update.editorIsHidden)
            return resetView(cm),
            !1;
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && 0 == countDirtyView(cm))
            return !1;
        maybeUpdateLineNumberWidth(cm) && (resetView(cm),
        update.dims = getDimensions(cm));
        var end = doc.first + doc.size
          , from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)
          , to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom)),
        display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo)),
        sawCollapsedSpans && (from = visualLineNo(cm.doc, from),
        to = visualLineEndNo(cm.doc, to));
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to),
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom)),
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && 0 == toUpdate && !update.force && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo))
            return !1;
        var focused = activeElt();
        return toUpdate > 4 && (display.lineDiv.style.display = "none"),
        patchDisplay(cm, display.updateLineNumbers, update.dims),
        toUpdate > 4 && (display.lineDiv.style.display = ""),
        focused && activeElt() != focused && focused.offsetHeight && focused.focus(),
        removeChildren(display.cursorDiv),
        removeChildren(display.selectionDiv),
        different && (display.lastWrapHeight = update.wrapperHeight,
        display.lastWrapWidth = update.wrapperWidth,
        startWorker(cm, 400)),
        display.updateLineNumbers = null,
        !0
    }
    function postUpdateDisplay(cm, update) {
        for (var viewport = (update.force,
        update.viewport), first = !0; ; first = !1) {
            if (first && cm.options.lineWrapping && update.oldScrollerWidth != cm.display.scroller.clientWidth)
                !0;
            else if (!1,
            viewport && null != viewport.top && (viewport = {
                top: Math.min(cm.doc.height + paddingVert(cm.display) - scrollerCutOff - cm.display.scroller.clientHeight, viewport.top)
            }),
            update.visible = visibleLines(cm.display, cm.doc, viewport),
            update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
                break;
            if (!updateDisplayIfNeeded(cm, update))
                break;
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm),
            setDocumentHeight(cm, barMeasure),
            updateScrollbars(cm, barMeasure)
        }
        signalLater(cm, "update", cm),
        cm.display.viewFrom == update.oldViewFrom && cm.display.viewTo == update.oldViewTo || signalLater(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo)
    }
    function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm,viewport);
        if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm),
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm),
            setDocumentHeight(cm, barMeasure),
            updateScrollbars(cm, barMeasure)
        }
    }
    function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + "px",
        cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + "px"
    }
    function checkForWebkitWidthBug(cm, measure) {
        cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1 && (cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = "0px",
        cm.display.gutters.style.height = measure.docHeight + "px")
    }
    function updateHeightsInViewport(cm) {
        for (var display = cm.display, prevBottom = display.lineDiv.offsetTop, i = 0; i < display.view.length; i++) {
            var height, cur = display.view[i];
            if (!cur.hidden) {
                if (ie && ie_version < 8) {
                    var bot = cur.node.offsetTop + cur.node.offsetHeight;
                    height = bot - prevBottom,
                    prevBottom = bot
                } else {
                    var box = cur.node.getBoundingClientRect();
                    height = box.bottom - box.top
                }
                var diff = cur.line.height - height;
                if (height < 2 && (height = textHeight(display)),
                (diff > .001 || diff < -.001) && (updateLineHeight(cur.line, height),
                updateWidgetHeight(cur.line),
                cur.rest))
                    for (var j = 0; j < cur.rest.length; j++)
                        updateWidgetHeight(cur.rest[j])
            }
        }
    }
    function updateWidgetHeight(line) {
        if (line.widgets)
            for (var i = 0; i < line.widgets.length; ++i)
                line.widgets[i].height = line.widgets[i].node.offsetHeight
    }
    function getDimensions(cm) {
        for (var d = cm.display, left = {}, width = {}, gutterLeft = d.gutters.clientLeft, n = d.gutters.firstChild, i = 0; n; n = n.nextSibling,
        ++i)
            left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft,
            width[cm.options.gutters[i]] = n.clientWidth;
        return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
        }
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
        function rm(node) {
            var next = node.nextSibling;
            return webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node),
            next
        }
        for (var display = cm.display, lineNumbers = cm.options.lineNumbers, container = display.lineDiv, cur = container.firstChild, view = display.view, lineN = display.viewFrom, i = 0; i < view.length; i++) {
            var lineView = view[i];
            if (lineView.hidden)
                ;
            else if (lineView.node) {
                for (; cur != lineView.node; )
                    cur = rm(cur);
                var updateNumber = lineNumbers && null != updateNumbersFrom && updateNumbersFrom <= lineN && lineView.lineNumber;
                lineView.changes && (indexOf(lineView.changes, "gutter") > -1 && (updateNumber = !1),
                updateLineForChanges(cm, lineView, lineN, dims)),
                updateNumber && (removeChildren(lineView.lineNumber),
                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))),
                cur = lineView.node.nextSibling
            } else {
                var node = buildLineElement(cm, lineView, lineN, dims);
                container.insertBefore(node, cur)
            }
            lineN += lineView.size
        }
        for (; cur; )
            cur = rm(cur)
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            "text" == type ? updateLineText(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(lineView) : "widget" == type && updateLineWidgets(lineView, dims)
        }
        lineView.changes = null
    }
    function ensureLineWrapped(lineView) {
        return lineView.node == lineView.text && (lineView.node = elt("div", null, null, "position: relative"),
        lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text),
        lineView.node.appendChild(lineView.text),
        ie && ie_version < 8 && (lineView.node.style.zIndex = 2)),
        lineView.node
    }
    function updateLineBackground(lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls && (cls += " CodeMirror-linebackground"),
        lineView.background)
            cls ? lineView.background.className = cls : (lineView.background.parentNode.removeChild(lineView.background),
            lineView.background = null);
        else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild)
        }
    }
    function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        return ext && ext.line == lineView.line ? (cm.display.externalMeasured = null,
        lineView.measure = ext.measure,
        ext.built) : buildLineContent(cm, lineView)
    }
    function updateLineText(cm, lineView) {
        var cls = lineView.text.className
          , built = getLineContent(cm, lineView);
        lineView.text == lineView.node && (lineView.node = built.pre),
        lineView.text.parentNode.replaceChild(built.pre, lineView.text),
        lineView.text = built.pre,
        built.bgClass != lineView.bgClass || built.textClass != lineView.textClass ? (lineView.bgClass = built.bgClass,
        lineView.textClass = built.textClass,
        updateLineClasses(lineView)) : cls && (lineView.text.className = cls)
    }
    function updateLineClasses(lineView) {
        updateLineBackground(lineView),
        lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || ""
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
        lineView.gutter && (lineView.node.removeChild(lineView.gutter),
        lineView.gutter = null);
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
            var wrap = ensureLineWrapped(lineView)
              , gutterWrap = lineView.gutter = wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"), lineView.text);
            if (lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass),
            !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"))),
            markers)
                for (var k = 0; k < cm.options.gutters.length; ++k) {
                    var id = cm.options.gutters[k]
                      , found = markers.hasOwnProperty(id) && markers[id];
                    found && gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"))
                }
        }
    }
    function updateLineWidgets(lineView, dims) {
        lineView.alignable && (lineView.alignable = null);
        for (var next, node = lineView.node.firstChild; node; node = next) {
            var next = node.nextSibling;
            "CodeMirror-linewidget" == node.className && lineView.node.removeChild(node)
        }
        insertLineWidgets(lineView, dims)
    }
    function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        return lineView.text = lineView.node = built.pre,
        built.bgClass && (lineView.bgClass = built.bgClass),
        built.textClass && (lineView.textClass = built.textClass),
        updateLineClasses(lineView),
        updateLineGutter(cm, lineView, lineN, dims),
        insertLineWidgets(lineView, dims),
        lineView.node
    }
    function insertLineWidgets(lineView, dims) {
        if (insertLineWidgetsFor(lineView.line, lineView, dims, !0),
        lineView.rest)
            for (var i = 0; i < lineView.rest.length; i++)
                insertLineWidgetsFor(lineView.rest[i], lineView, dims, !1)
    }
    function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
        if (line.widgets)
            for (var wrap = ensureLineWrapped(lineView), i = 0, ws = line.widgets; i < ws.length; ++i) {
                var widget = ws[i]
                  , node = elt("div", [widget.node], "CodeMirror-linewidget");
                widget.handleMouseEvents || (node.ignoreEvents = !0),
                positionLineWidget(widget, node, lineView, dims),
                allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node),
                signalLater(widget, "redraw")
            }
    }
    function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px",
            widget.coverGutter || (width -= dims.gutterTotalWidth,
            node.style.paddingLeft = dims.gutterTotalWidth + "px"),
            node.style.width = width + "px"
        }
        widget.coverGutter && (node.style.zIndex = 5,
        node.style.position = "relative",
        widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"))
    }
    function copyPos(x) {
        return Pos(x.line, x.ch)
    }
    function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a
    }
    function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b
    }
    function Selection(ranges, primIndex) {
        this.ranges = ranges,
        this.primIndex = primIndex
    }
    function Range(anchor, head) {
        this.anchor = anchor,
        this.head = head
    }
    function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function(a, b) {
            return cmp(a.from(), b.from())
        }),
        primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
            var cur = ranges[i]
              , prev = ranges[i - 1];
            if (cmp(prev.to(), cur.from()) >= 0) {
                var from = minPos(prev.from(), cur.from())
                  , to = maxPos(prev.to(), cur.to())
                  , inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                i <= primIndex && --primIndex,
                ranges.splice(--i, 2, new Range(inv ? to : from,inv ? from : to))
            }
        }
        return new Selection(ranges,primIndex)
    }
    function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor,head || anchor)],0)
    }
    function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))
    }
    function clipPos(doc, pos) {
        if (pos.line < doc.first)
            return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        return pos.line > last ? Pos(last, getLine(doc, last).text.length) : clipToLen(pos, getLine(doc, pos.line).text.length)
    }
    function clipToLen(pos, linelen) {
        var ch = pos.ch;
        return null == ch || ch > linelen ? Pos(pos.line, linelen) : ch < 0 ? Pos(pos.line, 0) : pos
    }
    function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size
    }
    function clipPosArray(doc, array) {
        for (var out = [], i = 0; i < array.length; i++)
            out[i] = clipPos(doc, array[i]);
        return out
    }
    function extendRange(doc, range, head, other) {
        if (doc.cm && doc.cm.display.shift || doc.extend) {
            var anchor = range.anchor;
            if (other) {
                var posBefore = cmp(head, anchor) < 0;
                posBefore != cmp(other, anchor) < 0 ? (anchor = head,
                head = other) : posBefore != cmp(head, other) < 0 && (head = other)
            }
            return new Range(anchor,head)
        }
        return new Range(other || head,head)
    }
    function extendSelection(doc, head, other, options) {
        setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)],0), options)
    }
    function extendSelections(doc, heads, options) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
            out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
        setSelection(doc, normalizeSelection(out, doc.sel.primIndex), options)
    }
    function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range,
        setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
    }
    function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options)
    }
    function filterSelectionChange(doc, sel) {
        var obj = {
            ranges: sel.ranges,
            update: function(ranges) {
                this.ranges = [];
                for (var i = 0; i < ranges.length; i++)
                    this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),clipPos(doc, ranges[i].head))
            }
        };
        return signal(doc, "beforeSelectionChange", doc, obj),
        doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj),
        obj.ranges != sel.ranges ? normalizeSelection(obj.ranges, obj.ranges.length - 1) : sel
    }
    function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done
          , last = lst(done);
        last && last.ranges ? (done[done.length - 1] = sel,
        setSelectionNoUndo(doc, sel, options)) : setSelection(doc, sel, options)
    }
    function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options),
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
    }
    function setSelectionNoUndo(doc, sel, options) {
        (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = filterSelectionChange(doc, sel)),
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1), !0)),
        options && !1 === options.scroll || !doc.cm || ensureCursorVisible(doc.cm)
    }
    function setSelectionInner(doc, sel) {
        sel.equals(doc.sel) || (doc.sel = sel,
        doc.cm && (doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = !0,
        signalCursorActivity(doc.cm)),
        signalLater(doc, "cursorActivity", doc))
    }
    function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, !1), sel_dontScroll)
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
        for (var out, i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i]
              , newAnchor = skipAtomic(doc, range.anchor, bias, mayClear)
              , newHead = skipAtomic(doc, range.head, bias, mayClear);
            (out || newAnchor != range.anchor || newHead != range.head) && (out || (out = sel.ranges.slice(0, i)),
            out[i] = new Range(newAnchor,newHead))
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel
    }
    function skipAtomic(doc, pos, bias, mayClear) {
        var flipped = !1
          , curPos = pos
          , dir = bias || 1;
        doc.cantEdit = !1;
        search: for (; ; ) {
            var line = getLine(doc, curPos.line);
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans.length; ++i) {
                    var sp = line.markedSpans[i]
                      , m = sp.marker;
                    if ((null == sp.from || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                        if (mayClear && (signal(m, "beforeCursorEnter"),
                        m.explicitlyCleared)) {
                            if (line.markedSpans) {
                                --i;
                                continue
                            }
                            break
                        }
                        if (!m.atomic)
                            continue;
                        var newPos = m.find(dir < 0 ? -1 : 1);
                        if (0 == cmp(newPos, curPos) && (newPos.ch += dir,
                        newPos.ch < 0 ? newPos = newPos.line > doc.first ? clipPos(doc, Pos(newPos.line - 1)) : null : newPos.ch > line.text.length && (newPos = newPos.line < doc.first + doc.size - 1 ? Pos(newPos.line + 1, 0) : null),
                        !newPos)) {
                            if (flipped)
                                return mayClear ? (doc.cantEdit = !0,
                                Pos(doc.first, 0)) : skipAtomic(doc, pos, bias, !0);
                            flipped = !0,
                            newPos = pos,
                            dir = -dir
                        }
                        curPos = newPos;
                        continue search
                    }
                }
            return curPos
        }
    }
    function drawSelection(cm) {
        for (var display = cm.display, doc = cm.doc, result = {}, curFragment = result.cursors = document.createDocumentFragment(), selFragment = result.selection = document.createDocumentFragment(), i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i]
              , collapsed = range.empty();
            (collapsed || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range, curFragment),
            collapsed || drawSelectionRange(cm, range, selFragment)
        }
        if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div")
              , wrapOff = display.wrapper.getBoundingClientRect()
              , lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)),
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left))
        }
        return result
    }
    function showSelection(cm, drawn) {
        removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors),
        removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection),
        null != drawn.teTop && (cm.display.inputDiv.style.top = drawn.teTop + "px",
        cm.display.inputDiv.style.left = drawn.teLeft + "px")
    }
    function updateSelection(cm) {
        showSelection(cm, drawSelection(cm))
    }
    function drawSelectionCursor(cm, range, output) {
        var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine)
          , cursor = output.appendChild(elt("div", " ", "CodeMirror-cursor"));
        if (cursor.style.left = pos.left + "px",
        cursor.style.top = pos.top + "px",
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px",
        pos.other) {
            var otherCursor = output.appendChild(elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "",
            otherCursor.style.left = pos.other.left + "px",
            otherCursor.style.top = pos.other.top + "px",
            otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px"
        }
    }
    function drawSelectionRange(cm, range, output) {
        function add(left, top, width, bottom) {
            top < 0 && (top = 0),
            top = Math.round(top),
            bottom = Math.round(bottom),
            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px; top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px; height: " + (bottom - top) + "px"))
        }
        function drawForLine(line, fromArg, toArg) {
            function coords(ch, bias) {
                return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
            }
            var start, end, lineObj = getLine(doc, line), lineLen = lineObj.text.length;
            return iterateBidiSections(getOrder(lineObj), fromArg || 0, null == toArg ? lineLen : toArg, function(from, to, dir) {
                var rightPos, left, right, leftPos = coords(from, "left");
                if (from == to)
                    rightPos = leftPos,
                    left = right = leftPos.left;
                else {
                    if (rightPos = coords(to - 1, "right"),
                    "rtl" == dir) {
                        var tmp = leftPos;
                        leftPos = rightPos,
                        rightPos = tmp
                    }
                    left = leftPos.left,
                    right = rightPos.right
                }
                null == fromArg && 0 == from && (left = leftSide),
                rightPos.top - leftPos.top > 3 && (add(left, leftPos.top, null, leftPos.bottom),
                left = leftSide,
                leftPos.bottom < rightPos.top && add(left, leftPos.bottom, null, rightPos.top)),
                null == toArg && to == lineLen && (right = rightSide),
                (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) && (start = leftPos),
                (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) && (end = rightPos),
                left < leftSide + 1 && (left = leftSide),
                add(left, rightPos.top, right - left, rightPos.bottom)
            }),
            {
                start: start,
                end: end
            }
        }
        var display = cm.display
          , doc = cm.doc
          , fragment = document.createDocumentFragment()
          , padding = paddingH(cm.display)
          , leftSide = padding.left
          , rightSide = display.lineSpace.offsetWidth - padding.right
          , sFrom = range.from()
          , sTo = range.to();
        if (sFrom.line == sTo.line)
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        else {
            var fromLine = getLine(doc, sFrom.line)
              , toLine = getLine(doc, sTo.line)
              , singleVLine = visualLine(fromLine) == visualLine(toLine)
              , leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end
              , rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            singleVLine && (leftEnd.top < rightStart.top - 2 ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom),
            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)) : add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)),
            leftEnd.bottom < rightStart.top && add(leftSide, leftEnd.bottom, null, rightStart.top)
        }
        output.appendChild(fragment)
    }
    function restartBlink(cm) {
        if (cm.state.focused) {
            var display = cm.display;
            clearInterval(display.blinker);
            var on = !0;
            display.cursorDiv.style.visibility = "",
            cm.options.cursorBlinkRate > 0 ? display.blinker = setInterval(function() {
                display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"
            }, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden")
        }
    }
    function startWorker(cm, time) {
        cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm))
    }
    function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first && (doc.frontier = doc.first),
        !(doc.frontier >= cm.display.viewTo)) {
            var end = +new Date + cm.options.workTime
              , state = copyState(doc.mode, getStateBefore(cm, doc.frontier))
              , changedLines = [];
            doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
                if (doc.frontier >= cm.display.viewFrom) {
                    var oldStyles = line.styles
                      , highlighted = highlightLine(cm, line, state, !0);
                    line.styles = highlighted.styles;
                    var oldCls = line.styleClasses
                      , newCls = highlighted.classes;
                    newCls ? line.styleClasses = newCls : oldCls && (line.styleClasses = null);
                    for (var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass), i = 0; !ischange && i < oldStyles.length; ++i)
                        ischange = oldStyles[i] != line.styles[i];
                    ischange && changedLines.push(doc.frontier),
                    line.stateAfter = copyState(doc.mode, state)
                } else
                    processLine(cm, line.text, state),
                    line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
                if (++doc.frontier,
                +new Date > end)
                    return startWorker(cm, cm.options.workDelay),
                    !0
            }),
            changedLines.length && runInOp(cm, function() {
                for (var i = 0; i < changedLines.length; i++)
                    regLineChange(cm, changedLines[i], "text")
            })
        }
    }
    function findStartLine(cm, n, precise) {
        for (var minindent, minline, doc = cm.doc, lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; search > lim; --search) {
            if (search <= doc.first)
                return doc.first;
            var line = getLine(doc, search - 1);
            if (line.stateAfter && (!precise || search <= doc.frontier))
                return search;
            var indented = countColumn(line.text, null, cm.options.tabSize);
            (null == minline || minindent > indented) && (minline = search - 1,
            minindent = indented)
        }
        return minline
    }
    function getStateBefore(cm, n, precise) {
        var doc = cm.doc
          , display = cm.display;
        if (!doc.mode.startState)
            return !0;
        var pos = findStartLine(cm, n, precise)
          , state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        return state = state ? copyState(doc.mode, state) : startState(doc.mode),
        doc.iter(pos, n, function(line) {
            processLine(cm, line.text, state);
            var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
            line.stateAfter = save ? copyState(doc.mode, state) : null,
            ++pos
        }),
        precise && (doc.frontier = pos),
        state
    }
    function paddingTop(display) {
        return display.lineSpace.offsetTop
    }
    function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight
    }
    function paddingH(display) {
        if (display.cachedPaddingH)
            return display.cachedPaddingH;
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x"))
          , style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle
          , data = {
            left: parseInt(style.paddingLeft),
            right: parseInt(style.paddingRight)
        };
        return isNaN(data.left) || isNaN(data.right) || (display.cachedPaddingH = data),
        data
    }
    function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping
          , curWidth = wrapping && cm.display.scroller.clientWidth;
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
                lineView.measure.width = curWidth;
                for (var rects = lineView.text.firstChild.getClientRects(), i = 0; i < rects.length - 1; i++) {
                    var cur = rects[i]
                      , next = rects[i + 1];
                    Math.abs(cur.bottom - next.bottom) > 2 && heights.push((cur.bottom + next.top) / 2 - rect.top)
                }
            }
            heights.push(rect.bottom - rect.top)
        }
    }
    function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line)
            return {
                map: lineView.measure.map,
                cache: lineView.measure.cache
            };
        for (var i = 0; i < lineView.rest.length; i++)
            if (lineView.rest[i] == line)
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
        for (var i = 0; i < lineView.rest.length; i++)
            if (lineNo(lineView.rest[i]) > lineN)
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i],
                    before: !0
                }
    }
    function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line)
          , view = cm.display.externalMeasured = new LineView(cm.doc,line,lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        return view.text = built.pre,
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre),
        view
    }
    function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
    }
    function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
            return cm.display.view[findViewIndex(cm, lineN)];
        var ext = cm.display.externalMeasured;
        return ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size ? ext : void 0
    }
    function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line)
          , view = findViewForLine(cm, lineN);
        view && !view.text ? view = null : view && view.changes && updateLineForChanges(cm, view, lineN, getDimensions(cm)),
        view || (view = updateExternalMeasurement(cm, line));
        var info = mapFromLineView(view, line, lineN);
        return {
            line: line,
            view: view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: !1
        }
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        prepared.before && (ch = -1);
        var found, key = ch + (bias || "");
        return prepared.cache.hasOwnProperty(key) ? found = prepared.cache[key] : (prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect()),
        prepared.hasHeights || (ensureLineHeights(cm, prepared.view, prepared.rect),
        prepared.hasHeights = !0),
        found = measureCharInner(cm, prepared, ch, bias),
        found.bogus || (prepared.cache[key] = found)),
        {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
        }
    }
    function measureCharInner(cm, prepared, ch, bias) {
        for (var node, start, end, collapse, map = prepared.map, i = 0; i < map.length; i += 3) {
            var mStart = map[i]
              , mEnd = map[i + 1];
            if (ch < mStart ? (start = 0,
            end = 1,
            collapse = "left") : ch < mEnd ? (start = ch - mStart,
            end = start + 1) : (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) && (end = mEnd - mStart,
            start = end - 1,
            ch >= mEnd && (collapse = "right")),
            null != start) {
                if (node = map[i + 2],
                mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias),
                "left" == bias && 0 == start)
                    for (; i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft; )
                        node = map[2 + (i -= 3)],
                        collapse = "left";
                if ("right" == bias && start == mEnd - mStart)
                    for (; i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft; )
                        node = map[(i += 3) + 2],
                        collapse = "right";
                break
            }
        }
        var rect;
        if (3 == node.nodeType) {
            for (var i = 0; i < 4; i++) {
                for (; start && isExtendingChar(prepared.line.text.charAt(mStart + start)); )
                    --start;
                for (; mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end)); )
                    ++end;
                if (ie && ie_version < 9 && 0 == start && end == mEnd - mStart)
                    rect = node.parentNode.getBoundingClientRect();
                else if (ie && cm.options.lineWrapping) {
                    var rects = range(node, start, end).getClientRects();
                    rect = rects.length ? rects["right" == bias ? rects.length - 1 : 0] : nullRect
                } else
                    rect = range(node, start, end).getBoundingClientRect() || nullRect;
                if (rect.left || rect.right || 0 == start)
                    break;
                end = start,
                start -= 1,
                collapse = "right"
            }
            ie && ie_version < 11 && (rect = maybeUpdateRectForZooming(cm.display.measure, rect))
        } else {
            start > 0 && (collapse = bias = "right");
            var rects;
            rect = cm.options.lineWrapping && (rects = node.getClientRects()).length > 1 ? rects["right" == bias ? rects.length - 1 : 0] : node.getBoundingClientRect()
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            rect = rSpan ? {
                left: rSpan.left,
                right: rSpan.left + charWidth(cm.display),
                top: rSpan.top,
                bottom: rSpan.bottom
            } : nullRect
        }
        for (var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top, mid = (rtop + rbot) / 2, heights = prepared.view.measure.heights, i = 0; i < heights.length - 1 && !(mid < heights[i]); i++)
            ;
        var top = i ? heights[i - 1] : 0
          , bot = heights[i]
          , result = {
            left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left,
            right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left,
            top: top,
            bottom: bot
        };
        return rect.left || rect.right || (result.bogus = !0),
        cm.options.singleCursorHeightPerLine || (result.rtop = rtop,
        result.rbottom = rbot),
        result
    }
    function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
            return rect;
        var scaleX = screen.logicalXDPI / screen.deviceXDPI
          , scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
        }
    }
    function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure && (lineView.measure.cache = {},
        lineView.measure.heights = null,
        lineView.rest))
            for (var i = 0; i < lineView.rest.length; i++)
                lineView.measure.caches[i] = {}
    }
    function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null,
        removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++)
            clearLineMeasurementCacheFor(cm.display.view[i])
    }
    function clearCaches(cm) {
        clearLineMeasurementCache(cm),
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null,
        cm.options.lineWrapping || (cm.display.maxLineChanged = !0),
        cm.display.lineNumChars = null
    }
    function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft
    }
    function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop
    }
    function intoCoordSystem(cm, lineObj, rect, context) {
        if (lineObj.widgets)
            for (var i = 0; i < lineObj.widgets.length; ++i)
                if (lineObj.widgets[i].above) {
                    var size = widgetHeight(lineObj.widgets[i]);
                    rect.top += size,
                    rect.bottom += size
                }
        if ("line" == context)
            return rect;
        context || (context = "local");
        var yOff = heightAtLine(lineObj);
        if ("local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset,
        "page" == context || "window" == context) {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
            var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
            rect.left += xOff,
            rect.right += xOff
        }
        return rect.top += yOff,
        rect.bottom += yOff,
        rect
    }
    function fromCoordSystem(cm, coords, context) {
        if ("div" == context)
            return coords;
        var left = coords.left
          , top = coords.top;
        if ("page" == context)
            left -= pageScrollX(),
            top -= pageScrollY();
        else if ("local" == context || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left,
            top += localBox.top
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
            left: left - lineSpaceBox.left,
            top: top - lineSpaceBox.top
        }
    }
    function charCoords(cm, pos, context, lineObj, bias) {
        return lineObj || (lineObj = getLine(cm.doc, pos.line)),
        intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        function get(ch, right) {
            var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
            return right ? m.left = m.right : m.right = m.left,
            intoCoordSystem(cm, lineObj, m, context)
        }
        function getBidi(ch, partPos) {
            var part = order[partPos]
              , right = part.level % 2;
            return ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level ? (part = order[--partPos],
            ch = bidiRight(part) - (part.level % 2 ? 0 : 1),
            right = !0) : ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level && (part = order[++partPos],
            ch = bidiLeft(part) - part.level % 2,
            right = !1),
            right && ch == part.to && ch > part.from ? get(ch - 1) : get(ch, right)
        }
        lineObj = lineObj || getLine(cm.doc, pos.line),
        preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
        var order = getOrder(lineObj)
          , ch = pos.ch;
        if (!order)
            return get(ch);
        var partPos = getBidiPartAt(order, ch)
          , val = getBidi(ch, partPos);
        return null != bidiOther && (val.other = getBidi(ch, bidiOther)),
        val
    }
    function estimateCoords(cm, pos) {
        var left = 0
          , pos = clipPos(cm.doc, pos);
        cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch);
        var lineObj = getLine(cm.doc, pos.line)
          , top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {
            left: left,
            right: left,
            top: top,
            bottom: top + lineObj.height
        }
    }
    function PosWithInfo(line, ch, outside, xRel) {
        var pos = Pos(line, ch);
        return pos.xRel = xRel,
        outside && (pos.outside = !0),
        pos
    }
    function coordsChar(cm, x, y) {
        var doc = cm.doc;
        if ((y += cm.display.viewOffset) < 0)
            return PosWithInfo(doc.first, 0, !0, -1);
        var lineN = lineAtHeight(doc, y)
          , last = doc.first + doc.size - 1;
        if (lineN > last)
            return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, !0, 1);
        x < 0 && (x = 0);
        for (var lineObj = getLine(doc, lineN); ; ) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y)
              , merged = collapsedSpanAtEnd(lineObj)
              , mergedPos = merged && merged.find(0, !0);
            if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
                return found;
            lineN = lineNo(lineObj = mergedPos.to.line)
        }
    }
    function coordsCharInner(cm, lineObj, lineNo, x, y) {
        function getX(ch) {
            var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
            return wrongLine = !0,
            innerOff > sp.bottom ? sp.left - adjust : innerOff < sp.top ? sp.left + adjust : (wrongLine = !1,
            sp.left)
        }
        var innerOff = y - heightAtLine(lineObj)
          , wrongLine = !1
          , adjust = 2 * cm.display.wrapper.clientWidth
          , preparedMeasure = prepareMeasureForLine(cm, lineObj)
          , bidi = getOrder(lineObj)
          , dist = lineObj.text.length
          , from = lineLeft(lineObj)
          , to = lineRight(lineObj)
          , fromX = getX(from)
          , fromOutside = wrongLine
          , toX = getX(to)
          , toOutside = wrongLine;
        if (x > toX)
            return PosWithInfo(lineNo, to, toOutside, 1);
        for (; ; ) {
            if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
                for (var ch = x < fromX || x - fromX <= toX - x ? from : to, xDiff = x - (ch == from ? fromX : toX); isExtendingChar(lineObj.text.charAt(ch)); )
                    ++ch;
                return PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0)
            }
            var step = Math.ceil(dist / 2)
              , middle = from + step;
            if (bidi) {
                middle = from;
                for (var i = 0; i < step; ++i)
                    middle = moveVisually(lineObj, middle, 1)
            }
            var middleX = getX(middle);
            middleX > x ? (to = middle,
            toX = middleX,
            (toOutside = wrongLine) && (toX += 1e3),
            dist = step) : (from = middle,
            fromX = middleX,
            fromOutside = wrongLine,
            dist -= step)
        }
    }
    function textHeight(display) {
        if (null != display.cachedTextHeight)
            return display.cachedTextHeight;
        if (null == measureText) {
            measureText = elt("pre");
            for (var i = 0; i < 49; ++i)
                measureText.appendChild(document.createTextNode("x")),
                measureText.appendChild(elt("br"));
            measureText.appendChild(document.createTextNode("x"))
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        return height > 3 && (display.cachedTextHeight = height),
        removeChildren(display.measure),
        height || 1
    }
    function charWidth(display) {
        if (null != display.cachedCharWidth)
            return display.cachedCharWidth;
        var anchor = elt("span", "xxxxxxxxxx")
          , pre = elt("pre", [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect()
          , width = (rect.right - rect.left) / 10;
        return width > 2 && (display.cachedCharWidth = width),
        width || 10
    }
    function startOperation(cm) {
        cm.curOp = {
            cm: cm,
            viewChanged: !1,
            startHeight: cm.doc.height,
            forceUpdate: !1,
            updateInput: null,
            typing: !1,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: !1,
            updateMaxLine: !1,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            id: ++nextOpId
        },
        operationGroup ? operationGroup.ops.push(cm.curOp) : cm.curOp.ownsGroup = operationGroup = {
            ops: [cm.curOp],
            delayedCallbacks: []
        }
    }
    function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks
          , i = 0;
        do {
            for (; i < callbacks.length; i++)
                callbacks[i]();
            for (var j = 0; j < group.ops.length; j++) {
                var op = group.ops[j];
                if (op.cursorActivityHandlers)
                    for (; op.cursorActivityCalled < op.cursorActivityHandlers.length; )
                        op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm)
            }
        } while (i < callbacks.length)
    }
    function endOperation(cm) {
        var op = cm.curOp
          , group = op.ownsGroup;
        if (group)
            try {
                fireCallbacksForOps(group)
            } finally {
                operationGroup = null;
                for (var i = 0; i < group.ops.length; i++)
                    group.ops[i].cm.curOp = null;
                endOperations(group)
            }
    }
    function endOperations(group) {
        for (var ops = group.ops, i = 0; i < ops.length; i++)
            endOperation_R1(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_W1(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_R2(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_W2(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_finish(ops[i])
    }
    function endOperation_R1(op) {
        var cm = op.cm
          , display = cm.display;
        op.updateMaxLine && findMaxLine(cm),
        op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping,
        op.update = op.mustUpdate && new DisplayUpdate(cm,op.mustUpdate && {
            top: op.scrollTop,
            ensure: op.scrollToPos
        },op.forceUpdate)
    }
    function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
    }
    function endOperation_R2(op) {
        var cm = op.cm
          , display = cm.display;
        op.updatedDisplay && updateHeightsInViewport(cm),
        op.barMeasure = measureForScrollbars(cm),
        display.maxLineChanged && !cm.options.lineWrapping && (op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3,
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo + scrollerCutOff - display.scroller.clientWidth)),
        (op.updatedDisplay || op.selectionChanged) && (op.newSelectionNodes = drawSelection(cm))
    }
    function endOperation_W2(op) {
        var cm = op.cm;
        null != op.adjustWidthTo && (cm.display.sizer.style.minWidth = op.adjustWidthTo + "px",
        op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), !0),
        cm.display.maxLineChanged = !1),
        op.newSelectionNodes && showSelection(cm, op.newSelectionNodes),
        op.updatedDisplay && setDocumentHeight(cm, op.barMeasure),
        (op.updatedDisplay || op.startHeight != cm.doc.height) && updateScrollbars(cm, op.barMeasure),
        op.selectionChanged && restartBlink(cm),
        cm.state.focused && op.updateInput && resetInput(cm, op.typing)
    }
    function endOperation_finish(op) {
        var cm = op.cm
          , display = cm.display
          , doc = cm.doc;
        if (null != op.adjustWidthTo && Math.abs(op.barMeasure.scrollWidth - cm.display.scroller.scrollWidth) > 1 && updateScrollbars(cm),
        op.updatedDisplay && postUpdateDisplay(cm, op.update),
        null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null),
        null != op.scrollTop && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
            var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
            display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top
        }
        if (null != op.scrollLeft && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
            var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
            display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left,
            alignHorizontally(cm)
        }
        if (op.scrollToPos) {
            var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            op.scrollToPos.isCursor && cm.state.focused && maybeScrollWindow(cm, coords)
        }
        var hidden = op.maybeHiddenMarkers
          , unhidden = op.maybeUnhiddenMarkers;
        if (hidden)
            for (var i = 0; i < hidden.length; ++i)
                hidden[i].lines.length || signal(hidden[i], "hide");
        if (unhidden)
            for (var i = 0; i < unhidden.length; ++i)
                unhidden[i].lines.length && signal(unhidden[i], "unhide");
        display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop),
        op.updatedDisplay && webkit && (cm.options.lineWrapping && checkForWebkitWidthBug(cm, op.barMeasure),
        op.barMeasure.scrollWidth > op.barMeasure.clientWidth && op.barMeasure.scrollWidth < op.barMeasure.clientWidth + 1 && !hScrollbarTakesSpace(cm) && updateScrollbars(cm)),
        op.changeObjs && signal(cm, "changes", cm, op.changeObjs)
    }
    function runInOp(cm, f) {
        if (cm.curOp)
            return f();
        startOperation(cm);
        try {
            return f()
        } finally {
            endOperation(cm)
        }
    }
    function operation(cm, f) {
        return function() {
            if (cm.curOp)
                return f.apply(cm, arguments);
            startOperation(cm);
            try {
                return f.apply(cm, arguments)
            } finally {
                endOperation(cm)
            }
        }
    }
    function methodOp(f) {
        return function() {
            if (this.curOp)
                return f.apply(this, arguments);
            startOperation(this);
            try {
                return f.apply(this, arguments)
            } finally {
                endOperation(this)
            }
        }
    }
    function docMethodOp(f) {
        return function() {
            var cm = this.cm;
            if (!cm || cm.curOp)
                return f.apply(this, arguments);
            startOperation(cm);
            try {
                return f.apply(this, arguments)
            } finally {
                endOperation(cm)
            }
        }
    }
    function LineView(doc, line, lineN) {
        this.line = line,
        this.rest = visualLineContinued(line),
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1,
        this.node = this.text = null,
        this.hidden = lineIsHidden(doc, line)
    }
    function buildViewArray(cm, from, to) {
        for (var nextPos, array = [], pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc,getLine(cm.doc, pos),pos);
            nextPos = pos + view.size,
            array.push(view)
        }
        return array
    }
    function regChange(cm, from, to, lendiff) {
        null == from && (from = cm.doc.first),
        null == to && (to = cm.doc.first + cm.doc.size),
        lendiff || (lendiff = 0);
        var display = cm.display;
        if (lendiff && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from),
        cm.curOp.viewChanged = !0,
        from >= display.viewTo)
            sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm);
        else if (to <= display.viewFrom)
            sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom ? resetView(cm) : (display.viewFrom += lendiff,
            display.viewTo += lendiff);
        else if (from <= display.viewFrom && to >= display.viewTo)
            resetView(cm);
        else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            cut ? (display.view = display.view.slice(cut.index),
            display.viewFrom = cut.lineN,
            display.viewTo += lendiff) : resetView(cm)
        } else if (to >= display.viewTo) {
            var cut = viewCuttingPoint(cm, from, from, -1);
            cut ? (display.view = display.view.slice(0, cut.index),
            display.viewTo = cut.lineN) : resetView(cm)
        } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1)
              , cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            cutTop && cutBot ? (display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index)),
            display.viewTo += lendiff) : resetView(cm)
        }
        var ext = display.externalMeasured;
        ext && (to < ext.lineN ? ext.lineN += lendiff : from < ext.lineN + ext.size && (display.externalMeasured = null))
    }
    function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = !0;
        var display = cm.display
          , ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null),
        !(line < display.viewFrom || line >= display.viewTo)) {
            var lineView = display.view[findViewIndex(cm, line)];
            if (null != lineView.node) {
                var arr = lineView.changes || (lineView.changes = []);
                -1 == indexOf(arr, type) && arr.push(type)
            }
        }
    }
    function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first,
        cm.display.view = [],
        cm.display.viewOffset = 0
    }
    function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo)
            return null;
        if ((n -= cm.display.viewFrom) < 0)
            return null;
        for (var view = cm.display.view, i = 0; i < view.length; i++)
            if ((n -= view[i].size) < 0)
                return i
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
        var diff, index = findViewIndex(cm, oldN), view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
            return {
                index: index,
                lineN: newN
            };
        for (var i = 0, n = cm.display.viewFrom; i < index; i++)
            n += view[i].size;
        if (n != oldN) {
            if (dir > 0) {
                if (index == view.length - 1)
                    return null;
                diff = n + view[index].size - oldN,
                index++
            } else
                diff = n - oldN;
            oldN += diff,
            newN += diff
        }
        for (; visualLineNo(cm.doc, newN) != newN; ) {
            if (index == (dir < 0 ? 0 : view.length - 1))
                return null;
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size,
            index += dir
        }
        return {
            index: index,
            lineN: newN
        }
    }
    function adjustView(cm, from, to) {
        var display = cm.display;
        0 == display.view.length || from >= display.viewTo || to <= display.viewFrom ? (display.view = buildViewArray(cm, from, to),
        display.viewFrom = from) : (display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from))),
        display.viewFrom = from,
        display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))),
        display.viewTo = to
    }
    function countDirtyView(cm) {
        for (var view = cm.display.view, dirty = 0, i = 0; i < view.length; i++) {
            var lineView = view[i];
            lineView.hidden || lineView.node && !lineView.changes || ++dirty
        }
        return dirty
    }
    function slowPoll(cm) {
        cm.display.pollingFast || cm.display.poll.set(cm.options.pollInterval, function() {
            readInput(cm),
            cm.state.focused && slowPoll(cm)
        })
    }
    function fastPoll(cm) {
        function p() {
            readInput(cm) || missed ? (cm.display.pollingFast = !1,
            slowPoll(cm)) : (missed = !0,
            cm.display.poll.set(60, p))
        }
        var missed = !1;
        cm.display.pollingFast = !0,
        cm.display.poll.set(20, p)
    }
    function readInput(cm) {
        var input = cm.display.input
          , prevInput = cm.display.prevInput
          , doc = cm.doc;
        if (!cm.state.focused || hasSelection(input) && !prevInput || isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
            return !1;
        cm.state.pasteIncoming && cm.state.fakedLastChar && (input.value = input.value.substring(0, input.value.length - 1),
        cm.state.fakedLastChar = !1);
        var text = input.value;
        if (text == prevInput && !cm.somethingSelected())
            return !1;
        if (ie && ie_version >= 9 && cm.display.inputHasSelection === text || mac && /[\uf700-\uf7ff]/.test(text))
            return resetInput(cm),
            !1;
        var withOp = !cm.curOp;
        withOp && startOperation(cm),
        cm.display.shift = !1,
        8203 != text.charCodeAt(0) || doc.sel != cm.display.selForContextMenu || prevInput || (prevInput = "​");
        for (var same = 0, l = Math.min(prevInput.length, text.length); same < l && prevInput.charCodeAt(same) == text.charCodeAt(same); )
            ++same;
        var inserted = text.slice(same)
          , textLines = splitLines(inserted)
          , multiPaste = null;
        cm.state.pasteIncoming && doc.sel.ranges.length > 1 && (lastCopied && lastCopied.join("\n") == inserted ? multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines) : textLines.length == doc.sel.ranges.length && (multiPaste = map(textLines, function(l) {
            return [l]
        })));
        for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
            var range = doc.sel.ranges[i]
              , from = range.from()
              , to = range.to();
            same < prevInput.length ? from = Pos(from.line, from.ch - (prevInput.length - same)) : cm.state.overwrite && range.empty() && !cm.state.pasteIncoming && (to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)));
            var updateInput = cm.curOp.updateInput
              , changeEvent = {
                from: from,
                to: to,
                text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"
            };
            if (makeChange(cm.doc, changeEvent),
            signalLater(cm, "inputRead", cm, changeEvent),
            inserted && !cm.state.pasteIncoming && cm.options.electricChars && cm.options.smartIndent && range.head.ch < 100 && (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
                var mode = cm.getModeAt(range.head)
                  , end = changeEnd(changeEvent);
                if (mode.electricChars) {
                    for (var j = 0; j < mode.electricChars.length; j++)
                        if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                            indentLine(cm, end.line, "smart");
                            break
                        }
                } else
                    mode.electricInput && mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)) && indentLine(cm, end.line, "smart")
            }
        }
        return ensureCursorVisible(cm),
        cm.curOp.updateInput = updateInput,
        cm.curOp.typing = !0,
        text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = cm.display.prevInput = "" : cm.display.prevInput = text,
        withOp && endOperation(cm),
        cm.state.pasteIncoming = cm.state.cutIncoming = !1,
        !0
    }
    function resetInput(cm, typing) {
        var minimal, selected, doc = cm.doc;
        if (cm.somethingSelected()) {
            cm.display.prevInput = "";
            var range = doc.sel.primary();
            minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1e3);
            var content = minimal ? "-" : selected || cm.getSelection();
            cm.display.input.value = content,
            cm.state.focused && selectInput(cm.display.input),
            ie && ie_version >= 9 && (cm.display.inputHasSelection = content)
        } else
            typing || (cm.display.prevInput = cm.display.input.value = "",
            ie && ie_version >= 9 && (cm.display.inputHasSelection = null));
        cm.display.inaccurateSelection = minimal
    }
    function focusInput(cm) {
        "nocursor" == cm.options.readOnly || mobile && activeElt() == cm.display.input || cm.display.input.focus()
    }
    function ensureFocus(cm) {
        cm.state.focused || (focusInput(cm),
        onFocus(cm))
    }
    function isReadOnly(cm) {
        return cm.options.readOnly || cm.doc.cantEdit
    }
    function registerEventHandlers(cm) {
        function reFocus() {
            cm.state.focused && setTimeout(bind(focusInput, cm), 0)
        }
        function drag_(e) {
            signalDOMEvent(cm, e) || e_stop(e)
        }
        function prepareCopyCut(e) {
            if (cm.somethingSelected())
                lastCopied = cm.getSelections(),
                d.inaccurateSelection && (d.prevInput = "",
                d.inaccurateSelection = !1,
                d.input.value = lastCopied.join("\n"),
                selectInput(d.input));
            else {
                for (var text = [], ranges = [], i = 0; i < cm.doc.sel.ranges.length; i++) {
                    var line = cm.doc.sel.ranges[i].head.line
                      , lineRange = {
                        anchor: Pos(line, 0),
                        head: Pos(line + 1, 0)
                    };
                    ranges.push(lineRange),
                    text.push(cm.getRange(lineRange.anchor, lineRange.head))
                }
                "cut" == e.type ? cm.setSelections(ranges, null, sel_dontScroll) : (d.prevInput = "",
                d.input.value = text.join("\n"),
                selectInput(d.input)),
                lastCopied = text
            }
            "cut" == e.type && (cm.state.cutIncoming = !0)
        }
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown)),
        ie && ie_version < 11 ? on(d.scroller, "dblclick", operation(cm, function(e) {
            if (!signalDOMEvent(cm, e)) {
                var pos = posFromMouse(cm, e);
                if (pos && !clickInGutter(cm, e) && !eventInWidget(cm.display, e)) {
                    e_preventDefault(e);
                    var word = cm.findWordAt(pos);
                    extendSelection(cm.doc, word.anchor, word.head)
                }
            }
        })) : on(d.scroller, "dblclick", function(e) {
            signalDOMEvent(cm, e) || e_preventDefault(e)
        }),
        on(d.lineSpace, "selectstart", function(e) {
            eventInWidget(d, e) || e_preventDefault(e)
        }),
        captureRightClick || on(d.scroller, "contextmenu", function(e) {
            onContextMenu(cm, e)
        }),
        on(d.scroller, "scroll", function() {
            d.scroller.clientHeight && (setScrollTop(cm, d.scroller.scrollTop),
            setScrollLeft(cm, d.scroller.scrollLeft, !0),
            signal(cm, "scroll", cm))
        }),
        on(d.scrollbarV, "scroll", function() {
            d.scroller.clientHeight && setScrollTop(cm, d.scrollbarV.scrollTop)
        }),
        on(d.scrollbarH, "scroll", function() {
            d.scroller.clientHeight && setScrollLeft(cm, d.scrollbarH.scrollLeft)
        }),
        on(d.scroller, "mousewheel", function(e) {
            onScrollWheel(cm, e)
        }),
        on(d.scroller, "DOMMouseScroll", function(e) {
            onScrollWheel(cm, e)
        }),
        on(d.scrollbarH, "mousedown", reFocus),
        on(d.scrollbarV, "mousedown", reFocus),
        on(d.wrapper, "scroll", function() {
            d.wrapper.scrollTop = d.wrapper.scrollLeft = 0
        }),
        on(d.input, "keyup", function(e) {
            onKeyUp.call(cm, e)
        }),
        on(d.input, "input", function() {
            ie && ie_version >= 9 && cm.display.inputHasSelection && (cm.display.inputHasSelection = null),
            fastPoll(cm)
        }),
        on(d.input, "keydown", operation(cm, onKeyDown)),
        on(d.input, "keypress", operation(cm, onKeyPress)),
        on(d.input, "focus", bind(onFocus, cm)),
        on(d.input, "blur", bind(onBlur, cm)),
        cm.options.dragDrop && (on(d.scroller, "dragstart", function(e) {
            onDragStart(cm, e)
        }),
        on(d.scroller, "dragenter", drag_),
        on(d.scroller, "dragover", drag_),
        on(d.scroller, "drop", operation(cm, onDrop))),
        on(d.scroller, "paste", function(e) {
            eventInWidget(d, e) || (cm.state.pasteIncoming = !0,
            focusInput(cm),
            fastPoll(cm))
        }),
        on(d.input, "paste", function() {
            if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
                var start = d.input.selectionStart
                  , end = d.input.selectionEnd;
                d.input.value += "$",
                d.input.selectionEnd = end,
                d.input.selectionStart = start,
                cm.state.fakedLastChar = !0
            }
            cm.state.pasteIncoming = !0,
            fastPoll(cm)
        }),
        on(d.input, "cut", prepareCopyCut),
        on(d.input, "copy", prepareCopyCut),
        khtml && on(d.sizer, "mouseup", function() {
            activeElt() == d.input && d.input.blur(),
            focusInput(cm)
        })
    }
    function onResize(cm) {
        var d = cm.display;
        d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth || (d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null,
        cm.setSize())
    }
    function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode)
            if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover)
                return !0
    }
    function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal) {
            var target = e_target(e);
            if (target == display.scrollbarH || target == display.scrollbarV || target == display.scrollbarFiller || target == display.gutterFiller)
                return null
        }
        var x, y, space = display.lineSpace.getBoundingClientRect();
        try {
            x = e.clientX - space.left,
            y = e.clientY - space.top
        } catch (e) {
            return null
        }
        var line, coords = coordsChar(cm, x, y);
        if (forRect && 1 == coords.xRel && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))
        }
        return coords
    }
    function onMouseDown(e) {
        if (!signalDOMEvent(this, e)) {
            var cm = this
              , display = cm.display;
            if (display.shift = e.shiftKey,
            eventInWidget(display, e))
                return void (webkit || (display.scroller.draggable = !1,
                setTimeout(function() {
                    display.scroller.draggable = !0
                }, 100)));
            if (!clickInGutter(cm, e)) {
                var start = posFromMouse(cm, e);
                switch (window.focus(),
                e_button(e)) {
                case 1:
                    start ? leftButtonDown(cm, e, start) : e_target(e) == display.scroller && e_preventDefault(e);
                    break;
                case 2:
                    webkit && (cm.state.lastMiddleDown = +new Date),
                    start && extendSelection(cm.doc, start),
                    setTimeout(bind(focusInput, cm), 20),
                    e_preventDefault(e);
                    break;
                case 3:
                    captureRightClick && onContextMenu(cm, e)
                }
            }
        }
    }
    function leftButtonDown(cm, e, start) {
        setTimeout(bind(ensureFocus, cm), 0);
        var type, now = +new Date;
        lastDoubleClick && lastDoubleClick.time > now - 400 && 0 == cmp(lastDoubleClick.pos, start) ? type = "triple" : lastClick && lastClick.time > now - 400 && 0 == cmp(lastClick.pos, start) ? (type = "double",
        lastDoubleClick = {
            time: now,
            pos: start
        }) : (type = "single",
        lastClick = {
            time: now,
            pos: start
        });
        var sel = cm.doc.sel
          , modifier = mac ? e.metaKey : e.ctrlKey;
        cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && "single" == type && sel.contains(start) > -1 && sel.somethingSelected() ? leftButtonStartDrag(cm, e, start, modifier) : leftButtonSelect(cm, e, start, type, modifier)
    }
    function leftButtonStartDrag(cm, e, start, modifier) {
        var display = cm.display
          , dragEnd = operation(cm, function(e2) {
            webkit && (display.scroller.draggable = !1),
            cm.state.draggingText = !1,
            off(document, "mouseup", dragEnd),
            off(display.scroller, "drop", dragEnd),
            Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10 && (e_preventDefault(e2),
            modifier || extendSelection(cm.doc, start),
            focusInput(cm),
            ie && 9 == ie_version && setTimeout(function() {
                document.body.focus(),
                focusInput(cm)
            }, 20))
        });
        webkit && (display.scroller.draggable = !0),
        cm.state.draggingText = dragEnd,
        display.scroller.dragDrop && display.scroller.dragDrop(),
        on(document, "mouseup", dragEnd),
        on(display.scroller, "drop", dragEnd)
    }
    function leftButtonSelect(cm, e, start, type, addNew) {
        function extendTo(pos) {
            if (0 != cmp(lastPos, pos))
                if (lastPos = pos,
                "rect" == type) {
                    for (var ranges = [], tabSize = cm.options.tabSize, startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize), posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize), left = Math.min(startCol, posCol), right = Math.max(startCol, posCol), line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                        var text = getLine(doc, line).text
                          , leftPos = findColumn(text, left, tabSize);
                        left == right ? ranges.push(new Range(Pos(line, leftPos),Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos),Pos(line, findColumn(text, right, tabSize))))
                    }
                    ranges.length || ranges.push(new Range(start,start)),
                    setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                        origin: "*mouse",
                        scroll: !1
                    }),
                    cm.scrollIntoView(pos)
                } else {
                    var oldRange = ourRange
                      , anchor = oldRange.anchor
                      , head = pos;
                    if ("single" != type) {
                        if ("double" == type)
                            var range = cm.findWordAt(pos);
                        else
                            var range = new Range(Pos(pos.line, 0),clipPos(doc, Pos(pos.line + 1, 0)));
                        cmp(range.anchor, anchor) > 0 ? (head = range.head,
                        anchor = minPos(oldRange.from(), range.anchor)) : (head = range.anchor,
                        anchor = maxPos(oldRange.to(), range.head))
                    }
                    var ranges = startSel.ranges.slice(0);
                    ranges[ourIndex] = new Range(clipPos(doc, anchor),head),
                    setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse)
                }
        }
        function extend(e) {
            var curCount = ++counter
              , cur = posFromMouse(cm, e, !0, "rect" == type);
            if (cur)
                if (0 != cmp(cur, lastPos)) {
                    ensureFocus(cm),
                    extendTo(cur);
                    var visible = visibleLines(display, doc);
                    (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function() {
                        counter == curCount && extend(e)
                    }), 150)
                } else {
                    var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                    outside && setTimeout(operation(cm, function() {
                        counter == curCount && (display.scroller.scrollTop += outside,
                        extend(e))
                    }), 50)
                }
        }
        function done(e) {
            counter = 1 / 0,
            e_preventDefault(e),
            focusInput(cm),
            off(document, "mousemove", move),
            off(document, "mouseup", up),
            doc.history.lastSelOrigin = null
        }
        var display = cm.display
          , doc = cm.doc;
        e_preventDefault(e);
        var ourRange, ourIndex, startSel = doc.sel;
        if (addNew && !e.shiftKey ? (ourIndex = doc.sel.contains(start),
        ourRange = ourIndex > -1 ? doc.sel.ranges[ourIndex] : new Range(start,start)) : ourRange = doc.sel.primary(),
        e.altKey)
            type = "rect",
            addNew || (ourRange = new Range(start,start)),
            start = posFromMouse(cm, e, !0, !0),
            ourIndex = -1;
        else if ("double" == type) {
            var word = cm.findWordAt(start);
            ourRange = cm.display.shift || doc.extend ? extendRange(doc, ourRange, word.anchor, word.head) : word
        } else if ("triple" == type) {
            var line = new Range(Pos(start.line, 0),clipPos(doc, Pos(start.line + 1, 0)));
            ourRange = cm.display.shift || doc.extend ? extendRange(doc, ourRange, line.anchor, line.head) : line
        } else
            ourRange = extendRange(doc, ourRange, start);
        addNew ? ourIndex > -1 ? replaceOneSelection(doc, ourIndex, ourRange, sel_mouse) : (ourIndex = doc.sel.ranges.length,
        setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex), {
            scroll: !1,
            origin: "*mouse"
        })) : (ourIndex = 0,
        setSelection(doc, new Selection([ourRange],0), sel_mouse),
        startSel = doc.sel);
        var lastPos = start
          , editorSize = display.wrapper.getBoundingClientRect()
          , counter = 0
          , move = operation(cm, function(e) {
            e_button(e) ? extend(e) : done(e)
        })
          , up = operation(cm, done);
        on(document, "mousemove", move),
        on(document, "mouseup", up)
    }
    function gutterEvent(cm, e, type, prevent, signalfn) {
        try {
            var mX = e.clientX
              , mY = e.clientY
        } catch (e) {
            return !1
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
            return !1;
        prevent && e_preventDefault(e);
        var display = cm.display
          , lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type))
            return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
            var g = display.gutters.childNodes[i];
            if (g && g.getBoundingClientRect().right >= mX) {
                return signalfn(cm, type, cm, lineAtHeight(cm.doc, mY), cm.options.gutters[i], e),
                e_defaultPrevented(e)
            }
        }
    }
    function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", !0, signalLater)
    }
    function onDrop(e) {
        var cm = this;
        if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
            e_preventDefault(e),
            ie && (lastDrop = +new Date);
            var pos = posFromMouse(cm, e, !0)
              , files = e.dataTransfer.files;
            if (pos && !isReadOnly(cm))
                if (files && files.length && window.FileReader && window.File)
                    for (var n = files.length, text = Array(n), read = 0, i = 0; i < n; ++i)
                        !function(file, i) {
                            var reader = new FileReader;
                            reader.onload = operation(cm, function() {
                                if (text[i] = reader.result,
                                ++read == n) {
                                    pos = clipPos(cm.doc, pos);
                                    var change = {
                                        from: pos,
                                        to: pos,
                                        text: splitLines(text.join("\n")),
                                        origin: "paste"
                                    };
                                    makeChange(cm.doc, change),
                                    setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))
                                }
                            }),
                            reader.readAsText(file)
                        }(files[i], i);
                else {
                    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1)
                        return cm.state.draggingText(e),
                        void setTimeout(bind(focusInput, cm), 20);
                    try {
                        var text = e.dataTransfer.getData("Text");
                        if (text) {
                            if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
                                var selected = cm.listSelections();
                            if (setSelectionNoUndo(cm.doc, simpleSelection(pos, pos)),
                            selected)
                                for (var i = 0; i < selected.length; ++i)
                                    replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
                            cm.replaceSelection(text, "around", "paste"),
                            focusInput(cm)
                        }
                    } catch (e) {}
                }
        }
    }
    function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100))
            return void e_stop(e);
        if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e) && (e.dataTransfer.setData("Text", cm.getSelection()),
        e.dataTransfer.setDragImage && !safari)) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
            presto && (img.width = img.height = 1,
            cm.display.wrapper.appendChild(img),
            img._top = img.offsetTop),
            e.dataTransfer.setDragImage(img, 0, 0),
            presto && img.parentNode.removeChild(img)
        }
    }
    function setScrollTop(cm, val) {
        Math.abs(cm.doc.scrollTop - val) < 2 || (cm.doc.scrollTop = val,
        gecko || updateDisplaySimple(cm, {
            top: val
        }),
        cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val),
        cm.display.scrollbarV.scrollTop != val && (cm.display.scrollbarV.scrollTop = val),
        gecko && updateDisplaySimple(cm),
        startWorker(cm, 100))
    }
    function setScrollLeft(cm, val, isScroller) {
        (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) || (val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth),
        cm.doc.scrollLeft = val,
        alignHorizontally(cm),
        cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val),
        cm.display.scrollbarH.scrollLeft != val && (cm.display.scrollbarH.scrollLeft = val))
    }
    function onScrollWheel(cm, e) {
        var dx = e.wheelDeltaX
          , dy = e.wheelDeltaY;
        null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail),
        null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta);
        var display = cm.display
          , scroll = display.scroller;
        if (dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight) {
            if (dy && mac && webkit)
                outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode)
                    for (var i = 0; i < view.length; i++)
                        if (view[i].node == cur) {
                            cm.display.currentWheelTarget = cur;
                            break outer
                        }
            if (dx && !gecko && !presto && null != wheelPixelsPerUnit)
                return dy && setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))),
                setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth))),
                e_preventDefault(e),
                void (display.wheelStartX = null);
            if (dy && null != wheelPixelsPerUnit) {
                var pixels = dy * wheelPixelsPerUnit
                  , top = cm.doc.scrollTop
                  , bot = top + display.wrapper.clientHeight;
                pixels < 0 ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50),
                updateDisplaySimple(cm, {
                    top: top,
                    bottom: bot
                })
            }
            wheelSamples < 20 && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft,
            display.wheelStartY = scroll.scrollTop,
            display.wheelDX = dx,
            display.wheelDY = dy,
            setTimeout(function() {
                if (null != display.wheelStartX) {
                    var movedX = scroll.scrollLeft - display.wheelStartX
                      , movedY = scroll.scrollTop - display.wheelStartY
                      , sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                    display.wheelStartX = display.wheelStartY = null,
                    sample && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1),
                    ++wheelSamples)
                }
            }, 200)) : (display.wheelDX += dx,
            display.wheelDY += dy))
        }
    }
    function doHandleBinding(cm, bound, dropShift) {
        if ("string" == typeof bound && !(bound = commands[bound]))
            return !1;
        cm.display.pollingFast && readInput(cm) && (cm.display.pollingFast = !1);
        var prevShift = cm.display.shift
          , done = !1;
        try {
            isReadOnly(cm) && (cm.state.suppressEdits = !0),
            dropShift && (cm.display.shift = !1),
            done = bound(cm) != Pass
        } finally {
            cm.display.shift = prevShift,
            cm.state.suppressEdits = !1
        }
        return done
    }
    function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
            var result = lookupKey(name, cm.state.keyMaps[i], handle);
            if (result)
                return result
        }
        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle) || lookupKey(name, cm.options.keyMap, handle)
    }
    function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
            if (isModifierKey(name))
                return "handled";
            stopSeq.set(50, function() {
                cm.state.keySeq == seq && (cm.state.keySeq = null,
                resetInput(cm))
            }),
            name = seq + " " + name
        }
        var result = lookupKeyForEditor(cm, name, handle);
        return "multi" == result && (cm.state.keySeq = name),
        "handled" == result && signalLater(cm, "keyHandled", cm, name, e),
        "handled" != result && "multi" != result || (e_preventDefault(e),
        restartBlink(cm)),
        seq && !result && /\'$/.test(name) ? (e_preventDefault(e),
        !0) : !!result
    }
    function handleKeyBinding(cm, e) {
        var name = keyName(e, !0);
        return !!name && (e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function(b) {
            return doHandleBinding(cm, b, !0)
        }) || dispatchKey(cm, name, e, function(b) {
            if ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion)
                return doHandleBinding(cm, b)
        }) : dispatchKey(cm, name, e, function(b) {
            return doHandleBinding(cm, b)
        }))
    }
    function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function(b) {
            return doHandleBinding(cm, b, !0)
        })
    }
    function onKeyDown(e) {
        var cm = this;
        if (ensureFocus(cm),
        !signalDOMEvent(cm, e)) {
            ie && ie_version < 11 && 27 == e.keyCode && (e.returnValue = !1);
            var code = e.keyCode;
            cm.display.shift = 16 == code || e.shiftKey;
            var handled = handleKeyBinding(cm, e);
            presto && (lastStoppedKey = handled ? code : null,
            !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")),
            18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || showCrossHair(cm)
        }
    }
    function showCrossHair(cm) {
        function up(e) {
            18 != e.keyCode && e.altKey || (rmClass(lineDiv, "CodeMirror-crosshair"),
            off(document, "keyup", up),
            off(document, "mouseover", up))
        }
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair"),
        on(document, "keyup", up),
        on(document, "mouseover", up)
    }
    function onKeyUp(e) {
        16 == e.keyCode && (this.doc.sel.shift = !1),
        signalDOMEvent(this, e)
    }
    function onKeyPress(e) {
        var cm = this;
        if (!(signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)) {
            var keyCode = e.keyCode
              , charCode = e.charCode;
            if (presto && keyCode == lastStoppedKey)
                return lastStoppedKey = null,
                void e_preventDefault(e);
            if (!(presto && (!e.which || e.which < 10) || khtml) || !handleKeyBinding(cm, e)) {
                handleCharBinding(cm, e, String.fromCharCode(null == charCode ? keyCode : charCode)) || (ie && ie_version >= 9 && (cm.display.inputHasSelection = null),
                fastPoll(cm))
            }
        }
    }
    function onFocus(cm) {
        "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm),
        cm.state.focused = !0,
        addClass(cm.display.wrapper, "CodeMirror-focused"),
        cm.curOp || cm.display.selForContextMenu == cm.doc.sel || (resetInput(cm),
        webkit && setTimeout(bind(resetInput, cm, !0), 0))),
        slowPoll(cm),
        restartBlink(cm))
    }
    function onBlur(cm) {
        cm.state.focused && (signal(cm, "blur", cm),
        cm.state.focused = !1,
        rmClass(cm.display.wrapper, "CodeMirror-focused")),
        clearInterval(cm.display.blinker),
        setTimeout(function() {
            cm.state.focused || (cm.display.shift = !1)
        }, 150)
    }
    function onContextMenu(cm, e) {
        function prepareSelectAllHack() {
            if (null != display.input.selectionStart) {
                var selected = cm.somethingSelected()
                  , extval = display.input.value = "​" + (selected ? display.input.value : "");
                display.prevInput = selected ? "" : "​",
                display.input.selectionStart = 1,
                display.input.selectionEnd = extval.length,
                display.selForContextMenu = cm.doc.sel
            }
        }
        function rehide() {
            if (display.inputDiv.style.position = "relative",
            display.input.style.cssText = oldCSS,
            ie && ie_version < 9 && (display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos),
            slowPoll(cm),
            null != display.input.selectionStart) {
                (!ie || ie && ie_version < 9) && prepareSelectAllHack();
                var i = 0
                  , poll = function() {
                    display.selForContextMenu == cm.doc.sel && 0 == display.input.selectionStart ? operation(cm, commands.selectAll)(cm) : i++ < 10 ? display.detectingSelectAll = setTimeout(poll, 500) : resetInput(cm)
                };
                display.detectingSelectAll = setTimeout(poll, 200)
            }
        }
        if (!signalDOMEvent(cm, e, "contextmenu")) {
            var display = cm.display;
            if (!eventInWidget(display, e) && !contextMenuInGutter(cm, e)) {
                var pos = posFromMouse(cm, e)
                  , scrollPos = display.scroller.scrollTop;
                if (pos && !presto) {
                    cm.options.resetSelectionOnContextMenu && -1 == cm.doc.sel.contains(pos) && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
                    var oldCSS = display.input.style.cssText;
                    if (display.inputDiv.style.position = "absolute",
                    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) + "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);",
                    webkit)
                        var oldScrollY = window.scrollY;
                    if (focusInput(cm),
                    webkit && window.scrollTo(null, oldScrollY),
                    resetInput(cm),
                    cm.somethingSelected() || (display.input.value = display.prevInput = " "),
                    display.selForContextMenu = cm.doc.sel,
                    clearTimeout(display.detectingSelectAll),
                    ie && ie_version >= 9 && prepareSelectAllHack(),
                    captureRightClick) {
                        e_stop(e);
                        var mouseup = function() {
                            off(window, "mouseup", mouseup),
                            setTimeout(rehide, 20)
                        };
                        on(window, "mouseup", mouseup)
                    } else
                        setTimeout(rehide, 50)
                }
            }
        }
    }
    function contextMenuInGutter(cm, e) {
        return !!hasHandler(cm, "gutterContextMenu") && gutterEvent(cm, e, "gutterContextMenu", !1, signal)
    }
    function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0)
            return pos;
        if (cmp(pos, change.to) <= 0)
            return changeEnd(change);
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1
          , ch = pos.ch;
        return pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch),
        Pos(line, ch)
    }
    function computeSelAfterChange(doc, change) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            out.push(new Range(adjustForChange(range.anchor, change),adjustForChange(range.head, change)))
        }
        return normalizeSelection(out, doc.sel.primIndex)
    }
    function offsetPos(pos, old, nw) {
        return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch)
    }
    function computeReplacedSel(doc, changes, hint) {
        for (var out = [], oldPrev = Pos(doc.first, 0), newPrev = oldPrev, i = 0; i < changes.length; i++) {
            var change = changes[i]
              , from = offsetPos(change.from, oldPrev, newPrev)
              , to = offsetPos(changeEnd(change), oldPrev, newPrev);
            if (oldPrev = change.to,
            newPrev = to,
            "around" == hint) {
                var range = doc.sel.ranges[i]
                  , inv = cmp(range.head, range.anchor) < 0;
                out[i] = new Range(inv ? to : from,inv ? from : to)
            } else
                out[i] = new Range(from,from)
        }
        return new Selection(out,doc.sel.primIndex)
    }
    function filterChange(doc, change, update) {
        var obj = {
            canceled: !1,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
                this.canceled = !0
            }
        };
        return update && (obj.update = function(from, to, text, origin) {
            from && (this.from = clipPos(doc, from)),
            to && (this.to = clipPos(doc, to)),
            text && (this.text = text),
            void 0 !== origin && (this.origin = origin)
        }
        ),
        signal(doc, "beforeChange", doc, obj),
        doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj),
        obj.canceled ? null : {
            from: obj.from,
            to: obj.to,
            text: obj.text,
            origin: obj.origin
        }
    }
    function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
            if (!doc.cm.curOp)
                return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            if (doc.cm.state.suppressEdits)
                return
        }
        if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
            var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
            if (split)
                for (var i = split.length - 1; i >= 0; --i)
                    makeChangeInner(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: i ? [""] : change.text
                    });
            else
                makeChangeInner(doc, change)
        }
    }
    function makeChangeInner(doc, change) {
        if (1 != change.text.length || "" != change.text[0] || 0 != cmp(change.from, change.to)) {
            var selAfter = computeSelAfterChange(doc, change);
            addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN),
            makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
            var rebased = [];
            linkedDocs(doc, function(doc, sharedHist) {
                sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change),
                rebased.push(doc.history)),
                makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
            })
        }
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (!doc.cm || !doc.cm.state.suppressEdits) {
            for (var event, hist = doc.history, selAfter = doc.sel, source = "undo" == type ? hist.done : hist.undone, dest = "undo" == type ? hist.undone : hist.done, i = 0; i < source.length && (event = source[i],
            allowSelectionOnly ? !event.ranges || event.equals(doc.sel) : event.ranges); i++)
                ;
            if (i != source.length) {
                for (hist.lastOrigin = hist.lastSelOrigin = null; event = source.pop(),
                event.ranges; ) {
                    if (pushSelectionToHistory(event, dest),
                    allowSelectionOnly && !event.equals(doc.sel))
                        return void setSelection(doc, event, {
                            clearRedo: !1
                        });
                    selAfter = event
                }
                var antiChanges = [];
                pushSelectionToHistory(selAfter, dest),
                dest.push({
                    changes: antiChanges,
                    generation: hist.generation
                }),
                hist.generation = event.generation || ++hist.maxGeneration;
                for (var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"), i = event.changes.length - 1; i >= 0; --i) {
                    var change = event.changes[i];
                    if (change.origin = type,
                    filter && !filterChange(doc, change, !1))
                        return void (source.length = 0);
                    antiChanges.push(historyChangeFromChange(doc, change));
                    var after = i ? computeSelAfterChange(doc, change) : lst(source);
                    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change)),
                    !i && doc.cm && doc.cm.scrollIntoView({
                        from: change.from,
                        to: changeEnd(change)
                    });
                    var rebased = [];
                    linkedDocs(doc, function(doc, sharedHist) {
                        sharedHist || -1 != indexOf(rebased, doc.history) || (rebaseHist(doc.history, change),
                        rebased.push(doc.history)),
                        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
                    })
                }
            }
        }
    }
    function shiftDoc(doc, distance) {
        if (0 != distance && (doc.first += distance,
        doc.sel = new Selection(map(doc.sel.ranges, function(range) {
            return new Range(Pos(range.anchor.line + distance, range.anchor.ch),Pos(range.head.line + distance, range.head.ch))
        }),doc.sel.primIndex),
        doc.cm)) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
                regLineChange(doc.cm, l, "gutter")
        }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp)
            return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        if (change.to.line < doc.first)
            return void shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
        if (!(change.from.line > doc.lastLine())) {
            if (change.from.line < doc.first) {
                var shift = change.text.length - 1 - (doc.first - change.from.line);
                shiftDoc(doc, shift),
                change = {
                    from: Pos(doc.first, 0),
                    to: Pos(change.to.line + shift, change.to.ch),
                    text: [lst(change.text)],
                    origin: change.origin
                }
            }
            var last = doc.lastLine();
            change.to.line > last && (change = {
                from: change.from,
                to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]],
                origin: change.origin
            }),
            change.removed = getBetween(doc, change.from, change.to),
            selAfter || (selAfter = computeSelAfterChange(doc, change)),
            doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans) : updateDoc(doc, change, spans),
            setSelectionNoUndo(doc, selAfter, sel_dontScroll)
        }
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc
          , display = cm.display
          , from = change.from
          , to = change.to
          , recomputeMaxLength = !1
          , checkWidthStart = from.line;
        cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(getLine(doc, from.line))),
        doc.iter(checkWidthStart, to.line + 1, function(line) {
            if (line == display.maxLine)
                return recomputeMaxLength = !0,
                !0
        })),
        doc.sel.contains(change.from, change.to) > -1 && signalCursorActivity(cm),
        updateDoc(doc, change, spans, estimateHeight(cm)),
        cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
            var len = lineLength(line);
            len > display.maxLineLength && (display.maxLine = line,
            display.maxLineLength = len,
            display.maxLineChanged = !0,
            recomputeMaxLength = !1)
        }),
        recomputeMaxLength && (cm.curOp.updateMaxLine = !0)),
        doc.frontier = Math.min(doc.frontier, from.line),
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, lendiff) : regLineChange(cm, from.line, "text");
        var changesHandler = hasHandler(cm, "changes")
          , changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
            var obj = {
                from: from,
                to: to,
                text: change.text,
                removed: change.removed,
                origin: change.origin
            };
            changeHandler && signalLater(cm, "change", cm, obj),
            changesHandler && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj)
        }
        cm.display.selForContextMenu = null
    }
    function replaceRange(doc, code, from, to, origin) {
        if (to || (to = from),
        cmp(to, from) < 0) {
            var tmp = to;
            to = from,
            from = tmp
        }
        "string" == typeof code && (code = splitLines(code)),
        makeChange(doc, {
            from: from,
            to: to,
            text: code,
            origin: origin
        })
    }
    function maybeScrollWindow(cm, coords) {
        if (!signalDOMEvent(cm, "scrollCursorIntoView")) {
            var display = cm.display
              , box = display.sizer.getBoundingClientRect()
              , doScroll = null;
            if (coords.top + box.top < 0 ? doScroll = !0 : coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1),
            null != doScroll && !phantom) {
                var scrollNode = elt("div", "​", null, "position: absolute; top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " + (coords.bottom - coords.top + scrollerCutOff) + "px; left: " + coords.left + "px; width: 2px;");
                cm.display.lineSpace.appendChild(scrollNode),
                scrollNode.scrollIntoView(doScroll),
                cm.display.lineSpace.removeChild(scrollNode)
            }
        }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
        null == margin && (margin = 0);
        for (var limit = 0; limit < 5; limit++) {
            var changed = !1
              , coords = cursorCoords(cm, pos)
              , endCoords = end && end != pos ? cursorCoords(cm, end) : coords
              , scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin)
              , startTop = cm.doc.scrollTop
              , startLeft = cm.doc.scrollLeft;
            if (null != scrollPos.scrollTop && (setScrollTop(cm, scrollPos.scrollTop),
            Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = !0)),
            null != scrollPos.scrollLeft && (setScrollLeft(cm, scrollPos.scrollLeft),
            Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = !0)),
            !changed)
                return coords
        }
    }
    function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        null != scrollPos.scrollTop && setScrollTop(cm, scrollPos.scrollTop),
        null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft)
    }
    function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display
          , snapMargin = textHeight(cm.display);
        y1 < 0 && (y1 = 0);
        var screentop = cm.curOp && null != cm.curOp.scrollTop ? cm.curOp.scrollTop : display.scroller.scrollTop
          , screen = display.scroller.clientHeight - scrollerCutOff
          , result = {};
        y2 - y1 > screen && (y2 = y1 + screen);
        var docBottom = cm.doc.height + paddingVert(display)
          , atTop = y1 < snapMargin
          , atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop)
            result.scrollTop = atTop ? 0 : y1;
        else if (y2 > screentop + screen) {
            var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
            newTop != screentop && (result.scrollTop = newTop)
        }
        var screenleft = cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp.scrollLeft : display.scroller.scrollLeft
          , screenw = display.scroller.clientWidth - scrollerCutOff - display.gutters.offsetWidth
          , tooWide = x2 - x1 > screenw;
        return tooWide && (x2 = x1 + screenw),
        x1 < 10 ? result.scrollLeft = 0 : x1 < screenleft ? result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) : x2 > screenw + screenleft - 3 && (result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw),
        result
    }
    function addToScrollPos(cm, left, top) {
        null == left && null == top || resolveScrollToPos(cm),
        null != left && (cm.curOp.scrollLeft = (null == cm.curOp.scrollLeft ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left),
        null != top && (cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc.scrollTop : cm.curOp.scrollTop) + top)
    }
    function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor()
          , from = cur
          , to = cur;
        cm.options.lineWrapping || (from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur,
        to = Pos(cur.line, cur.ch + 1)),
        cm.curOp.scrollToPos = {
            from: from,
            to: to,
            margin: cm.options.cursorScrollMargin,
            isCursor: !0
        }
    }
    function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range.from)
              , to = estimateCoords(cm, range.to)
              , sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
            cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)
        }
    }
    function indentLine(cm, n, how, aggressive) {
        var state, doc = cm.doc;
        null == how && (how = "add"),
        "smart" == how && (doc.mode.indent ? state = getStateBefore(cm, n) : how = "prev");
        var tabSize = cm.options.tabSize
          , line = getLine(doc, n)
          , curSpace = countColumn(line.text, null, tabSize);
        line.stateAfter && (line.stateAfter = null);
        var indentation, curSpaceString = line.text.match(/^\s*/)[0];
        if (aggressive || /\S/.test(line.text)) {
            if ("smart" == how && ((indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)) == Pass || indentation > 150)) {
                if (!aggressive)
                    return;
                how = "prev"
            }
        } else
            indentation = 0,
            how = "not";
        "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how),
        indentation = Math.max(0, indentation);
        var indentString = ""
          , pos = 0;
        if (cm.options.indentWithTabs)
            for (var i = Math.floor(indentation / tabSize); i; --i)
                pos += tabSize,
                indentString += "\t";
        if (pos < indentation && (indentString += spaceStr(indentation - pos)),
        indentString != curSpaceString)
            replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
        else
            for (var i = 0; i < doc.sel.ranges.length; i++) {
                var range = doc.sel.ranges[i];
                if (range.head.line == n && range.head.ch < curSpaceString.length) {
                    var pos = Pos(n, curSpaceString.length);
                    replaceOneSelection(doc, i, new Range(pos,pos));
                    break
                }
            }
        line.stateAfter = null
    }
    function changeLine(doc, handle, changeType, op) {
        var no = handle
          , line = handle;
        return "number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle),
        null == no ? null : (op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType),
        line)
    }
    function deleteNearSelection(cm, compute) {
        for (var ranges = cm.doc.sel.ranges, kill = [], i = 0; i < ranges.length; i++) {
            for (var toKill = compute(ranges[i]); kill.length && cmp(toKill.from, lst(kill).to) <= 0; ) {
                var replaced = kill.pop();
                if (cmp(replaced.from, toKill.from) < 0) {
                    toKill.from = replaced.from;
                    break
                }
            }
            kill.push(toKill)
        }
        runInOp(cm, function() {
            for (var i = kill.length - 1; i >= 0; i--)
                replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
            ensureCursorVisible(cm)
        })
    }
    function findPosH(doc, pos, dir, unit, visually) {
        function findNextLine() {
            var l = line + dir;
            return l < doc.first || l >= doc.first + doc.size ? possible = !1 : (line = l,
            lineObj = getLine(doc, l))
        }
        function moveOnce(boundToLine) {
            var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, !0);
            if (null == next) {
                if (boundToLine || !findNextLine())
                    return possible = !1;
                ch = visually ? (dir < 0 ? lineRight : lineLeft)(lineObj) : dir < 0 ? lineObj.text.length : 0
            } else
                ch = next;
            return !0
        }
        var line = pos.line
          , ch = pos.ch
          , origDir = dir
          , lineObj = getLine(doc, line)
          , possible = !0;
        if ("char" == unit)
            moveOnce();
        else if ("column" == unit)
            moveOnce(!0);
        else if ("word" == unit || "group" == unit)
            for (var sawType = null, group = "group" == unit, helper = doc.cm && doc.cm.getHelper(pos, "wordChars"), first = !0; !(dir < 0) || moveOnce(!first); first = !1) {
                var cur = lineObj.text.charAt(ch) || "\n"
                  , type = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
                if (!group || first || type || (type = "s"),
                sawType && sawType != type) {
                    dir < 0 && (dir = 1,
                    moveOnce());
                    break
                }
                if (type && (sawType = type),
                dir > 0 && !moveOnce(!first))
                    break
            }
        var result = skipAtomic(doc, Pos(line, ch), origDir, !0);
        return possible || (result.hitSide = !0),
        result
    }
    function findPosV(cm, pos, dir, unit) {
        var y, doc = cm.doc, x = pos.left;
        if ("page" == unit) {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display))
        } else
            "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
        for (; ; ) {
            var target = coordsChar(cm, x, y);
            if (!target.outside)
                break;
            if (dir < 0 ? y <= 0 : y >= doc.height) {
                target.hitSide = !0;
                break
            }
            y += 5 * dir
        }
        return target
    }
    function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt,
        handle && (optionHandlers[name] = notOnInit ? function(cm, val, old) {
            old != Init && handle(cm, val, old)
        }
        : handle)
    }
    function normalizeKeyName(name) {
        for (var alt, ctrl, shift, cmd, parts = name.split(/-(?!$)/), name = parts[parts.length - 1], i = 0; i < parts.length - 1; i++) {
            var mod = parts[i];
            if (/^(cmd|meta|m)$/i.test(mod))
                cmd = !0;
            else if (/^a(lt)?$/i.test(mod))
                alt = !0;
            else if (/^(c|ctrl|control)$/i.test(mod))
                ctrl = !0;
            else {
                if (!/^s(hift)$/i.test(mod))
                    throw new Error("Unrecognized modifier name: " + mod);
                shift = !0
            }
        }
        return alt && (name = "Alt-" + name),
        ctrl && (name = "Ctrl-" + name),
        cmd && (name = "Cmd-" + name),
        shift && (name = "Shift-" + name),
        name
    }
    function getKeyMap(val) {
        return "string" == typeof val ? keyMap[val] : val
    }
    function markText(doc, from, to, options, type) {
        if (options && options.shared)
            return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp)
            return operation(doc.cm, markText)(doc, from, to, options, type);
        var marker = new TextMarker(doc,type)
          , diff = cmp(from, to);
        if (options && copyObj(options, marker, !1),
        diff > 0 || 0 == diff && !1 !== marker.clearWhenEmpty)
            return marker;
        if (marker.replacedWith && (marker.collapsed = !0,
        marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget"),
        options.handleMouseEvents || (marker.widgetNode.ignoreEvents = !0),
        options.insertLeft && (marker.widgetNode.insertLeft = !0)),
        marker.collapsed) {
            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
                throw new Error("Inserting collapsed marker partially overlapping an existing one");
            sawCollapsedSpans = !0
        }
        marker.addToHistory && addChangeToHistory(doc, {
            from: from,
            to: to,
            origin: "markText"
        }, doc.sel, NaN);
        var updateMaxLine, curLine = from.line, cm = doc.cm;
        if (doc.iter(curLine, to.line + 1, function(line) {
            cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = !0),
            marker.collapsed && curLine != from.line && updateLineHeight(line, 0),
            addMarkedSpan(line, new MarkedSpan(marker,curLine == from.line ? from.ch : null,curLine == to.line ? to.ch : null)),
            ++curLine
        }),
        marker.collapsed && doc.iter(from.line, to.line + 1, function(line) {
            lineIsHidden(doc, line) && updateLineHeight(line, 0)
        }),
        marker.clearOnEnter && on(marker, "beforeCursorEnter", function() {
            marker.clear()
        }),
        marker.readOnly && (sawReadOnlySpans = !0,
        (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()),
        marker.collapsed && (marker.id = ++nextMarkerId,
        marker.atomic = !0),
        cm) {
            if (updateMaxLine && (cm.curOp.updateMaxLine = !0),
            marker.collapsed)
                regChange(cm, from.line, to.line + 1);
            else if (marker.className || marker.title || marker.startStyle || marker.endStyle)
                for (var i = from.line; i <= to.line; i++)
                    regLineChange(cm, i, "text");
            marker.atomic && reCheckSelection(cm.doc),
            signalLater(cm, "markerAdded", cm, marker)
        }
        return marker
    }
    function markTextShared(doc, from, to, options, type) {
        options = copyObj(options),
        options.shared = !1;
        var markers = [markText(doc, from, to, options, type)]
          , primary = markers[0]
          , widget = options.widgetNode;
        return linkedDocs(doc, function(doc) {
            widget && (options.widgetNode = widget.cloneNode(!0)),
            markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
            for (var i = 0; i < doc.linked.length; ++i)
                if (doc.linked[i].isParent)
                    return;
            primary = lst(markers)
        }),
        new SharedTextMarker(markers,primary)
    }
    function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
            return m.parent
        })
    }
    function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i]
              , pos = marker.find()
              , mFrom = doc.clipPos(pos.from)
              , mTo = doc.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
                var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                marker.markers.push(subMark),
                subMark.parent = marker
            }
        }
    }
    function detachSharedMarkers(markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i]
              , linked = [marker.primary.doc];
            linkedDocs(marker.primary.doc, function(d) {
                linked.push(d)
            });
            for (var j = 0; j < marker.markers.length; j++) {
                var subMarker = marker.markers[j];
                -1 == indexOf(linked, subMarker.doc) && (subMarker.parent = null,
                marker.markers.splice(j--, 1))
            }
        }
    }
    function MarkedSpan(marker, from, to) {
        this.marker = marker,
        this.from = from,
        this.to = to
    }
    function getMarkedSpanFor(spans, marker) {
        if (spans)
            for (var i = 0; i < spans.length; ++i) {
                var span = spans[i];
                if (span.marker == marker)
                    return span
            }
    }
    function removeMarkedSpan(spans, span) {
        for (var r, i = 0; i < spans.length; ++i)
            spans[i] != span && (r || (r = [])).push(spans[i]);
        return r
    }
    function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span],
        span.marker.attachLine(line)
    }
    function markedSpansBefore(old, startCh, isInsert) {
        if (old)
            for (var nw, i = 0; i < old.length; ++i) {
                var span = old[i]
                  , marker = span.marker
                  , startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                if (startsBefore || span.from == startCh && "bookmark" == marker.type && (!isInsert || !span.marker.insertLeft)) {
                    var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker,span.from,endsAfter ? null : span.to))
                }
            }
        return nw
    }
    function markedSpansAfter(old, endCh, isInsert) {
        if (old)
            for (var nw, i = 0; i < old.length; ++i) {
                var span = old[i]
                  , marker = span.marker
                  , endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                if (endsAfter || span.from == endCh && "bookmark" == marker.type && (!isInsert || span.marker.insertLeft)) {
                    var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker,startsBefore ? null : span.from - endCh,null == span.to ? null : span.to - endCh))
                }
            }
        return nw
    }
    function stretchSpansOverChange(doc, change) {
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans
          , oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast)
            return null;
        var startCh = change.from.ch
          , endCh = change.to.ch
          , isInsert = 0 == cmp(change.from, change.to)
          , first = markedSpansBefore(oldFirst, startCh, isInsert)
          , last = markedSpansAfter(oldLast, endCh, isInsert)
          , sameLine = 1 == change.text.length
          , offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first)
            for (var i = 0; i < first.length; ++i) {
                var span = first[i];
                if (null == span.to) {
                    var found = getMarkedSpanFor(last, span.marker);
                    found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh
                }
            }
        if (last)
            for (var i = 0; i < last.length; ++i) {
                var span = last[i];
                if (null != span.to && (span.to += offset),
                null == span.from) {
                    var found = getMarkedSpanFor(first, span.marker);
                    found || (span.from = offset,
                    sameLine && (first || (first = [])).push(span))
                } else
                    span.from += offset,
                    sameLine && (first || (first = [])).push(span)
            }
        first && (first = clearEmptySpans(first)),
        last && last != first && (last = clearEmptySpans(last));
        var newMarkers = [first];
        if (!sameLine) {
            var gapMarkers, gap = change.text.length - 2;
            if (gap > 0 && first)
                for (var i = 0; i < first.length; ++i)
                    null == first[i].to && (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker,null,null));
            for (var i = 0; i < gap; ++i)
                newMarkers.push(gapMarkers);
            newMarkers.push(last)
        }
        return newMarkers
    }
    function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            null != span.from && span.from == span.to && !1 !== span.marker.clearWhenEmpty && spans.splice(i--, 1)
        }
        return spans.length ? spans : null
    }
    function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change)
          , stretched = stretchSpansOverChange(doc, change);
        if (!old)
            return stretched;
        if (!stretched)
            return old;
        for (var i = 0; i < old.length; ++i) {
            var oldCur = old[i]
              , stretchCur = stretched[i];
            if (oldCur && stretchCur)
                spans: for (var j = 0; j < stretchCur.length; ++j) {
                    for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k)
                        if (oldCur[k].marker == span.marker)
                            continue spans;
                    oldCur.push(span)
                }
            else
                stretchCur && (old[i] = stretchCur)
        }
        return old
    }
    function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        if (doc.iter(from.line, to.line + 1, function(line) {
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans.length; ++i) {
                    var mark = line.markedSpans[i].marker;
                    !mark.readOnly || markers && -1 != indexOf(markers, mark) || (markers || (markers = [])).push(mark)
                }
        }),
        !markers)
            return null;
        for (var parts = [{
            from: from,
            to: to
        }], i = 0; i < markers.length; ++i)
            for (var mk = markers[i], m = mk.find(0), j = 0; j < parts.length; ++j) {
                var p = parts[j];
                if (!(cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)) {
                    var newParts = [j, 1]
                      , dfrom = cmp(p.from, m.from)
                      , dto = cmp(p.to, m.to);
                    (dfrom < 0 || !mk.inclusiveLeft && !dfrom) && newParts.push({
                        from: p.from,
                        to: m.from
                    }),
                    (dto > 0 || !mk.inclusiveRight && !dto) && newParts.push({
                        from: m.to,
                        to: p.to
                    }),
                    parts.splice.apply(parts, newParts),
                    j += newParts.length - 1
                }
            }
        return parts
    }
    function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (spans) {
            for (var i = 0; i < spans.length; ++i)
                spans[i].marker.detachLine(line);
            line.markedSpans = null
        }
    }
    function attachMarkedSpans(line, spans) {
        if (spans) {
            for (var i = 0; i < spans.length; ++i)
                spans[i].marker.attachLine(line);
            line.markedSpans = spans
        }
    }
    function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0
    }
    function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0
    }
    function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (0 != lenDiff)
            return lenDiff;
        var aPos = a.find()
          , bPos = b.find()
          , fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp)
            return -fromCmp;
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        return toCmp || b.id - a.id
    }
    function collapsedSpanAtSide(line, start) {
        var found, sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var sp, i = 0; i < sps.length; ++i)
                sp = sps[i],
                sp.marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
        return found
    }
    function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, !0)
    }
    function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, !1)
    }
    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo)
          , sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var i = 0; i < sps.length; ++i) {
                var sp = sps[i];
                if (sp.marker.collapsed) {
                    var found = sp.marker.find(0)
                      , fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)
                      , toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                    if (!(fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) && (fromCmp <= 0 && (cmp(found.to, from) > 0 || sp.marker.inclusiveRight && marker.inclusiveLeft) || fromCmp >= 0 && (cmp(found.from, to) < 0 || sp.marker.inclusiveLeft && marker.inclusiveRight)))
                        return !0
                }
            }
    }
    function visualLine(line) {
        for (var merged; merged = collapsedSpanAtStart(line); )
            line = merged.find(-1, !0).line;
        return line
    }
    function visualLineContinued(line) {
        for (var merged, lines; merged = collapsedSpanAtEnd(line); )
            line = merged.find(1, !0).line,
            (lines || (lines = [])).push(line);
        return lines
    }
    function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN)
          , vis = visualLine(line);
        return line == vis ? lineN : lineNo(vis)
    }
    function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine())
            return lineN;
        var merged, line = getLine(doc, lineN);
        if (!lineIsHidden(doc, line))
            return lineN;
        for (; merged = collapsedSpanAtEnd(line); )
            line = merged.find(1, !0).line;
        return lineNo(line) + 1
    }
    function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var sp, i = 0; i < sps.length; ++i)
                if (sp = sps[i],
                sp.marker.collapsed) {
                    if (null == sp.from)
                        return !0;
                    if (!sp.marker.widgetNode && 0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
                        return !0
                }
    }
    function lineIsHiddenInner(doc, line, span) {
        if (null == span.to) {
            var end = span.marker.find(1, !0);
            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
        }
        if (span.marker.inclusiveRight && span.to == line.text.length)
            return !0;
        for (var sp, i = 0; i < line.markedSpans.length; ++i)
            if (sp = line.markedSpans[i],
            sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
                return !0
    }
    function adjustScrollWhenAboveVisible(cm, line, diff) {
        heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollPos(cm, null, diff)
    }
    function widgetHeight(widget) {
        if (null != widget.height)
            return widget.height;
        if (!contains(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            widget.coverGutter && (parentStyle += "margin-left: -" + widget.cm.getGutterElement().offsetWidth + "px;"),
            removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, parentStyle))
        }
        return widget.height = widget.node.offsetHeight
    }
    function addLineWidget(cm, handle, node, options) {
        var widget = new LineWidget(cm,node,options);
        return widget.noHScroll && (cm.display.alignWidgets = !0),
        changeLine(cm.doc, handle, "widget", function(line) {
            var widgets = line.widgets || (line.widgets = []);
            if (null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget),
            widget.line = line,
            !lineIsHidden(cm.doc, line)) {
                var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
                updateLineHeight(line, line.height + widgetHeight(widget)),
                aboveVisible && addToScrollPos(cm, null, widget.height),
                cm.curOp.forceUpdate = !0
            }
            return !0
        }),
        widget
    }
    function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text,
        line.stateAfter && (line.stateAfter = null),
        line.styles && (line.styles = null),
        null != line.order && (line.order = null),
        detachMarkedSpans(line),
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        estHeight != line.height && updateLineHeight(line, estHeight)
    }
    function cleanUpLine(line) {
        line.parent = null,
        detachMarkedSpans(line)
    }
    function extractLineClasses(type, output) {
        if (type)
            for (; ; ) {
                var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                if (!lineClass)
                    break;
                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                var prop = lineClass[1] ? "bgClass" : "textClass";
                null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(output[prop]) || (output[prop] += " " + lineClass[2])
            }
        return type
    }
    function callBlankLine(mode, state) {
        if (mode.blankLine)
            return mode.blankLine(state);
        if (mode.innerMode) {
            var inner = CodeMirror.innerMode(mode, state);
            return inner.mode.blankLine ? inner.mode.blankLine(inner.state) : void 0
        }
    }
    function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
            inner && (inner[0] = CodeMirror.innerMode(mode, state).mode);
            var style = mode.token(stream, state);
            if (stream.pos > stream.start)
                return style
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.")
    }
    function takeToken(cm, pos, precise, asArray) {
        function getObj(copy) {
            return {
                start: stream.start,
                end: stream.pos,
                string: stream.current(),
                type: style || null,
                state: copy ? copyState(doc.mode, state) : state
            }
        }
        var style, doc = cm.doc, mode = doc.mode;
        pos = clipPos(doc, pos);
        var tokens, line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise), stream = new StringStream(line.text,cm.options.tabSize);
        for (asArray && (tokens = []); (asArray || stream.pos < pos.ch) && !stream.eol(); )
            stream.start = stream.pos,
            style = readToken(mode, stream, state),
            asArray && tokens.push(getObj(!0));
        return asArray ? tokens : getObj()
    }
    function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
        var style, curStart = 0, curStyle = null, stream = new StringStream(text,cm.options.tabSize), inner = cm.options.addModeClass && [null];
        for ("" == text && extractLineClasses(callBlankLine(mode, state), lineClasses); !stream.eol(); ) {
            if (stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1,
            forceToEnd && processLine(cm, text, state, stream.pos),
            stream.pos = text.length,
            style = null) : style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses),
            inner) {
                var mName = inner[0].name;
                mName && (style = "m-" + (style ? mName + " " + style : mName))
            }
            flattenSpans && curStyle == style || (curStart < stream.start && f(stream.start, curStyle),
            curStart = stream.start,
            curStyle = style),
            stream.start = stream.pos
        }
        for (; curStart < stream.pos; ) {
            var pos = Math.min(stream.pos, curStart + 5e4);
            f(pos, curStyle),
            curStart = pos
        }
    }
    function highlightLine(cm, line, state, forceToEnd) {
        var st = [cm.state.modeGen]
          , lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
            st.push(end, style)
        }, lineClasses, forceToEnd);
        for (var o = 0; o < cm.state.overlays.length; ++o) {
            var overlay = cm.state.overlays[o]
              , i = 1
              , at = 0;
            runMode(cm, line.text, overlay.mode, !0, function(end, style) {
                for (var start = i; at < end; ) {
                    var i_end = st[i];
                    i_end > end && st.splice(i, 1, end, st[i + 1], i_end),
                    i += 2,
                    at = Math.min(end, i_end)
                }
                if (style)
                    if (overlay.opaque)
                        st.splice(start, i - start, end, "cm-overlay " + style),
                        i = start + 2;
                    else
                        for (; start < i; start += 2) {
                            var cur = st[start + 1];
                            st[start + 1] = (cur ? cur + " " : "") + "cm-overlay " + style
                        }
            }, lineClasses)
        }
        return {
            styles: st,
            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        }
    }
    function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
            line.styles = result.styles,
            result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null),
            updateFrontier === cm.doc.frontier && cm.doc.frontier++
        }
        return line.styles
    }
    function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode
          , stream = new StringStream(text,cm.options.tabSize);
        for (stream.start = stream.pos = startAt || 0,
        "" == text && callBlankLine(mode, state); !stream.eol() && stream.pos <= cm.options.maxHighlightLength; )
            readToken(mode, stream, state),
            stream.start = stream.pos
    }
    function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style))
            return null;
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"))
    }
    function buildLineContent(cm, lineView) {
        var content = elt("span", null, null, webkit ? "padding-right: .1px" : null)
          , builder = {
            pre: elt("pre", [content]),
            content: content,
            col: 0,
            pos: 0,
            cm: cm
        };
        lineView.measure = {};
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
            var order, line = i ? lineView.rest[i - 1] : lineView.line;
            builder.pos = 0,
            builder.addToken = buildToken,
            (ie || webkit) && cm.getOption("lineWrapping") && (builder.addToken = buildTokenSplitSpaces(builder.addToken)),
            hasBadBidiRects(cm.display.measure) && (order = getOrder(line)) && (builder.addToken = buildTokenBadBidi(builder.addToken, order)),
            builder.map = [];
            insertLineContent(line, builder, getLineStyles(cm, line, lineView != cm.display.externalMeasured && lineNo(line))),
            line.styleClasses && (line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "")),
            line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))),
            0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))),
            0 == i ? (lineView.measure.map = builder.map,
            lineView.measure.cache = {}) : ((lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map),
            (lineView.measure.caches || (lineView.measure.caches = [])).push({}))
        }
        return webkit && /\bcm-tab\b/.test(builder.content.lastChild.className) && (builder.content.className = "cm-tab-wrap-hack"),
        signal(cm, "renderLine", cm, lineView.line, builder.pre),
        builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || "")),
        builder
    }
    function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "•", "cm-invalidchar");
        return token.title = "\\u" + ch.charCodeAt(0).toString(16),
        token
    }
    function buildToken(builder, text, style, startStyle, endStyle, title) {
        if (text) {
            var special = builder.cm.options.specialChars
              , mustWrap = !1;
            if (special.test(text))
                for (var content = document.createDocumentFragment(), pos = 0; ; ) {
                    special.lastIndex = pos;
                    var m = special.exec(text)
                      , skipped = m ? m.index - pos : text.length - pos;
                    if (skipped) {
                        var txt = document.createTextNode(text.slice(pos, pos + skipped));
                        ie && ie_version < 9 ? content.appendChild(elt("span", [txt])) : content.appendChild(txt),
                        builder.map.push(builder.pos, builder.pos + skipped, txt),
                        builder.col += skipped,
                        builder.pos += skipped
                    }
                    if (!m)
                        break;
                    if (pos += skipped + 1,
                    "\t" == m[0]) {
                        var tabSize = builder.cm.options.tabSize
                          , tabWidth = tabSize - builder.col % tabSize
                          , txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                        builder.col += tabWidth
                    } else {
                        var txt = builder.cm.options.specialCharPlaceholder(m[0]);
                        ie && ie_version < 9 ? content.appendChild(elt("span", [txt])) : content.appendChild(txt),
                        builder.col += 1
                    }
                    builder.map.push(builder.pos, builder.pos + 1, txt),
                    builder.pos++
                }
            else {
                builder.col += text.length;
                var content = document.createTextNode(text);
                builder.map.push(builder.pos, builder.pos + text.length, content),
                ie && ie_version < 9 && (mustWrap = !0),
                builder.pos += text.length
            }
            if (style || startStyle || endStyle || mustWrap) {
                var fullStyle = style || "";
                startStyle && (fullStyle += startStyle),
                endStyle && (fullStyle += endStyle);
                var token = elt("span", [content], fullStyle);
                return title && (token.title = title),
                builder.content.appendChild(token)
            }
            builder.content.appendChild(content)
        }
    }
    function buildTokenSplitSpaces(inner) {
        function split(old) {
            for (var out = " ", i = 0; i < old.length - 2; ++i)
                out += i % 2 ? " " : " ";
            return out += " "
        }
        return function(builder, text, style, startStyle, endStyle, title) {
            inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title)
        }
    }
    function buildTokenBadBidi(inner, order) {
        return function(builder, text, style, startStyle, endStyle, title) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            for (var start = builder.pos, end = start + text.length; ; ) {
                for (var i = 0; i < order.length; i++) {
                    var part = order[i];
                    if (part.to > start && part.from <= start)
                        break
                }
                if (part.to >= end)
                    return inner(builder, text, style, startStyle, endStyle, title);
                inner(builder, text.slice(0, part.to - start), style, startStyle, null, title),
                startStyle = null,
                text = text.slice(part.to - start),
                start = part.to
            }
        }
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        widget && (builder.map.push(builder.pos, builder.pos + size, widget),
        builder.content.appendChild(widget)),
        builder.pos += size
    }
    function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans
          , allText = line.text
          , at = 0;
        if (spans)
            for (var style, spanStyle, spanEndStyle, spanStartStyle, title, collapsed, len = allText.length, pos = 0, i = 1, text = "", nextChange = 0; ; ) {
                if (nextChange == pos) {
                    spanStyle = spanEndStyle = spanStartStyle = title = "",
                    collapsed = null,
                    nextChange = 1 / 0;
                    for (var foundBookmarks = [], j = 0; j < spans.length; ++j) {
                        var sp = spans[j]
                          , m = sp.marker;
                        sp.from <= pos && (null == sp.to || sp.to > pos) ? (null != sp.to && nextChange > sp.to && (nextChange = sp.to,
                        spanEndStyle = ""),
                        m.className && (spanStyle += " " + m.className),
                        m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle),
                        m.endStyle && sp.to == nextChange && (spanEndStyle += " " + m.endStyle),
                        m.title && !title && (title = m.title),
                        m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp)) : sp.from > pos && nextChange > sp.from && (nextChange = sp.from),
                        "bookmark" == m.type && sp.from == pos && m.widgetNode && foundBookmarks.push(m)
                    }
                    if (collapsed && (collapsed.from || 0) == pos && (buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from),
                    null == collapsed.to))
                        return;
                    if (!collapsed && foundBookmarks.length)
                        for (var j = 0; j < foundBookmarks.length; ++j)
                            buildCollapsedSpan(builder, 0, foundBookmarks[j])
                }
                if (pos >= len)
                    break;
                for (var upto = Math.min(len, nextChange); ; ) {
                    if (text) {
                        var end = pos + text.length;
                        if (!collapsed) {
                            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title)
                        }
                        if (end >= upto) {
                            text = text.slice(upto - pos),
                            pos = upto;
                            break
                        }
                        pos = end,
                        spanStartStyle = ""
                    }
                    text = allText.slice(at, at = styles[i++]),
                    style = interpretTokenStyle(styles[i++], builder.cm.options)
                }
            }
        else
            for (var i = 1; i < styles.length; i += 2)
                builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options))
    }
    function isWholeLineUpdate(doc, change) {
        return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
    }
    function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
            return markedSpans ? markedSpans[n] : null
        }
        function update(line, text, spans) {
            updateLine(line, text, spans, estimateHeight),
            signalLater(line, "change", line, change)
        }
        var from = change.from
          , to = change.to
          , text = change.text
          , firstLine = getLine(doc, from.line)
          , lastLine = getLine(doc, to.line)
          , lastText = lst(text)
          , lastSpans = spansFor(text.length - 1)
          , nlines = to.line - from.line;
        if (isWholeLineUpdate(doc, change)) {
            for (var i = 0, added = []; i < text.length - 1; ++i)
                added.push(new Line(text[i],spansFor(i),estimateHeight));
            update(lastLine, lastLine.text, lastSpans),
            nlines && doc.remove(from.line, nlines),
            added.length && doc.insert(from.line, added)
        } else if (firstLine == lastLine)
            if (1 == text.length)
                update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            else {
                for (var added = [], i = 1; i < text.length - 1; ++i)
                    added.push(new Line(text[i],spansFor(i),estimateHeight));
                added.push(new Line(lastText + firstLine.text.slice(to.ch),lastSpans,estimateHeight)),
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)),
                doc.insert(from.line + 1, added)
            }
        else if (1 == text.length)
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)),
            doc.remove(from.line + 1, nlines);
        else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)),
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            for (var i = 1, added = []; i < text.length - 1; ++i)
                added.push(new Line(text[i],spansFor(i),estimateHeight));
            nlines > 1 && doc.remove(from.line + 1, nlines - 1),
            doc.insert(from.line + 1, added)
        }
        signalLater(doc, "change", doc, change)
    }
    function LeafChunk(lines) {
        this.lines = lines,
        this.parent = null;
        for (var i = 0, height = 0; i < lines.length; ++i)
            lines[i].parent = this,
            height += lines[i].height;
        this.height = height
    }
    function BranchChunk(children) {
        this.children = children;
        for (var size = 0, height = 0, i = 0; i < children.length; ++i) {
            var ch = children[i];
            size += ch.chunkSize(),
            height += ch.height,
            ch.parent = this
        }
        this.size = size,
        this.height = height,
        this.parent = null
    }
    function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
            if (doc.linked)
                for (var i = 0; i < doc.linked.length; ++i) {
                    var rel = doc.linked[i];
                    if (rel.doc != skip) {
                        var shared = sharedHist && rel.sharedHist;
                        sharedHistOnly && !shared || (f(rel.doc, shared),
                        propagate(rel.doc, doc, shared))
                    }
                }
        }
        propagate(doc, null, !0)
    }
    function attachDoc(cm, doc) {
        if (doc.cm)
            throw new Error("This document is already in use.");
        cm.doc = doc,
        doc.cm = cm,
        estimateLineHeights(cm),
        loadMode(cm),
        cm.options.lineWrapping || findMaxLine(cm),
        cm.options.mode = doc.modeOption,
        regChange(cm)
    }
    function getLine(doc, n) {
        if ((n -= doc.first) < 0 || n >= doc.size)
            throw new Error("There is no line " + (n + doc.first) + " in the document.");
        for (var chunk = doc; !chunk.lines; )
            for (var i = 0; ; ++i) {
                var child = chunk.children[i]
                  , sz = child.chunkSize();
                if (n < sz) {
                    chunk = child;
                    break
                }
                n -= sz
            }
        return chunk.lines[n]
    }
    function getBetween(doc, start, end) {
        var out = []
          , n = start.line;
        return doc.iter(start.line, end.line + 1, function(line) {
            var text = line.text;
            n == end.line && (text = text.slice(0, end.ch)),
            n == start.line && (text = text.slice(start.ch)),
            out.push(text),
            ++n
        }),
        out
    }
    function getLines(doc, from, to) {
        var out = [];
        return doc.iter(from, to, function(line) {
            out.push(line.text)
        }),
        out
    }
    function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff)
            for (var n = line; n; n = n.parent)
                n.height += diff
    }
    function lineNo(line) {
        if (null == line.parent)
            return null;
        for (var cur = line.parent, no = indexOf(cur.lines, line), chunk = cur.parent; chunk; cur = chunk,
        chunk = chunk.parent)
            for (var i = 0; chunk.children[i] != cur; ++i)
                no += chunk.children[i].chunkSize();
        return no + cur.first
    }
    function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
            for (var i = 0; i < chunk.children.length; ++i) {
                var child = chunk.children[i]
                  , ch = child.height;
                if (h < ch) {
                    chunk = child;
                    continue outer
                }
                h -= ch,
                n += child.chunkSize()
            }
            return n
        } while (!chunk.lines);
        for (var i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i]
              , lh = line.height;
            if (h < lh)
                break;
            h -= lh
        }
        return n + i
    }
    function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        for (var h = 0, chunk = lineObj.parent, i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i];
            if (line == lineObj)
                break;
            h += line.height
        }
        for (var p = chunk.parent; p; chunk = p,
        p = chunk.parent)
            for (var i = 0; i < p.children.length; ++i) {
                var cur = p.children[i];
                if (cur == chunk)
                    break;
                h += cur.height
            }
        return h
    }
    function getOrder(line) {
        var order = line.order;
        return null == order && (order = line.order = bidiOrdering(line.text)),
        order
    }
    function History(startGen) {
        this.done = [],
        this.undone = [],
        this.undoDepth = 1 / 0,
        this.lastModTime = this.lastSelTime = 0,
        this.lastOp = this.lastSelOp = null,
        this.lastOrigin = this.lastSelOrigin = null,
        this.generation = this.maxGeneration = startGen || 1
    }
    function historyChangeFromChange(doc, change) {
        var histChange = {
            from: copyPos(change.from),
            to: changeEnd(change),
            text: getBetween(doc, change.from, change.to)
        };
        return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1),
        linkedDocs(doc, function(doc) {
            attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
        }, !0),
        histChange
    }
    function clearSelectionEvents(array) {
        for (; array.length; ) {
            if (!lst(array).ranges)
                break;
            array.pop()
        }
    }
    function lastChangeEvent(hist, force) {
        return force ? (clearSelectionEvents(hist.done),
        lst(hist.done)) : hist.done.length && !lst(hist.done).ranges ? lst(hist.done) : hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges ? (hist.done.pop(),
        lst(hist.done)) : void 0
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var cur, time = +new Date;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || "*" == change.origin.charAt(0))) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            var last = lst(cur.changes);
            0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? last.to = changeEnd(change) : cur.changes.push(historyChangeFromChange(doc, change))
        } else {
            var before = lst(hist.done);
            for (before && before.ranges || pushSelectionToHistory(doc.sel, hist.done),
            cur = {
                changes: [historyChangeFromChange(doc, change)],
                generation: hist.generation
            },
            hist.done.push(cur); hist.done.length > hist.undoDepth; )
                hist.done.shift(),
                hist.done[0].ranges || hist.done.shift()
        }
        hist.done.push(selAfter),
        hist.generation = ++hist.maxGeneration,
        hist.lastModTime = hist.lastSelTime = time,
        hist.lastOp = hist.lastSelOp = opId,
        hist.lastOrigin = hist.lastSelOrigin = change.origin,
        last || signal(doc, "historyAdded")
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return "*" == ch || "+" == ch && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
    }
    function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history
          , origin = options && options.origin;
        opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done),
        hist.lastSelTime = +new Date,
        hist.lastSelOrigin = origin,
        hist.lastSelOp = opId,
        options && !1 !== options.clearRedo && clearSelectionEvents(hist.undone)
    }
    function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        top && top.ranges && top.equals(sel) || dest.push(sel)
    }
    function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id]
          , n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
            line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans),
            ++n
        })
    }
    function removeClearedSpans(spans) {
        if (!spans)
            return null;
        for (var out, i = 0; i < spans.length; ++i)
            spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
        return out ? out.length ? out : null : spans
    }
    function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found)
            return null;
        for (var i = 0, nw = []; i < change.text.length; ++i)
            nw.push(removeClearedSpans(found[i]));
        return nw
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
        for (var i = 0, copy = []; i < events.length; ++i) {
            var event = events[i];
            if (event.ranges)
                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            else {
                var changes = event.changes
                  , newChanges = [];
                copy.push({
                    changes: newChanges
                });
                for (var j = 0; j < changes.length; ++j) {
                    var m, change = changes[j];
                    if (newChanges.push({
                        from: change.from,
                        to: change.to,
                        text: change.text
                    }),
                    newGroup)
                        for (var prop in change)
                            (m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1 && (lst(newChanges)[prop] = change[prop],
                            delete change[prop])
                }
            }
        }
        return copy
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
        to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from,
        pos.ch = 0)
    }
    function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
            var sub = array[i]
              , ok = !0;
            if (sub.ranges) {
                sub.copied || (sub = array[i] = sub.deepCopy(),
                sub.copied = !0);
                for (var j = 0; j < sub.ranges.length; j++)
                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff),
                    rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
            } else {
                for (var j = 0; j < sub.changes.length; ++j) {
                    var cur = sub.changes[j];
                    if (to < cur.from.line)
                        cur.from = Pos(cur.from.line + diff, cur.from.ch),
                        cur.to = Pos(cur.to.line + diff, cur.to.ch);
                    else if (from <= cur.to.line) {
                        ok = !1;
                        break
                    }
                }
                ok || (array.splice(0, i + 1),
                i = 0)
            }
        }
    }
    function rebaseHist(hist, change) {
        var from = change.from.line
          , to = change.to.line
          , diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff),
        rebaseHistArray(hist.undone, from, to, diff)
    }
    function e_defaultPrevented(e) {
        return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
    }
    function e_target(e) {
        return e.target || e.srcElement
    }
    function e_button(e) {
        var b = e.which;
        return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)),
        mac && e.ctrlKey && 1 == b && (b = 3),
        b
    }
    function signalLater(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (arr) {
            var list, args = Array.prototype.slice.call(arguments, 2);
            operationGroup ? list = operationGroup.delayedCallbacks : orphanDelayedCallbacks ? list = orphanDelayedCallbacks : (list = orphanDelayedCallbacks = [],
            setTimeout(fireOrphanDelayed, 0));
            for (var i = 0; i < arr.length; ++i)
                list.push(function(f) {
                    return function() {
                        f.apply(null, args)
                    }
                }(arr[i]))
        }
    }
    function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i)
            delayed[i]()
    }
    function signalDOMEvent(cm, e, override) {
        return "string" == typeof e && (e = {
            type: e,
            preventDefault: function() {
                this.defaultPrevented = !0
            }
        }),
        signal(cm, override || e.type, cm, e),
        e_defaultPrevented(e) || e.codemirrorIgnore
    }
    function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (arr)
            for (var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []), i = 0; i < arr.length; ++i)
                -1 == indexOf(set, arr[i]) && set.push(arr[i])
    }
    function hasHandler(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        return arr && arr.length > 0
    }
    function eventMixin(ctor) {
        ctor.prototype.on = function(type, f) {
            on(this, type, f)
        }
        ,
        ctor.prototype.off = function(type, f) {
            off(this, type, f)
        }
    }
    function Delayed() {
        this.id = null
    }
    function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0; ; ) {
            var nextTab = string.indexOf("\t", pos);
            -1 == nextTab && (nextTab = string.length);
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal)
                return pos + Math.min(skipped, goal - col);
            if (col += nextTab - pos,
            col += tabSize - col % tabSize,
            pos = nextTab + 1,
            col >= goal)
                return pos
        }
    }
    function spaceStr(n) {
        for (; spaceStrs.length <= n; )
            spaceStrs.push(lst(spaceStrs) + " ");
        return spaceStrs[n]
    }
    function lst(arr) {
        return arr[arr.length - 1]
    }
    function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i)
            if (array[i] == elt)
                return i;
        return -1
    }
    function map(array, f) {
        for (var out = [], i = 0; i < array.length; i++)
            out[i] = f(array[i], i);
        return out
    }
    function createObj(base, props) {
        var inst;
        if (Object.create)
            inst = Object.create(base);
        else {
            var ctor = function() {};
            ctor.prototype = base,
            inst = new ctor
        }
        return props && copyObj(props, inst),
        inst
    }
    function copyObj(obj, target, overwrite) {
        target || (target = {});
        for (var prop in obj)
            !obj.hasOwnProperty(prop) || !1 === overwrite && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
        return target
    }
    function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
            return f.apply(null, args)
        }
    }
    function isWordChar(ch, helper) {
        return helper ? !!(helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) || helper.test(ch) : isWordCharBasic(ch)
    }
    function isEmpty(obj) {
        for (var n in obj)
            if (obj.hasOwnProperty(n) && obj[n])
                return !1;
        return !0
    }
    function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch)
    }
    function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className && (e.className = className),
        style && (e.style.cssText = style),
        "string" == typeof content)
            e.appendChild(document.createTextNode(content));
        else if (content)
            for (var i = 0; i < content.length; ++i)
                e.appendChild(content[i]);
        return e
    }
    function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count)
            e.removeChild(e.firstChild);
        return e
    }
    function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e)
    }
    function contains(parent, child) {
        if (parent.contains)
            return parent.contains(child);
        for (; child = child.parentNode; )
            if (child == parent)
                return !0
    }
    function activeElt() {
        return document.activeElement
    }
    function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*")
    }
    function joinClasses(a, b) {
        for (var as = a.split(" "), i = 0; i < as.length; i++)
            as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
        return b
    }
    function forEachCodeMirror(f) {
        if (document.body.getElementsByClassName)
            for (var byClass = document.body.getElementsByClassName("CodeMirror"), i = 0; i < byClass.length; i++) {
                var cm = byClass[i].CodeMirror;
                cm && f(cm)
            }
    }
    function ensureGlobalHandlers() {
        globalsRegistered || (registerGlobalHandlers(),
        globalsRegistered = !0)
    }
    function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function() {
            null == resizeTimer && (resizeTimer = setTimeout(function() {
                resizeTimer = null,
                knownScrollbarWidth = null,
                forEachCodeMirror(onResize)
            }, 100))
        }),
        on(window, "blur", function() {
            forEachCodeMirror(onBlur)
        })
    }
    function scrollbarWidth(measure) {
        if (null != knownScrollbarWidth)
            return knownScrollbarWidth;
        var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
        return removeChildrenAndAdd(measure, test),
        test.offsetWidth && (knownScrollbarWidth = test.offsetHeight - test.clientHeight),
        knownScrollbarWidth || 0
    }
    function zeroWidthElement(measure) {
        if (null == zwspSupported) {
            var test = elt("span", "​");
            removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")])),
            0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8))
        }
        return zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px")
    }
    function hasBadBidiRects(measure) {
        if (null != badBidiRects)
            return badBidiRects;
        var txt = removeChildrenAndAdd(measure, document.createTextNode("AخA"))
          , r0 = range(txt, 0, 1).getBoundingClientRect();
        if (!r0 || r0.left == r0.right)
            return !1;
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        return badBidiRects = r1.right - r0.right < 3
    }
    function hasBadZoomedRects(measure) {
        if (null != badZoomedRects)
            return badZoomedRects;
        var node = removeChildrenAndAdd(measure, elt("span", "x"))
          , normal = node.getBoundingClientRect()
          , fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
    }
    function iterateBidiSections(order, from, to, f) {
        if (!order)
            return f(from, to, "ltr");
        for (var found = !1, i = 0; i < order.length; ++i) {
            var part = order[i];
            (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr"),
            found = !0)
        }
        found || f(from, to, "ltr")
    }
    function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from
    }
    function bidiRight(part) {
        return part.level % 2 ? part.from : part.to
    }
    function lineLeft(line) {
        var order = getOrder(line);
        return order ? bidiLeft(order[0]) : 0
    }
    function lineRight(line) {
        var order = getOrder(line);
        return order ? bidiRight(lst(order)) : line.text.length
    }
    function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN)
          , visual = visualLine(line);
        visual != line && (lineN = lineNo(visual));
        var order = getOrder(visual)
          , ch = order ? order[0].level % 2 ? lineRight(visual) : lineLeft(visual) : 0;
        return Pos(lineN, ch)
    }
    function lineEnd(cm, lineN) {
        for (var merged, line = getLine(cm.doc, lineN); merged = collapsedSpanAtEnd(line); )
            line = merged.find(1, !0).line,
            lineN = null;
        var order = getOrder(line)
          , ch = order ? order[0].level % 2 ? lineLeft(line) : lineRight(line) : line.text.length;
        return Pos(null == lineN ? lineNo(line) : lineN, ch)
    }
    function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line)
          , line = getLine(cm.doc, start.line)
          , order = getOrder(line);
        if (!order || 0 == order[0].level) {
            var firstNonWS = Math.max(0, line.text.search(/\S/))
              , inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start.line, inWS ? 0 : firstNonWS)
        }
        return start
    }
    function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        return a == linedir || b != linedir && a < b
    }
    function getBidiPartAt(order, pos) {
        bidiOther = null;
        for (var found, i = 0; i < order.length; ++i) {
            var cur = order[i];
            if (cur.from < pos && cur.to > pos)
                return i;
            if (cur.from == pos || cur.to == pos) {
                if (null != found)
                    return compareBidiLevel(order, cur.level, order[found].level) ? (cur.from != cur.to && (bidiOther = found),
                    i) : (cur.from != cur.to && (bidiOther = i),
                    found);
                found = i
            }
        }
        return found
    }
    function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit)
            return pos + dir;
        do {
            pos += dir
        } while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
        return pos
    }
    function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi)
            return moveLogically(line, start, dir, byUnit);
        for (var pos = getBidiPartAt(bidi, start), part = bidi[pos], target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit); ; ) {
            if (target > part.from && target < part.to)
                return target;
            if (target == part.from || target == part.to)
                return getBidiPartAt(bidi, target) == pos ? target : (part = bidi[pos += dir],
                dir > 0 == part.level % 2 ? part.to : part.from);
            if (!(part = bidi[pos += dir]))
                return null;
            target = dir > 0 == part.level % 2 ? moveInLine(line, part.to, -1, byUnit) : moveInLine(line, part.from, 1, byUnit)
        }
    }
    function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit)
            for (; target > 0 && isExtendingChar(line.text.charAt(target)); )
                target += dir;
        return target < 0 || target > line.text.length ? null : target
    }
    var gecko = /gecko\/\d/i.test(navigator.userAgent)
      , ie_upto10 = /MSIE \d/.test(navigator.userAgent)
      , ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
      , ie = ie_upto10 || ie_11up
      , ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1])
      , webkit = /WebKit\//.test(navigator.userAgent)
      , qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent)
      , chrome = /Chrome\//.test(navigator.userAgent)
      , presto = /Opera\//.test(navigator.userAgent)
      , safari = /Apple Computer/.test(navigator.vendor)
      , khtml = /KHTML\//.test(navigator.userAgent)
      , mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent)
      , phantom = /PhantomJS/.test(navigator.userAgent)
      , ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent)
      , mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent)
      , mac = ios || /Mac/.test(navigator.platform)
      , windows = /win/i.test(navigator.platform)
      , presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
    presto_version && (presto_version = Number(presto_version[1])),
    presto_version && presto_version >= 15 && (presto = !1,
    webkit = !0);
    var flipCtrlCmd = mac && (qtwebkit || presto && (null == presto_version || presto_version < 12.11))
      , captureRightClick = gecko || ie && ie_version >= 9
      , sawReadOnlySpans = !1
      , sawCollapsedSpans = !1
      , Pos = CodeMirror.Pos = function(line, ch) {
        if (!(this instanceof Pos))
            return new Pos(line,ch);
        this.line = line,
        this.ch = ch
    }
      , cmp = CodeMirror.cmpPos = function(a, b) {
        return a.line - b.line || a.ch - b.ch
    }
    ;
    Selection.prototype = {
        primary: function() {
            return this.ranges[this.primIndex]
        },
        equals: function(other) {
            if (other == this)
                return !0;
            if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
                return !1;
            for (var i = 0; i < this.ranges.length; i++) {
                var here = this.ranges[i]
                  , there = other.ranges[i];
                if (0 != cmp(here.anchor, there.anchor) || 0 != cmp(here.head, there.head))
                    return !1
            }
            return !0
        },
        deepCopy: function() {
            for (var out = [], i = 0; i < this.ranges.length; i++)
                out[i] = new Range(copyPos(this.ranges[i].anchor),copyPos(this.ranges[i].head));
            return new Selection(out,this.primIndex)
        },
        somethingSelected: function() {
            for (var i = 0; i < this.ranges.length; i++)
                if (!this.ranges[i].empty())
                    return !0;
            return !1
        },
        contains: function(pos, end) {
            end || (end = pos);
            for (var i = 0; i < this.ranges.length; i++) {
                var range = this.ranges[i];
                if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
                    return i
            }
            return -1
        }
    },
    Range.prototype = {
        from: function() {
            return minPos(this.anchor, this.head)
        },
        to: function() {
            return maxPos(this.anchor, this.head)
        },
        empty: function() {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
        }
    };
    var measureText, lastClick, lastDoubleClick, nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    }, operationGroup = null, nextOpId = 0, lastCopied = null, lastDrop = 0, wheelSamples = 0, wheelPixelsPerUnit = null;
    ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
    var stopSeq = new Delayed
      , lastStoppedKey = null
      , changeEnd = CodeMirror.changeEnd = function(change) {
        return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to
    }
    ;
    CodeMirror.prototype = {
        constructor: CodeMirror,
        focus: function() {
            window.focus(),
            focusInput(this),
            fastPoll(this)
        },
        setOption: function(option, value) {
            var options = this.options
              , old = options[option];
            options[option] == value && "mode" != option || (options[option] = value,
            optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old))
        },
        getOption: function(option) {
            return this.options[option]
        },
        getDoc: function() {
            return this.doc
        },
        addKeyMap: function(map, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map))
        },
        removeKeyMap: function(map) {
            for (var maps = this.state.keyMaps, i = 0; i < maps.length; ++i)
                if (maps[i] == map || maps[i].name == map)
                    return maps.splice(i, 1),
                    !0
        },
        addOverlay: methodOp(function(spec, options) {
            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
            if (mode.startState)
                throw new Error("Overlays may not be stateful.");
            this.state.overlays.push({
                mode: mode,
                modeSpec: spec,
                opaque: options && options.opaque
            }),
            this.state.modeGen++,
            regChange(this)
        }),
        removeOverlay: methodOp(function(spec) {
            for (var overlays = this.state.overlays, i = 0; i < overlays.length; ++i) {
                var cur = overlays[i].modeSpec;
                if (cur == spec || "string" == typeof spec && cur.name == spec)
                    return overlays.splice(i, 1),
                    this.state.modeGen++,
                    void regChange(this)
            }
        }),
        indentLine: methodOp(function(n, dir, aggressive) {
            "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"),
            isLine(this.doc, n) && indentLine(this, n, dir, aggressive)
        }),
        indentSelection: methodOp(function(how) {
            for (var ranges = this.doc.sel.ranges, end = -1, i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (range.empty())
                    range.head.line > end && (indentLine(this, range.head.line, how, !0),
                    end = range.head.line,
                    i == this.doc.sel.primIndex && ensureCursorVisible(this));
                else {
                    var from = range.from()
                      , to = range.to()
                      , start = Math.max(end, from.line);
                    end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                    for (var j = start; j < end; ++j)
                        indentLine(this, j, how);
                    var newRanges = this.doc.sel.ranges;
                    0 == from.ch && ranges.length == newRanges.length && newRanges[i].from().ch > 0 && replaceOneSelection(this.doc, i, new Range(from,newRanges[i].to()), sel_dontScroll)
                }
            }
        }),
        getTokenAt: function(pos, precise) {
            return takeToken(this, pos, precise)
        },
        getLineTokens: function(line, precise) {
            return takeToken(this, Pos(line), precise, !0)
        },
        getTokenTypeAt: function(pos) {
            pos = clipPos(this.doc, pos);
            var type, styles = getLineStyles(this, getLine(this.doc, pos.line)), before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
            if (0 == ch)
                type = styles[2];
            else
                for (; ; ) {
                    var mid = before + after >> 1;
                    if ((mid ? styles[2 * mid - 1] : 0) >= ch)
                        after = mid;
                    else {
                        if (!(styles[2 * mid + 1] < ch)) {
                            type = styles[2 * mid + 2];
                            break
                        }
                        before = mid + 1
                    }
                }
            var cut = type ? type.indexOf("cm-overlay ") : -1;
            return cut < 0 ? type : 0 == cut ? null : type.slice(0, cut - 1)
        },
        getModeAt: function(pos) {
            var mode = this.doc.mode;
            return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode
        },
        getHelper: function(pos, type) {
            return this.getHelpers(pos, type)[0]
        },
        getHelpers: function(pos, type) {
            var found = [];
            if (!helpers.hasOwnProperty(type))
                return helpers;
            var help = helpers[type]
              , mode = this.getModeAt(pos);
            if ("string" == typeof mode[type])
                help[mode[type]] && found.push(help[mode[type]]);
            else if (mode[type])
                for (var i = 0; i < mode[type].length; i++) {
                    var val = help[mode[type][i]];
                    val && found.push(val)
                }
            else
                mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
            for (var i = 0; i < help._global.length; i++) {
                var cur = help._global[i];
                cur.pred(mode, this) && -1 == indexOf(found, cur.val) && found.push(cur.val)
            }
            return found
        },
        getStateAfter: function(line, precise) {
            var doc = this.doc;
            return line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line),
            getStateBefore(this, line + 1, precise)
        },
        cursorCoords: function(start, mode) {
            var pos, range = this.doc.sel.primary();
            return pos = null == start ? range.head : "object" == typeof start ? clipPos(this.doc, start) : start ? range.from() : range.to(),
            cursorCoords(this, pos, mode || "page")
        },
        charCoords: function(pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || "page")
        },
        coordsChar: function(coords, mode) {
            return coords = fromCoordSystem(this, coords, mode || "page"),
            coordsChar(this, coords.left, coords.top)
        },
        lineAtHeight: function(height, mode) {
            return height = fromCoordSystem(this, {
                top: height,
                left: 0
            }, mode || "page").top,
            lineAtHeight(this.doc, height + this.display.viewOffset)
        },
        heightAtLine: function(line, mode) {
            var end = !1
              , last = this.doc.first + this.doc.size - 1;
            line < this.doc.first ? line = this.doc.first : line > last && (line = last,
            end = !0);
            var lineObj = getLine(this.doc, line);
            return intoCoordSystem(this, lineObj, {
                top: 0,
                left: 0
            }, mode || "page").top + (end ? this.doc.height - heightAtLine(lineObj) : 0)
        },
        defaultTextHeight: function() {
            return textHeight(this.display)
        },
        defaultCharWidth: function() {
            return charWidth(this.display)
        },
        setGutterMarker: methodOp(function(line, gutterID, value) {
            return changeLine(this.doc, line, "gutter", function(line) {
                var markers = line.gutterMarkers || (line.gutterMarkers = {});
                return markers[gutterID] = value,
                !value && isEmpty(markers) && (line.gutterMarkers = null),
                !0
            })
        }),
        clearGutter: methodOp(function(gutterID) {
            var cm = this
              , doc = cm.doc
              , i = doc.first;
            doc.iter(function(line) {
                line.gutterMarkers && line.gutterMarkers[gutterID] && (line.gutterMarkers[gutterID] = null,
                regLineChange(cm, i, "gutter"),
                isEmpty(line.gutterMarkers) && (line.gutterMarkers = null)),
                ++i
            })
        }),
        addLineWidget: methodOp(function(handle, node, options) {
            return addLineWidget(this, handle, node, options)
        }),
        removeLineWidget: function(widget) {
            widget.clear()
        },
        lineInfo: function(line) {
            if ("number" == typeof line) {
                if (!isLine(this.doc, line))
                    return null;
                var n = line;
                if (!(line = getLine(this.doc, line)))
                    return null
            } else {
                var n = lineNo(line);
                if (null == n)
                    return null
            }
            return {
                line: n,
                handle: line,
                text: line.text,
                gutterMarkers: line.gutterMarkers,
                textClass: line.textClass,
                bgClass: line.bgClass,
                wrapClass: line.wrapClass,
                widgets: line.widgets
            }
        },
        getViewport: function() {
            return {
                from: this.display.viewFrom,
                to: this.display.viewTo
            }
        },
        addWidget: function(pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom
              , left = pos.left;
            if (node.style.position = "absolute",
            display.sizer.appendChild(node),
            "over" == vert)
                top = pos.top;
            else if ("above" == vert || "near" == vert) {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height)
                  , hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom),
                left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth)
            }
            node.style.top = top + "px",
            node.style.left = node.style.right = "",
            "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth,
            node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2),
            node.style.left = left + "px"),
            scroll && scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight)
        },
        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        execCommand: function(cmd) {
            if (commands.hasOwnProperty(cmd))
                return commands[cmd](this)
        },
        findPosH: function(from, amount, unit, visually) {
            var dir = 1;
            amount < 0 && (dir = -1,
            amount = -amount);
            for (var i = 0, cur = clipPos(this.doc, from); i < amount && (cur = findPosH(this.doc, cur, dir, unit, visually),
            !cur.hitSide); ++i)
                ;
            return cur
        },
        moveH: methodOp(function(dir, unit) {
            var cm = this;
            cm.extendSelectionsBy(function(range) {
                return cm.display.shift || cm.doc.extend || range.empty() ? findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually) : dir < 0 ? range.from() : range.to()
            }, sel_move)
        }),
        deleteH: methodOp(function(dir, unit) {
            var sel = this.doc.sel
              , doc = this.doc;
            sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function(range) {
                var other = findPosH(doc, range.head, dir, unit, !1);
                return dir < 0 ? {
                    from: other,
                    to: range.head
                } : {
                    from: range.head,
                    to: other
                }
            })
        }),
        findPosV: function(from, amount, unit, goalColumn) {
            var dir = 1
              , x = goalColumn;
            amount < 0 && (dir = -1,
            amount = -amount);
            for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                var coords = cursorCoords(this, cur, "div");
                if (null == x ? x = coords.left : coords.left = x,
                cur = findPosV(this, coords, dir, unit),
                cur.hitSide)
                    break
            }
            return cur
        },
        moveV: methodOp(function(dir, unit) {
            var cm = this
              , doc = this.doc
              , goals = []
              , collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
            if (doc.extendSelectionsBy(function(range) {
                if (collapse)
                    return dir < 0 ? range.from() : range.to();
                var headPos = cursorCoords(cm, range.head, "div");
                null != range.goalColumn && (headPos.left = range.goalColumn),
                goals.push(headPos.left);
                var pos = findPosV(cm, headPos, dir, unit);
                return "page" == unit && range == doc.sel.primary() && addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top),
                pos
            }, sel_move),
            goals.length)
                for (var i = 0; i < doc.sel.ranges.length; i++)
                    doc.sel.ranges[i].goalColumn = goals[i]
        }),
        findWordAt: function(pos) {
            var doc = this.doc
              , line = getLine(doc, pos.line).text
              , start = pos.ch
              , end = pos.ch;
            if (line) {
                var helper = this.getHelper(pos, "wordChars");
                (pos.xRel < 0 || end == line.length) && start ? --start : ++end;
                for (var startChar = line.charAt(start), check = isWordChar(startChar, helper) ? function(ch) {
                    return isWordChar(ch, helper)
                }
                : /\s/.test(startChar) ? function(ch) {
                    return /\s/.test(ch)
                }
                : function(ch) {
                    return !/\s/.test(ch) && !isWordChar(ch)
                }
                ; start > 0 && check(line.charAt(start - 1)); )
                    --start;
                for (; end < line.length && check(line.charAt(end)); )
                    ++end
            }
            return new Range(Pos(pos.line, start),Pos(pos.line, end))
        },
        toggleOverwrite: function(value) {
            null != value && value == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? addClass(this.display.cursorDiv, "CodeMirror-overwrite") : rmClass(this.display.cursorDiv, "CodeMirror-overwrite"),
            signal(this, "overwriteToggle", this, this.state.overwrite))
        },
        hasFocus: function() {
            return activeElt() == this.display.input
        },
        scrollTo: methodOp(function(x, y) {
            null == x && null == y || resolveScrollToPos(this),
            null != x && (this.curOp.scrollLeft = x),
            null != y && (this.curOp.scrollTop = y)
        }),
        getScrollInfo: function() {
            var scroller = this.display.scroller
              , co = scrollerCutOff;
            return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height: scroller.scrollHeight - co,
                width: scroller.scrollWidth - co,
                clientHeight: scroller.clientHeight - co,
                clientWidth: scroller.clientWidth - co
            }
        },
        scrollIntoView: methodOp(function(range, margin) {
            if (null == range ? (range = {
                from: this.doc.sel.primary().head,
                to: null
            },
            null == margin && (margin = this.options.cursorScrollMargin)) : "number" == typeof range ? range = {
                from: Pos(range, 0),
                to: null
            } : null == range.from && (range = {
                from: range,
                to: null
            }),
            range.to || (range.to = range.from),
            range.margin = margin || 0,
            null != range.from.line)
                resolveScrollToPos(this),
                this.curOp.scrollToPos = range;
            else {
                var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
                this.scrollTo(sPos.scrollLeft, sPos.scrollTop)
            }
        }),
        setSize: methodOp(function(width, height) {
            function interpret(val) {
                return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val
            }
            var cm = this;
            null != width && (cm.display.wrapper.style.width = interpret(width)),
            null != height && (cm.display.wrapper.style.height = interpret(height)),
            cm.options.lineWrapping && clearLineMeasurementCache(this);
            var lineNo = cm.display.viewFrom;
            cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
                if (line.widgets)
                    for (var i = 0; i < line.widgets.length; i++)
                        if (line.widgets[i].noHScroll) {
                            regLineChange(cm, lineNo, "widget");
                            break
                        }
                ++lineNo
            }),
            cm.curOp.forceUpdate = !0,
            signal(cm, "refresh", this)
        }),
        operation: function(f) {
            return runInOp(this, f)
        },
        refresh: methodOp(function() {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this),
            this.curOp.forceUpdate = !0,
            clearCaches(this),
            this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop),
            updateGutterSpace(this),
            (null == oldHeight || Math.abs(oldHeight - textHeight(this.display)) > .5) && estimateLineHeights(this),
            signal(this, "refresh", this)
        }),
        swapDoc: methodOp(function(doc) {
            var old = this.doc;
            return old.cm = null,
            attachDoc(this, doc),
            clearCaches(this),
            resetInput(this),
            this.scrollTo(doc.scrollLeft, doc.scrollTop),
            this.curOp.forceScroll = !0,
            signalLater(this, "swapDoc", this, old),
            old
        }),
        getInputField: function() {
            return this.display.input
        },
        getWrapperElement: function() {
            return this.display.wrapper
        },
        getScrollerElement: function() {
            return this.display.scroller
        },
        getGutterElement: function() {
            return this.display.gutters
        }
    },
    eventMixin(CodeMirror);
    var defaults = CodeMirror.defaults = {}
      , optionHandlers = CodeMirror.optionHandlers = {}
      , Init = CodeMirror.Init = {
        toString: function() {
            return "CodeMirror.Init"
        }
    };
    option("value", "", function(cm, val) {
        cm.setValue(val)
    }, !0),
    option("mode", null, function(cm, val) {
        cm.doc.modeOption = val,
        loadMode(cm)
    }, !0),
    option("indentUnit", 2, loadMode, !0),
    option("indentWithTabs", !1),
    option("smartIndent", !0),
    option("tabSize", 4, function(cm) {
        resetModeState(cm),
        clearCaches(cm),
        regChange(cm)
    }, !0),
    option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val) {
        cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"),"g"),
        cm.refresh()
    }, !0),
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
        cm.refresh()
    }, !0),
    option("electricChars", !0),
    option("rtlMoveVisually", !windows),
    option("wholeLineUpdateBefore", !0),
    option("theme", "default", function(cm) {
        themeChanged(cm),
        guttersChanged(cm)
    }, !0),
    option("keyMap", "default", function(cm, val, old) {
        var next = getKeyMap(val)
          , prev = old != CodeMirror.Init && getKeyMap(old);
        prev && prev.detach && prev.detach(cm, next),
        next.attach && next.attach(cm, prev || null)
    }),
    option("extraKeys", null),
    option("lineWrapping", !1, wrappingChanged, !0),
    option("gutters", [], function(cm) {
        setGuttersForLineNumbers(cm.options),
        guttersChanged(cm)
    }, !0),
    option("fixedGutter", !0, function(cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0",
        cm.refresh()
    }, !0),
    option("coverGutterNextToScrollbar", !1, updateScrollbars, !0),
    option("lineNumbers", !1, function(cm) {
        setGuttersForLineNumbers(cm.options),
        guttersChanged(cm)
    }, !0),
    option("firstLineNumber", 1, guttersChanged, !0),
    option("lineNumberFormatter", function(integer) {
        return integer
    }, guttersChanged, !0),
    option("showCursorWhenSelecting", !1, updateSelection, !0),
    option("resetSelectionOnContextMenu", !0),
    option("readOnly", !1, function(cm, val) {
        "nocursor" == val ? (onBlur(cm),
        cm.display.input.blur(),
        cm.display.disabled = !0) : (cm.display.disabled = !1,
        val || resetInput(cm))
    }),
    option("disableInput", !1, function(cm, val) {
        val || resetInput(cm)
    }, !0),
    option("dragDrop", !0),
    option("cursorBlinkRate", 530),
    option("cursorScrollMargin", 0),
    option("cursorHeight", 1, updateSelection, !0),
    option("singleCursorHeightPerLine", !0, updateSelection, !0),
    option("workTime", 100),
    option("workDelay", 100),
    option("flattenSpans", !0, resetModeState, !0),
    option("addModeClass", !1, resetModeState, !0),
    option("pollInterval", 100),
    option("undoDepth", 200, function(cm, val) {
        cm.doc.history.undoDepth = val
    }),
    option("historyEventDelay", 1250),
    option("viewportMargin", 10, function(cm) {
        cm.refresh()
    }, !0),
    option("maxHighlightLength", 1e4, resetModeState, !0),
    option("moveInputWithCursor", !0, function(cm, val) {
        val || (cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0)
    }),
    option("tabindex", null, function(cm, val) {
        cm.display.input.tabIndex = val || ""
    }),
    option("autofocus", null);
    var modes = CodeMirror.modes = {}
      , mimeModes = CodeMirror.mimeModes = {};
    CodeMirror.defineMode = function(name, mode) {
        CodeMirror.defaults.mode || "null" == name || (CodeMirror.defaults.mode = name),
        arguments.length > 2 && (mode.dependencies = Array.prototype.slice.call(arguments, 2)),
        modes[name] = mode
    }
    ,
    CodeMirror.defineMIME = function(mime, spec) {
        mimeModes[mime] = spec
    }
    ,
    CodeMirror.resolveMode = function(spec) {
        if ("string" == typeof spec && mimeModes.hasOwnProperty(spec))
            spec = mimeModes[spec];
        else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            "string" == typeof found && (found = {
                name: found
            }),
            spec = createObj(found, spec),
            spec.name = found.name
        } else if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
            return CodeMirror.resolveMode("application/xml");
        return "string" == typeof spec ? {
            name: spec
        } : spec || {
            name: "null"
        }
    }
    ,
    CodeMirror.getMode = function(options, spec) {
        var spec = CodeMirror.resolveMode(spec)
          , mfactory = modes[spec.name];
        if (!mfactory)
            return CodeMirror.getMode(options, "text/plain");
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop in exts)
                exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]),
                modeObj[prop] = exts[prop])
        }
        if (modeObj.name = spec.name,
        spec.helperType && (modeObj.helperType = spec.helperType),
        spec.modeProps)
            for (var prop in spec.modeProps)
                modeObj[prop] = spec.modeProps[prop];
        return modeObj
    }
    ,
    CodeMirror.defineMode("null", function() {
        return {
            token: function(stream) {
                stream.skipToEnd()
            }
        }
    }),
    CodeMirror.defineMIME("text/plain", "null");
    var modeExtensions = CodeMirror.modeExtensions = {};
    CodeMirror.extendMode = function(mode, properties) {
        copyObj(properties, modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {})
    }
    ,
    CodeMirror.defineExtension = function(name, func) {
        CodeMirror.prototype[name] = func
    }
    ,
    CodeMirror.defineDocExtension = function(name, func) {
        Doc.prototype[name] = func
    }
    ,
    CodeMirror.defineOption = option;
    var initHooks = [];
    CodeMirror.defineInitHook = function(f) {
        initHooks.push(f)
    }
    ;
    var helpers = CodeMirror.helpers = {};
    CodeMirror.registerHelper = function(type, name, value) {
        helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {
            _global: []
        }),
        helpers[type][name] = value
    }
    ,
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
        CodeMirror.registerHelper(type, name, value),
        helpers[type]._global.push({
            pred: predicate,
            val: value
        })
    }
    ;
    var copyState = CodeMirror.copyState = function(mode, state) {
        if (!0 === state)
            return state;
        if (mode.copyState)
            return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
            var val = state[n];
            val instanceof Array && (val = val.concat([])),
            nstate[n] = val
        }
        return nstate
    }
      , startState = CodeMirror.startState = function(mode, a1, a2) {
        return !mode.startState || mode.startState(a1, a2)
    }
    ;
    CodeMirror.innerMode = function(mode, state) {
        for (; mode.innerMode; ) {
            var info = mode.innerMode(state);
            if (!info || info.mode == mode)
                break;
            state = info.state,
            mode = info.mode
        }
        return info || {
            mode: mode,
            state: state
        }
    }
    ;
    var commands = CodeMirror.commands = {
        selectAll: function(cm) {
            cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
        },
        singleSelection: function(cm) {
            cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll)
        },
        killLine: function(cm) {
            deleteNearSelection(cm, function(range) {
                if (range.empty()) {
                    var len = getLine(cm.doc, range.head.line).text.length;
                    return range.head.ch == len && range.head.line < cm.lastLine() ? {
                        from: range.head,
                        to: Pos(range.head.line + 1, 0)
                    } : {
                        from: range.head,
                        to: Pos(range.head.line, len)
                    }
                }
                return {
                    from: range.from(),
                    to: range.to()
                }
            })
        },
        deleteLine: function(cm) {
            deleteNearSelection(cm, function(range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                }
            })
        },
        delLineLeft: function(cm) {
            deleteNearSelection(cm, function(range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: range.from()
                }
            })
        },
        delWrappedLineLeft: function(cm) {
            deleteNearSelection(cm, function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return {
                    from: cm.coordsChar({
                        left: 0,
                        top: top
                    }, "div"),
                    to: range.from()
                }
            })
        },
        delWrappedLineRight: function(cm) {
            deleteNearSelection(cm, function(range) {
                var top = cm.charCoords(range.head, "div").top + 5
                  , rightPos = cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, "div");
                return {
                    from: range.from(),
                    to: rightPos
                }
            })
        },
        undo: function(cm) {
            cm.undo()
        },
        redo: function(cm) {
            cm.redo()
        },
        undoSelection: function(cm) {
            cm.undoSelection()
        },
        redoSelection: function(cm) {
            cm.redoSelection()
        },
        goDocStart: function(cm) {
            cm.extendSelection(Pos(cm.firstLine(), 0))
        },
        goDocEnd: function(cm) {
            cm.extendSelection(Pos(cm.lastLine()))
        },
        goLineStart: function(cm) {
            cm.extendSelectionsBy(function(range) {
                return lineStart(cm, range.head.line)
            }, {
                origin: "+move",
                bias: 1
            })
        },
        goLineStartSmart: function(cm) {
            cm.extendSelectionsBy(function(range) {
                return lineStartSmart(cm, range.head)
            }, {
                origin: "+move",
                bias: 1
            })
        },
        goLineEnd: function(cm) {
            cm.extendSelectionsBy(function(range) {
                return lineEnd(cm, range.head.line)
            }, {
                origin: "+move",
                bias: -1
            })
        },
        goLineRight: function(cm) {
            cm.extendSelectionsBy(function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, "div")
            }, sel_move)
        },
        goLineLeft: function(cm) {
            cm.extendSelectionsBy(function(range) {
                var top = cm.charCoords(range.head, "div").top + 5;
                return cm.coordsChar({
                    left: 0,
                    top: top
                }, "div")
            }, sel_move)
        },
        goLineLeftSmart: function(cm) {
            cm.extendSelectionsBy(function(range) {
                var top = cm.charCoords(range.head, "div").top + 5
                  , pos = cm.coordsChar({
                    left: 0,
                    top: top
                }, "div");
                return pos.ch < cm.getLine(pos.line).search(/\S/) ? lineStartSmart(cm, range.head) : pos
            }, sel_move)
        },
        goLineUp: function(cm) {
            cm.moveV(-1, "line")
        },
        goLineDown: function(cm) {
            cm.moveV(1, "line")
        },
        goPageUp: function(cm) {
            cm.moveV(-1, "page")
        },
        goPageDown: function(cm) {
            cm.moveV(1, "page")
        },
        goCharLeft: function(cm) {
            cm.moveH(-1, "char")
        },
        goCharRight: function(cm) {
            cm.moveH(1, "char")
        },
        goColumnLeft: function(cm) {
            cm.moveH(-1, "column")
        },
        goColumnRight: function(cm) {
            cm.moveH(1, "column")
        },
        goWordLeft: function(cm) {
            cm.moveH(-1, "word")
        },
        goGroupRight: function(cm) {
            cm.moveH(1, "group")
        },
        goGroupLeft: function(cm) {
            cm.moveH(-1, "group")
        },
        goWordRight: function(cm) {
            cm.moveH(1, "word")
        },
        delCharBefore: function(cm) {
            cm.deleteH(-1, "char")
        },
        delCharAfter: function(cm) {
            cm.deleteH(1, "char")
        },
        delWordBefore: function(cm) {
            cm.deleteH(-1, "word")
        },
        delWordAfter: function(cm) {
            cm.deleteH(1, "word")
        },
        delGroupBefore: function(cm) {
            cm.deleteH(-1, "group")
        },
        delGroupAfter: function(cm) {
            cm.deleteH(1, "group")
        },
        indentAuto: function(cm) {
            cm.indentSelection("smart")
        },
        indentMore: function(cm) {
            cm.indentSelection("add")
        },
        indentLess: function(cm) {
            cm.indentSelection("subtract")
        },
        insertTab: function(cm) {
            cm.replaceSelection("\t")
        },
        insertSoftTab: function(cm) {
            for (var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize, i = 0; i < ranges.length; i++) {
                var pos = ranges[i].from()
                  , col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                spaces.push(new Array(tabSize - col % tabSize + 1).join(" "))
            }
            cm.replaceSelections(spaces)
        },
        defaultTab: function(cm) {
            cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab")
        },
        transposeChars: function(cm) {
            runInOp(cm, function() {
                for (var ranges = cm.listSelections(), newSel = [], i = 0; i < ranges.length; i++) {
                    var cur = ranges[i].head
                      , line = getLine(cm.doc, cur.line).text;
                    if (line)
                        if (cur.ch == line.length && (cur = new Pos(cur.line,cur.ch - 1)),
                        cur.ch > 0)
                            cur = new Pos(cur.line,cur.ch + 1),
                            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                        else if (cur.line > cm.doc.first) {
                            var prev = getLine(cm.doc, cur.line - 1).text;
                            prev && cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose")
                        }
                    newSel.push(new Range(cur,cur))
                }
                cm.setSelections(newSel)
            })
        },
        newlineAndIndent: function(cm) {
            runInOp(cm, function() {
                for (var len = cm.listSelections().length, i = 0; i < len; i++) {
                    var range = cm.listSelections()[i];
                    cm.replaceRange("\n", range.anchor, range.head, "+input"),
                    cm.indentLine(range.from().line + 1, null, !0),
                    ensureCursorVisible(cm)
                }
            })
        },
        toggleOverwrite: function(cm) {
            cm.toggleOverwrite()
        }
    }
      , keyMap = CodeMirror.keyMap = {};
    keyMap.basic = {
        Left: "goCharLeft",
        Right: "goCharRight",
        Up: "goLineUp",
        Down: "goLineDown",
        End: "goLineEnd",
        Home: "goLineStartSmart",
        PageUp: "goPageUp",
        PageDown: "goPageDown",
        Delete: "delCharAfter",
        Backspace: "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        Tab: "defaultTab",
        "Shift-Tab": "indentAuto",
        Enter: "newlineAndIndent",
        Insert: "toggleOverwrite",
        Esc: "singleSelection"
    },
    keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
    },
    keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight",
        "Alt-B": "goWordLeft",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars"
    },
    keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: ["basic", "emacsy"]
    },
    keyMap.default = mac ? keyMap.macDefault : keyMap.pcDefault,
    CodeMirror.normalizeKeyMap = function(keymap) {
        var copy = {};
        for (var keyname in keymap)
            if (keymap.hasOwnProperty(keyname)) {
                var value = keymap[keyname];
                if (/^(name|fallthrough|(de|at)tach)$/.test(keyname))
                    continue;
                if ("..." == value) {
                    delete keymap[keyname];
                    continue
                }
                for (var keys = map(keyname.split(" "), normalizeKeyName), i = 0; i < keys.length; i++) {
                    var val, name;
                    i == keys.length - 1 ? (name = keyname,
                    val = value) : (name = keys.slice(0, i + 1).join(" "),
                    val = "...");
                    var prev = copy[name];
                    if (prev) {
                        if (prev != val)
                            throw new Error("Inconsistent bindings for " + name)
                    } else
                        copy[name] = val
                }
                delete keymap[keyname]
            }
        for (var prop in copy)
            keymap[prop] = copy[prop];
        return keymap
    }
    ;
    var lookupKey = CodeMirror.lookupKey = function(key, map, handle) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key) : map[key];
        if (!1 === found)
            return "nothing";
        if ("..." === found)
            return "multi";
        if (null != found && handle(found))
            return "handled";
        if (map.fallthrough) {
            if ("[object Array]" != Object.prototype.toString.call(map.fallthrough))
                return lookupKey(key, map.fallthrough, handle);
            for (var i = 0; i < map.fallthrough.length; i++) {
                var result = lookupKey(key, map.fallthrough[i], handle);
                if (result)
                    return result
            }
        }
    }
      , isModifierKey = CodeMirror.isModifierKey = function(value) {
        var name = "string" == typeof value ? value : keyNames[value.keyCode];
        return "Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name
    }
      , keyName = CodeMirror.keyName = function(event, noShift) {
        if (presto && 34 == event.keyCode && event.char)
            return !1;
        var base = keyNames[event.keyCode]
          , name = base;
        return null != name && !event.altGraphKey && (event.altKey && "Alt" != base && (name = "Alt-" + name),
        (flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name),
        (flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Cmd" != base && (name = "Cmd-" + name),
        !noShift && event.shiftKey && "Shift" != base && (name = "Shift-" + name),
        name)
    }
    ;
    CodeMirror.fromTextArea = function(textarea, options) {
        function save() {
            textarea.value = cm.getValue()
        }
        if (options || (options = {}),
        options.value = textarea.value,
        !options.tabindex && textarea.tabindex && (options.tabindex = textarea.tabindex),
        !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder),
        null == options.autofocus) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body
        }
        if (textarea.form && (on(textarea.form, "submit", save),
        !options.leaveSubmitMethodAlone)) {
            var form = textarea.form
              , realSubmit = form.submit;
            try {
                var wrappedSubmit = form.submit = function() {
                    save(),
                    form.submit = realSubmit,
                    form.submit(),
                    form.submit = wrappedSubmit
                }
            } catch (e) {}
        }
        textarea.style.display = "none";
        var cm = CodeMirror(function(node) {
            textarea.parentNode.insertBefore(node, textarea.nextSibling)
        }, options);
        return cm.save = save,
        cm.getTextArea = function() {
            return textarea
        }
        ,
        cm.toTextArea = function() {
            cm.toTextArea = isNaN,
            save(),
            textarea.parentNode.removeChild(cm.getWrapperElement()),
            textarea.style.display = "",
            textarea.form && (off(textarea.form, "submit", save),
            "function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit))
        }
        ,
        cm
    }
    ;
    var StringStream = CodeMirror.StringStream = function(string, tabSize) {
        this.pos = this.start = 0,
        this.string = string,
        this.tabSize = tabSize || 8,
        this.lastColumnPos = this.lastColumnValue = 0,
        this.lineStart = 0
    }
    ;
    StringStream.prototype = {
        eol: function() {
            return this.pos >= this.string.length
        },
        sol: function() {
            return this.pos == this.lineStart
        },
        peek: function() {
            return this.string.charAt(this.pos) || void 0
        },
        next: function() {
            if (this.pos < this.string.length)
                return this.string.charAt(this.pos++)
        },
        eat: function(match) {
            var ch = this.string.charAt(this.pos);
            if ("string" == typeof match)
                var ok = ch == match;
            else
                var ok = ch && (match.test ? match.test(ch) : match(ch));
            if (ok)
                return ++this.pos,
                ch
        },
        eatWhile: function(match) {
            for (var start = this.pos; this.eat(match); )
                ;
            return this.pos > start
        },
        eatSpace: function() {
            for (var start = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
                ++this.pos;
            return this.pos > start
        },
        skipToEnd: function() {
            this.pos = this.string.length
        },
        skipTo: function(ch) {
            var found = this.string.indexOf(ch, this.pos);
            if (found > -1)
                return this.pos = found,
                !0
        },
        backUp: function(n) {
            this.pos -= n
        },
        column: function() {
            return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue),
            this.lastColumnPos = this.start),
            this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
        },
        indentation: function() {
            return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
        },
        match: function(pattern, consume, caseInsensitive) {
            if ("string" != typeof pattern) {
                var match = this.string.slice(this.pos).match(pattern);
                return match && match.index > 0 ? null : (match && !1 !== consume && (this.pos += match[0].length),
                match)
            }
            var cased = function(str) {
                return caseInsensitive ? str.toLowerCase() : str
            };
            if (cased(this.string.substr(this.pos, pattern.length)) == cased(pattern))
                return !1 !== consume && (this.pos += pattern.length),
                !0
        },
        current: function() {
            return this.string.slice(this.start, this.pos)
        },
        hideFirstChars: function(n, inner) {
            this.lineStart += n;
            try {
                return inner()
            } finally {
                this.lineStart -= n
            }
        }
    };
    var TextMarker = CodeMirror.TextMarker = function(doc, type) {
        this.lines = [],
        this.type = type,
        this.doc = doc
    }
    ;
    eventMixin(TextMarker),
    TextMarker.prototype.clear = function() {
        if (!this.explicitlyCleared) {
            var cm = this.doc.cm
              , withOp = cm && !cm.curOp;
            if (withOp && startOperation(cm),
            hasHandler(this, "clear")) {
                var found = this.find();
                found && signalLater(this, "clear", found.from, found.to)
            }
            for (var min = null, max = null, i = 0; i < this.lines.length; ++i) {
                var line = this.lines[i]
                  , span = getMarkedSpanFor(line.markedSpans, this);
                cm && !this.collapsed ? regLineChange(cm, lineNo(line), "text") : cm && (null != span.to && (max = lineNo(line)),
                null != span.from && (min = lineNo(line))),
                line.markedSpans = removeMarkedSpan(line.markedSpans, span),
                null == span.from && this.collapsed && !lineIsHidden(this.doc, line) && cm && updateLineHeight(line, textHeight(cm.display))
            }
            if (cm && this.collapsed && !cm.options.lineWrapping)
                for (var i = 0; i < this.lines.length; ++i) {
                    var visual = visualLine(this.lines[i])
                      , len = lineLength(visual);
                    len > cm.display.maxLineLength && (cm.display.maxLine = visual,
                    cm.display.maxLineLength = len,
                    cm.display.maxLineChanged = !0)
                }
            null != min && cm && this.collapsed && regChange(cm, min, max + 1),
            this.lines.length = 0,
            this.explicitlyCleared = !0,
            this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1,
            cm && reCheckSelection(cm.doc)),
            cm && signalLater(cm, "markerCleared", cm, this),
            withOp && endOperation(cm),
            this.parent && this.parent.clear()
        }
    }
    ,
    TextMarker.prototype.find = function(side, lineObj) {
        null == side && "bookmark" == this.type && (side = 1);
        for (var from, to, i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i]
              , span = getMarkedSpanFor(line.markedSpans, this);
            if (null != span.from && (from = Pos(lineObj ? line : lineNo(line), span.from),
            -1 == side))
                return from;
            if (null != span.to && (to = Pos(lineObj ? line : lineNo(line), span.to),
            1 == side))
                return to
        }
        return from && {
            from: from,
            to: to
        }
    }
    ,
    TextMarker.prototype.changed = function() {
        var pos = this.find(-1, !0)
          , widget = this
          , cm = this.doc.cm;
        pos && cm && runInOp(cm, function() {
            var line = pos.line
              , lineN = lineNo(pos.line)
              , view = findViewForLine(cm, lineN);
            if (view && (clearLineMeasurementCacheFor(view),
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0),
            cm.curOp.updateMaxLine = !0,
            !lineIsHidden(widget.doc, line) && null != widget.height) {
                var oldHeight = widget.height;
                widget.height = null;
                var dHeight = widgetHeight(widget) - oldHeight;
                dHeight && updateLineHeight(line, line.height + dHeight)
            }
        })
    }
    ,
    TextMarker.prototype.attachLine = function(line) {
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            op.maybeHiddenMarkers && -1 != indexOf(op.maybeHiddenMarkers, this) || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this)
        }
        this.lines.push(line)
    }
    ,
    TextMarker.prototype.detachLine = function(line) {
        if (this.lines.splice(indexOf(this.lines, line), 1),
        !this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
        }
    }
    ;
    var nextMarkerId = 0
      , SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
        this.markers = markers,
        this.primary = primary;
        for (var i = 0; i < markers.length; ++i)
            markers[i].parent = this
    }
    ;
    eventMixin(SharedTextMarker),
    SharedTextMarker.prototype.clear = function() {
        if (!this.explicitlyCleared) {
            this.explicitlyCleared = !0;
            for (var i = 0; i < this.markers.length; ++i)
                this.markers[i].clear();
            signalLater(this, "clear")
        }
    }
    ,
    SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj)
    }
    ;
    var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
        if (options)
            for (var opt in options)
                options.hasOwnProperty(opt) && (this[opt] = options[opt]);
        this.cm = cm,
        this.node = node
    }
    ;
    eventMixin(LineWidget),
    LineWidget.prototype.clear = function() {
        var cm = this.cm
          , ws = this.line.widgets
          , line = this.line
          , no = lineNo(line);
        if (null != no && ws) {
            for (var i = 0; i < ws.length; ++i)
                ws[i] == this && ws.splice(i--, 1);
            ws.length || (line.widgets = null);
            var height = widgetHeight(this);
            runInOp(cm, function() {
                adjustScrollWhenAboveVisible(cm, line, -height),
                regLineChange(cm, no, "widget"),
                updateLineHeight(line, Math.max(0, line.height - height))
            })
        }
    }
    ,
    LineWidget.prototype.changed = function() {
        var oldH = this.height
          , cm = this.cm
          , line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        diff && runInOp(cm, function() {
            cm.curOp.forceUpdate = !0,
            adjustScrollWhenAboveVisible(cm, line, diff),
            updateLineHeight(line, line.height + diff)
        })
    }
    ;
    var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
        this.text = text,
        attachMarkedSpans(this, markedSpans),
        this.height = estimateHeight ? estimateHeight(this) : 1
    }
    ;
    eventMixin(Line),
    Line.prototype.lineNo = function() {
        return lineNo(this)
    }
    ;
    var styleToClassCache = {}
      , styleToClassCacheWithMode = {};
    LeafChunk.prototype = {
        chunkSize: function() {
            return this.lines.length
        },
        removeInner: function(at, n) {
            for (var i = at, e = at + n; i < e; ++i) {
                var line = this.lines[i];
                this.height -= line.height,
                cleanUpLine(line),
                signalLater(line, "delete")
            }
            this.lines.splice(at, n)
        },
        collapse: function(lines) {
            lines.push.apply(lines, this.lines)
        },
        insertInner: function(at, lines, height) {
            this.height += height,
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i = 0; i < lines.length; ++i)
                lines[i].parent = this
        },
        iterN: function(at, n, op) {
            for (var e = at + n; at < e; ++at)
                if (op(this.lines[at]))
                    return !0
        }
    },
    BranchChunk.prototype = {
        chunkSize: function() {
            return this.size
        },
        removeInner: function(at, n) {
            this.size -= n;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i]
                  , sz = child.chunkSize();
                if (at < sz) {
                    var rm = Math.min(n, sz - at)
                      , oldHeight = child.height;
                    if (child.removeInner(at, rm),
                    this.height -= oldHeight - child.height,
                    sz == rm && (this.children.splice(i--, 1),
                    child.parent = null),
                    0 == (n -= rm))
                        break;
                    at = 0
                } else
                    at -= sz
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0]instanceof LeafChunk))) {
                var lines = [];
                this.collapse(lines),
                this.children = [new LeafChunk(lines)],
                this.children[0].parent = this
            }
        },
        collapse: function(lines) {
            for (var i = 0; i < this.children.length; ++i)
                this.children[i].collapse(lines)
        },
        insertInner: function(at, lines, height) {
            this.size += lines.length,
            this.height += height;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i]
                  , sz = child.chunkSize();
                if (at <= sz) {
                    if (child.insertInner(at, lines, height),
                    child.lines && child.lines.length > 50) {
                        for (; child.lines.length > 50; ) {
                            var spilled = child.lines.splice(child.lines.length - 25, 25)
                              , newleaf = new LeafChunk(spilled);
                            child.height -= newleaf.height,
                            this.children.splice(i + 1, 0, newleaf),
                            newleaf.parent = this
                        }
                        this.maybeSpill()
                    }
                    break
                }
                at -= sz
            }
        },
        maybeSpill: function() {
            if (!(this.children.length <= 10)) {
                var me = this;
                do {
                    var spilled = me.children.splice(me.children.length - 5, 5)
                      , sibling = new BranchChunk(spilled);
                    if (me.parent) {
                        me.size -= sibling.size,
                        me.height -= sibling.height;
                        var myIndex = indexOf(me.parent.children, me);
                        me.parent.children.splice(myIndex + 1, 0, sibling)
                    } else {
                        var copy = new BranchChunk(me.children);
                        copy.parent = me,
                        me.children = [copy, sibling],
                        me = copy
                    }
                    sibling.parent = me.parent
                } while (me.children.length > 10);
                me.parent.maybeSpill()
            }
        },
        iterN: function(at, n, op) {
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i]
                  , sz = child.chunkSize();
                if (at < sz) {
                    var used = Math.min(n, sz - at);
                    if (child.iterN(at, used, op))
                        return !0;
                    if (0 == (n -= used))
                        break;
                    at = 0
                } else
                    at -= sz
            }
        }
    };
    var nextDocId = 0
      , Doc = CodeMirror.Doc = function(text, mode, firstLine) {
        if (!(this instanceof Doc))
            return new Doc(text,mode,firstLine);
        null == firstLine && (firstLine = 0),
        BranchChunk.call(this, [new LeafChunk([new Line("",null)])]),
        this.first = firstLine,
        this.scrollTop = this.scrollLeft = 0,
        this.cantEdit = !1,
        this.cleanGeneration = 1,
        this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start),
        this.history = new History(null),
        this.id = ++nextDocId,
        this.modeOption = mode,
        "string" == typeof text && (text = splitLines(text)),
        updateDoc(this, {
            from: start,
            to: start,
            text: text
        }),
        setSelection(this, simpleSelection(start), sel_dontScroll)
    }
    ;
    Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function(from, to, op) {
            op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from)
        },
        insert: function(at, lines) {
            for (var height = 0, i = 0; i < lines.length; ++i)
                height += lines[i].height;
            this.insertInner(at - this.first, lines, height)
        },
        remove: function(at, n) {
            this.removeInner(at - this.first, n)
        },
        getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            return !1 === lineSep ? lines : lines.join(lineSep || "\n")
        },
        setValue: docMethodOp(function(code) {
            var top = Pos(this.first, 0)
              , last = this.first + this.size - 1;
            makeChange(this, {
                from: top,
                to: Pos(last, getLine(this, last).text.length),
                text: splitLines(code),
                origin: "setValue"
            }, !0),
            setSelection(this, simpleSelection(top))
        }),
        replaceRange: function(code, from, to, origin) {
            from = clipPos(this, from),
            to = to ? clipPos(this, to) : from,
            replaceRange(this, code, from, to, origin)
        },
        getRange: function(from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            return !1 === lineSep ? lines : lines.join(lineSep || "\n")
        },
        getLine: function(line) {
            var l = this.getLineHandle(line);
            return l && l.text
        },
        getLineHandle: function(line) {
            if (isLine(this, line))
                return getLine(this, line)
        },
        getLineNumber: function(line) {
            return lineNo(line)
        },
        getLineHandleVisualStart: function(line) {
            return "number" == typeof line && (line = getLine(this, line)),
            visualLine(line)
        },
        lineCount: function() {
            return this.size
        },
        firstLine: function() {
            return this.first
        },
        lastLine: function() {
            return this.first + this.size - 1
        },
        clipPos: function(pos) {
            return clipPos(this, pos)
        },
        getCursor: function(start) {
            var range = this.sel.primary();
            return null == start || "head" == start ? range.head : "anchor" == start ? range.anchor : "end" == start || "to" == start || !1 === start ? range.to() : range.from()
        },
        listSelections: function() {
            return this.sel.ranges
        },
        somethingSelected: function() {
            return this.sel.somethingSelected()
        },
        setCursor: docMethodOp(function(line, ch, options) {
            setSimpleSelection(this, clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options)
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)
        }),
        extendSelection: docMethodOp(function(head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)
        }),
        extendSelections: docMethodOp(function(heads, options) {
            extendSelections(this, clipPosArray(this, heads))
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
            extendSelections(this, map(this.sel.ranges, f), options)
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
            if (ranges.length) {
                for (var i = 0, out = []; i < ranges.length; i++)
                    out[i] = new Range(clipPos(this, ranges[i].anchor),clipPos(this, ranges[i].head));
                null == primary && (primary = Math.min(ranges.length - 1, this.sel.primIndex)),
                setSelection(this, normalizeSelection(out, primary), options)
            }
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor),clipPos(this, head || anchor))),
            setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)
        }),
        getSelection: function(lineSep) {
            for (var lines, ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                lines = lines ? lines.concat(sel) : sel
            }
            return !1 === lineSep ? lines : lines.join(lineSep || "\n")
        },
        getSelections: function(lineSep) {
            for (var parts = [], ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                !1 !== lineSep && (sel = sel.join(lineSep || "\n")),
                parts[i] = sel
            }
            return parts
        },
        replaceSelection: function(code, collapse, origin) {
            for (var dup = [], i = 0; i < this.sel.ranges.length; i++)
                dup[i] = code;
            this.replaceSelections(dup, collapse, origin || "+input")
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
            for (var changes = [], sel = this.sel, i = 0; i < sel.ranges.length; i++) {
                var range = sel.ranges[i];
                changes[i] = {
                    from: range.from(),
                    to: range.to(),
                    text: splitLines(code[i]),
                    origin: origin
                }
            }
            for (var newSel = collapse && "end" != collapse && computeReplacedSel(this, changes, collapse), i = changes.length - 1; i >= 0; i--)
                makeChange(this, changes[i]);
            newSel ? setSelectionReplaceHistory(this, newSel) : this.cm && ensureCursorVisible(this.cm)
        }),
        undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo")
        }),
        redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo")
        }),
        undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", !0)
        }),
        redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", !0)
        }),
        setExtending: function(val) {
            this.extend = val
        },
        getExtending: function() {
            return this.extend
        },
        historySize: function() {
            for (var hist = this.history, done = 0, undone = 0, i = 0; i < hist.done.length; i++)
                hist.done[i].ranges || ++done;
            for (var i = 0; i < hist.undone.length; i++)
                hist.undone[i].ranges || ++undone;
            return {
                undo: done,
                redo: undone
            }
        },
        clearHistory: function() {
            this.history = new History(this.history.maxGeneration)
        },
        markClean: function() {
            this.cleanGeneration = this.changeGeneration(!0)
        },
        changeGeneration: function(forceSplit) {
            return forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null),
            this.history.generation
        },
        isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration)
        },
        getHistory: function() {
            return {
                done: copyHistoryArray(this.history.done),
                undone: copyHistoryArray(this.history.undone)
            }
        },
        setHistory: function(histData) {
            var hist = this.history = new History(this.history.maxGeneration);
            hist.done = copyHistoryArray(histData.done.slice(0), null, !0),
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, !0)
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
                if (line[prop]) {
                    if (classTest(cls).test(line[prop]))
                        return !1;
                    line[prop] += " " + cls
                } else
                    line[prop] = cls;
                return !0
            })
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, "class", function(line) {
                var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass"
                  , cur = line[prop];
                if (!cur)
                    return !1;
                if (null == cls)
                    line[prop] = null;
                else {
                    var found = cur.match(classTest(cls));
                    if (!found)
                        return !1;
                    var end = found.index + found[0].length;
                    line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null
                }
                return !0
            })
        }),
        markText: function(from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, "range")
        },
        setBookmark: function(pos, options) {
            var realOpts = {
                replacedWith: options && (null == options.nodeType ? options.widget : options),
                insertLeft: options && options.insertLeft,
                clearWhenEmpty: !1,
                shared: options && options.shared
            };
            return pos = clipPos(this, pos),
            markText(this, pos, pos, realOpts, "bookmark")
        },
        findMarksAt: function(pos) {
            pos = clipPos(this, pos);
            var markers = []
              , spans = getLine(this, pos.line).markedSpans;
            if (spans)
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker)
                }
            return markers
        },
        findMarks: function(from, to, filter) {
            from = clipPos(this, from),
            to = clipPos(this, to);
            var found = []
              , lineNo = from.line;
            return this.iter(from.line, to.line + 1, function(line) {
                var spans = line.markedSpans;
                if (spans)
                    for (var i = 0; i < spans.length; i++) {
                        var span = spans[i];
                        lineNo == from.line && from.ch > span.to || null == span.from && lineNo != from.line || lineNo == to.line && span.from > to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker)
                    }
                ++lineNo
            }),
            found
        },
        getAllMarks: function() {
            var markers = [];
            return this.iter(function(line) {
                var sps = line.markedSpans;
                if (sps)
                    for (var i = 0; i < sps.length; ++i)
                        null != sps[i].from && markers.push(sps[i].marker)
            }),
            markers
        },
        posFromIndex: function(off) {
            var ch, lineNo = this.first;
            return this.iter(function(line) {
                var sz = line.text.length + 1;
                if (sz > off)
                    return ch = off,
                    !0;
                off -= sz,
                ++lineNo
            }),
            clipPos(this, Pos(lineNo, ch))
        },
        indexFromPos: function(coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            return coords.line < this.first || coords.ch < 0 ? 0 : (this.iter(this.first, coords.line, function(line) {
                index += line.text.length + 1
            }),
            index)
        },
        copy: function(copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size),this.modeOption,this.first);
            return doc.scrollTop = this.scrollTop,
            doc.scrollLeft = this.scrollLeft,
            doc.sel = this.sel,
            doc.extend = !1,
            copyHistory && (doc.history.undoDepth = this.history.undoDepth,
            doc.setHistory(this.getHistory())),
            doc
        },
        linkedDoc: function(options) {
            options || (options = {});
            var from = this.first
              , to = this.first + this.size;
            null != options.from && options.from > from && (from = options.from),
            null != options.to && options.to < to && (to = options.to);
            var copy = new Doc(getLines(this, from, to),options.mode || this.modeOption,from);
            return options.sharedHist && (copy.history = this.history),
            (this.linked || (this.linked = [])).push({
                doc: copy,
                sharedHist: options.sharedHist
            }),
            copy.linked = [{
                doc: this,
                isParent: !0,
                sharedHist: options.sharedHist
            }],
            copySharedMarkers(copy, findSharedMarkers(this)),
            copy
        },
        unlinkDoc: function(other) {
            if (other instanceof CodeMirror && (other = other.doc),
            this.linked)
                for (var i = 0; i < this.linked.length; ++i) {
                    var link = this.linked[i];
                    if (link.doc == other) {
                        this.linked.splice(i, 1),
                        other.unlinkDoc(this),
                        detachSharedMarkers(findSharedMarkers(this));
                        break
                    }
                }
            if (other.history == this.history) {
                var splitIds = [other.id];
                linkedDocs(other, function(doc) {
                    splitIds.push(doc.id)
                }, !0),
                other.history = new History(null),
                other.history.done = copyHistoryArray(this.history.done, splitIds),
                other.history.undone = copyHistoryArray(this.history.undone, splitIds)
            }
        },
        iterLinkedDocs: function(f) {
            linkedDocs(this, f)
        },
        getMode: function() {
            return this.mode
        },
        getEditor: function() {
            return this.cm
        }
    }),
    Doc.prototype.eachLine = Doc.prototype.iter;
    var dontDelegate = "iter insert remove copy getEditor".split(" ");
    for (var prop in Doc.prototype)
        Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror.prototype[prop] = function(method) {
            return function() {
                return method.apply(this.doc, arguments)
            }
        }(Doc.prototype[prop]));
    eventMixin(Doc);
    var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
        e.preventDefault ? e.preventDefault() : e.returnValue = !1
    }
      , e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
        e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
    }
      , e_stop = CodeMirror.e_stop = function(e) {
        e_preventDefault(e),
        e_stopPropagation(e)
    }
      , on = CodeMirror.on = function(emitter, type, f) {
        if (emitter.addEventListener)
            emitter.addEventListener(type, f, !1);
        else if (emitter.attachEvent)
            emitter.attachEvent("on" + type, f);
        else {
            var map = emitter._handlers || (emitter._handlers = {})
              , arr = map[type] || (map[type] = []);
            arr.push(f)
        }
    }
      , off = CodeMirror.off = function(emitter, type, f) {
        if (emitter.removeEventListener)
            emitter.removeEventListener(type, f, !1);
        else if (emitter.detachEvent)
            emitter.detachEvent("on" + type, f);
        else {
            var arr = emitter._handlers && emitter._handlers[type];
            if (!arr)
                return;
            for (var i = 0; i < arr.length; ++i)
                if (arr[i] == f) {
                    arr.splice(i, 1);
                    break
                }
        }
    }
      , signal = CodeMirror.signal = function(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (arr)
            for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < arr.length; ++i)
                arr[i].apply(null, args)
    }
      , orphanDelayedCallbacks = null
      , scrollerCutOff = 30
      , Pass = CodeMirror.Pass = {
        toString: function() {
            return "CodeMirror.Pass"
        }
    }
      , sel_dontScroll = {
        scroll: !1
    }
      , sel_mouse = {
        origin: "*mouse"
    }
      , sel_move = {
        origin: "+move"
    };
    Delayed.prototype.set = function(ms, f) {
        clearTimeout(this.id),
        this.id = setTimeout(f, ms)
    }
    ;
    var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
        null == end && -1 == (end = string.search(/[^\s\u00a0]/)) && (end = string.length);
        for (var i = startIndex || 0, n = startValue || 0; ; ) {
            var nextTab = string.indexOf("\t", i);
            if (nextTab < 0 || nextTab >= end)
                return n + (end - i);
            n += nextTab - i,
            n += tabSize - n % tabSize,
            i = nextTab + 1
        }
    }
      , spaceStrs = [""]
      , selectInput = function(node) {
        node.select()
    };
    ios ? selectInput = function(node) {
        node.selectionStart = 0,
        node.selectionEnd = node.value.length
    }
    : ie && (selectInput = function(node) {
        try {
            node.select()
        } catch (_e) {}
    }
    ),
    [].indexOf && (indexOf = function(array, elt) {
        return array.indexOf(elt)
    }
    ),
    [].map && (map = function(array, f) {
        return array.map(f)
    }
    );
    var range, nonASCIISingleCaseWordChar = /[\u00df\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, isWordCharBasic = CodeMirror.isWordChar = function(ch) {
        return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
    }
    , extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    range = document.createRange ? function(node, start, end) {
        var r = document.createRange();
        return r.setEnd(node, end),
        r.setStart(node, start),
        r
    }
    : function(node, start, end) {
        var r = document.body.createTextRange();
        try {
            r.moveToElementText(node.parentNode)
        } catch (e) {
            return r
        }
        return r.collapse(!0),
        r.moveEnd("character", end),
        r.moveStart("character", start),
        r
    }
    ,
    ie && ie_version < 11 && (activeElt = function() {
        try {
            return document.activeElement
        } catch (e) {
            return document.body
        }
    }
    );
    var knownScrollbarWidth, zwspSupported, badBidiRects, rmClass = CodeMirror.rmClass = function(node, cls) {
        var current = node.className
          , match = classTest(cls).exec(current);
        if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "")
        }
    }
    , addClass = CodeMirror.addClass = function(node, cls) {
        var current = node.className;
        classTest(cls).test(current) || (node.className += (current ? " " : "") + cls)
    }
    , globalsRegistered = !1, dragAndDrop = function() {
        if (ie && ie_version < 9)
            return !1;
        var div = elt("div");
        return "draggable"in div || "dragDrop"in div
    }(), splitLines = CodeMirror.splitLines = 3 != "\n\nb".split(/\n/).length ? function(string) {
        for (var pos = 0, result = [], l = string.length; pos <= l; ) {
            var nl = string.indexOf("\n", pos);
            -1 == nl && (nl = string.length);
            var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl)
              , rt = line.indexOf("\r");
            -1 != rt ? (result.push(line.slice(0, rt)),
            pos += rt + 1) : (result.push(line),
            pos = nl + 1)
        }
        return result
    }
    : function(string) {
        return string.split(/\r\n?|\n/)
    }
    , hasSelection = window.getSelection ? function(te) {
        try {
            return te.selectionStart != te.selectionEnd
        } catch (e) {
            return !1
        }
    }
    : function(te) {
        try {
            var range = te.ownerDocument.selection.createRange()
        } catch (e) {}
        return !(!range || range.parentElement() != te) && 0 != range.compareEndPoints("StartToEnd", range)
    }
    , hasCopyEvent = function() {
        var e = elt("div");
        return "oncopy"in e || (e.setAttribute("oncopy", "return;"),
        "function" == typeof e.oncopy)
    }(), badZoomedRects = null, keyNames = {
        3: "Enter",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        107: "=",
        109: "-",
        127: "Delete",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
    };
    CodeMirror.keyNames = keyNames,
    function() {
        for (var i = 0; i < 10; i++)
            keyNames[i + 48] = keyNames[i + 96] = String(i);
        for (var i = 65; i <= 90; i++)
            keyNames[i] = String.fromCharCode(i);
        for (var i = 1; i <= 12; i++)
            keyNames[i + 111] = keyNames[i + 63235] = "F" + i
    }();
    var bidiOther, bidiOrdering = function() {
        function charType(code) {
            return code <= 247 ? lowTypes.charAt(code) : 1424 <= code && code <= 1524 ? "R" : 1536 <= code && code <= 1773 ? arabicTypes.charAt(code - 1536) : 1774 <= code && code <= 2220 ? "r" : 8192 <= code && code <= 8203 ? "w" : 8204 == code ? "b" : "L"
        }
        function BidiSpan(level, from, to) {
            this.level = level,
            this.from = from,
            this.to = to
        }
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"
          , arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm"
          , bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
          , isNeutral = /[stwN]/
          , isStrong = /[LRr]/
          , countsAsLeft = /[Lb1n]/
          , countsAsNum = /[1n]/;
        return function(str) {
            if (!bidiRE.test(str))
                return !1;
            for (var type, len = str.length, types = [], i = 0; i < len; ++i)
                types.push(type = charType(str.charCodeAt(i)));
            for (var i = 0, prev = "L"; i < len; ++i) {
                var type = types[i];
                "m" == type ? types[i] = prev : prev = type
            }
            for (var i = 0, cur = "L"; i < len; ++i) {
                var type = types[i];
                "1" == type && "r" == cur ? types[i] = "n" : isStrong.test(type) && (cur = type,
                "r" == type && (types[i] = "R"))
            }
            for (var i = 1, prev = types[0]; i < len - 1; ++i) {
                var type = types[i];
                "+" == type && "1" == prev && "1" == types[i + 1] ? types[i] = "1" : "," != type || prev != types[i + 1] || "1" != prev && "n" != prev || (types[i] = prev),
                prev = type
            }
            for (var i = 0; i < len; ++i) {
                var type = types[i];
                if ("," == type)
                    types[i] = "N";
                else if ("%" == type) {
                    for (var end = i + 1; end < len && "%" == types[end]; ++end)
                        ;
                    for (var replace = i && "!" == types[i - 1] || end < len && "1" == types[end] ? "1" : "N", j = i; j < end; ++j)
                        types[j] = replace;
                    i = end - 1
                }
            }
            for (var i = 0, cur = "L"; i < len; ++i) {
                var type = types[i];
                "L" == cur && "1" == type ? types[i] = "L" : isStrong.test(type) && (cur = type)
            }
            for (var i = 0; i < len; ++i)
                if (isNeutral.test(types[i])) {
                    for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end)
                        ;
                    for (var before = "L" == (i ? types[i - 1] : "L"), after = "L" == (end < len ? types[end] : "L"), replace = before || after ? "L" : "R", j = i; j < end; ++j)
                        types[j] = replace;
                    i = end - 1
                }
            for (var m, order = [], i = 0; i < len; )
                if (countsAsLeft.test(types[i])) {
                    var start = i;
                    for (++i; i < len && countsAsLeft.test(types[i]); ++i)
                        ;
                    order.push(new BidiSpan(0,start,i))
                } else {
                    var pos = i
                      , at = order.length;
                    for (++i; i < len && "L" != types[i]; ++i)
                        ;
                    for (var j = pos; j < i; )
                        if (countsAsNum.test(types[j])) {
                            pos < j && order.splice(at, 0, new BidiSpan(1,pos,j));
                            var nstart = j;
                            for (++j; j < i && countsAsNum.test(types[j]); ++j)
                                ;
                            order.splice(at, 0, new BidiSpan(2,nstart,j)),
                            pos = j
                        } else
                            ++j;
                    pos < i && order.splice(at, 0, new BidiSpan(1,pos,i))
                }
            return 1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length,
            order.unshift(new BidiSpan(0,0,m[0].length))),
            1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length,
            order.push(new BidiSpan(0,len - m[0].length,len))),
            order[0].level != lst(order).level && order.push(new BidiSpan(order[0].level,len,len)),
            order
        }
    }();
    return CodeMirror.version = "4.8.0",
    CodeMirror
}),
function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("xml", function(config, parserConfig) {
        function inText(stream, state) {
            function chain(parser) {
                return state.tokenize = parser,
                parser(stream, state)
            }
            var ch = stream.next();
            if ("<" == ch)
                return stream.eat("!") ? stream.eat("[") ? stream.match("CDATA[") ? chain(inBlock("atom", "]]>")) : null : stream.match("--") ? chain(inBlock("comment", "--\x3e")) : stream.match("DOCTYPE", !0, !0) ? (stream.eatWhile(/[\w\._\-]/),
                chain(doctype(1))) : null : stream.eat("?") ? (stream.eatWhile(/[\w\._\-]/),
                state.tokenize = inBlock("meta", "?>"),
                "meta") : (type = stream.eat("/") ? "closeTag" : "openTag",
                state.tokenize = inTag,
                "tag bracket");
            if ("&" == ch) {
                var ok;
                return ok = stream.eat("#") ? stream.eat("x") ? stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";") : stream.eatWhile(/[\d]/) && stream.eat(";") : stream.eatWhile(/[\w\.\-:]/) && stream.eat(";"),
                ok ? "atom" : "error"
            }
            return stream.eatWhile(/[^&<]/),
            null
        }
        function inTag(stream, state) {
            var ch = stream.next();
            if (">" == ch || "/" == ch && stream.eat(">"))
                return state.tokenize = inText,
                type = ">" == ch ? "endTag" : "selfcloseTag",
                "tag bracket";
            if ("=" == ch)
                return type = "equals",
                null;
            if ("<" == ch) {
                state.tokenize = inText,
                state.state = baseState,
                state.tagName = state.tagStart = null;
                var next = state.tokenize(stream, state);
                return next ? next + " tag error" : "tag error"
            }
            return /[\'\"]/.test(ch) ? (state.tokenize = inAttribute(ch),
            state.stringStartCol = stream.column(),
            state.tokenize(stream, state)) : (stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/),
            "word")
        }
        function inAttribute(quote) {
            var closure = function(stream, state) {
                for (; !stream.eol(); )
                    if (stream.next() == quote) {
                        state.tokenize = inTag;
                        break
                    }
                return "string"
            };
            return closure.isInAttribute = !0,
            closure
        }
        function inBlock(style, terminator) {
            return function(stream, state) {
                for (; !stream.eol(); ) {
                    if (stream.match(terminator)) {
                        state.tokenize = inText;
                        break
                    }
                    stream.next()
                }
                return style
            }
        }
        function doctype(depth) {
            return function(stream, state) {
                for (var ch; null != (ch = stream.next()); ) {
                    if ("<" == ch)
                        return state.tokenize = doctype(depth + 1),
                        state.tokenize(stream, state);
                    if (">" == ch) {
                        if (1 == depth) {
                            state.tokenize = inText;
                            break
                        }
                        return state.tokenize = doctype(depth - 1),
                        state.tokenize(stream, state)
                    }
                }
                return "meta"
            }
        }
        function Context(state, tagName, startOfLine) {
            this.prev = state.context,
            this.tagName = tagName,
            this.indent = state.indented,
            this.startOfLine = startOfLine,
            (Kludges.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) && (this.noIndent = !0)
        }
        function popContext(state) {
            state.context && (state.context = state.context.prev)
        }
        function maybePopContext(state, nextTagName) {
            for (var parentTagName; ; ) {
                if (!state.context)
                    return;
                if (parentTagName = state.context.tagName,
                !Kludges.contextGrabbers.hasOwnProperty(parentTagName) || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName))
                    return;
                popContext(state)
            }
        }
        function baseState(type, stream, state) {
            return "openTag" == type ? (state.tagStart = stream.column(),
            tagNameState) : "closeTag" == type ? closeTagNameState : baseState
        }
        function tagNameState(type, stream, state) {
            return "word" == type ? (state.tagName = stream.current(),
            setStyle = "tag",
            attrState) : (setStyle = "error",
            tagNameState)
        }
        function closeTagNameState(type, stream, state) {
            if ("word" == type) {
                var tagName = stream.current();
                return state.context && state.context.tagName != tagName && Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName) && popContext(state),
                state.context && state.context.tagName == tagName ? (setStyle = "tag",
                closeState) : (setStyle = "tag error",
                closeStateErr)
            }
            return setStyle = "error",
            closeStateErr
        }
        function closeState(type, _stream, state) {
            return "endTag" != type ? (setStyle = "error",
            closeState) : (popContext(state),
            baseState)
        }
        function closeStateErr(type, stream, state) {
            return setStyle = "error",
            closeState(type, stream, state)
        }
        function attrState(type, _stream, state) {
            if ("word" == type)
                return setStyle = "attribute",
                attrEqState;
            if ("endTag" == type || "selfcloseTag" == type) {
                var tagName = state.tagName
                  , tagStart = state.tagStart;
                return state.tagName = state.tagStart = null,
                "selfcloseTag" == type || Kludges.autoSelfClosers.hasOwnProperty(tagName) ? maybePopContext(state, tagName) : (maybePopContext(state, tagName),
                state.context = new Context(state,tagName,tagStart == state.indented)),
                baseState
            }
            return setStyle = "error",
            attrState
        }
        function attrEqState(type, stream, state) {
            return "equals" == type ? attrValueState : (Kludges.allowMissing || (setStyle = "error"),
            attrState(type, stream, state))
        }
        function attrValueState(type, stream, state) {
            return "string" == type ? attrContinuedState : "word" == type && Kludges.allowUnquoted ? (setStyle = "string",
            attrState) : (setStyle = "error",
            attrState(type, stream, state))
        }
        function attrContinuedState(type, stream, state) {
            return "string" == type ? attrContinuedState : attrState(type, stream, state)
        }
        var indentUnit = config.indentUnit
          , multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1
          , multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag;
        null == multilineTagIndentPastTag && (multilineTagIndentPastTag = !0);
        var type, setStyle, Kludges = parserConfig.htmlMode ? {
            autoSelfClosers: {
                area: !0,
                base: !0,
                br: !0,
                col: !0,
                command: !0,
                embed: !0,
                frame: !0,
                hr: !0,
                img: !0,
                input: !0,
                keygen: !0,
                link: !0,
                meta: !0,
                param: !0,
                source: !0,
                track: !0,
                wbr: !0,
                menuitem: !0
            },
            implicitlyClosed: {
                dd: !0,
                li: !0,
                optgroup: !0,
                option: !0,
                p: !0,
                rp: !0,
                rt: !0,
                tbody: !0,
                td: !0,
                tfoot: !0,
                th: !0,
                tr: !0
            },
            contextGrabbers: {
                dd: {
                    dd: !0,
                    dt: !0
                },
                dt: {
                    dd: !0,
                    dt: !0
                },
                li: {
                    li: !0
                },
                option: {
                    option: !0,
                    optgroup: !0
                },
                optgroup: {
                    optgroup: !0
                },
                p: {
                    address: !0,
                    article: !0,
                    aside: !0,
                    blockquote: !0,
                    dir: !0,
                    div: !0,
                    dl: !0,
                    fieldset: !0,
                    footer: !0,
                    form: !0,
                    h1: !0,
                    h2: !0,
                    h3: !0,
                    h4: !0,
                    h5: !0,
                    h6: !0,
                    header: !0,
                    hgroup: !0,
                    hr: !0,
                    menu: !0,
                    nav: !0,
                    ol: !0,
                    p: !0,
                    pre: !0,
                    section: !0,
                    table: !0,
                    ul: !0
                },
                rp: {
                    rp: !0,
                    rt: !0
                },
                rt: {
                    rp: !0,
                    rt: !0
                },
                tbody: {
                    tbody: !0,
                    tfoot: !0
                },
                td: {
                    td: !0,
                    th: !0
                },
                tfoot: {
                    tbody: !0
                },
                th: {
                    td: !0,
                    th: !0
                },
                thead: {
                    tbody: !0,
                    tfoot: !0
                },
                tr: {
                    tr: !0
                }
            },
            doNotIndent: {
                pre: !0
            },
            allowUnquoted: !0,
            allowMissing: !0,
            caseFold: !0
        } : {
            autoSelfClosers: {},
            implicitlyClosed: {},
            contextGrabbers: {},
            doNotIndent: {},
            allowUnquoted: !1,
            allowMissing: !1,
            caseFold: !1
        }, alignCDATA = parserConfig.alignCDATA;
        return {
            startState: function() {
                return {
                    tokenize: inText,
                    state: baseState,
                    indented: 0,
                    tagName: null,
                    tagStart: null,
                    context: null
                }
            },
            token: function(stream, state) {
                if (!state.tagName && stream.sol() && (state.indented = stream.indentation()),
                stream.eatSpace())
                    return null;
                type = null;
                var style = state.tokenize(stream, state);
                return (style || type) && "comment" != style && (setStyle = null,
                state.state = state.state(type || style, stream, state),
                setStyle && (style = "error" == setStyle ? style + " error" : setStyle)),
                style
            },
            indent: function(state, textAfter, fullLine) {
                var context = state.context;
                if (state.tokenize.isInAttribute)
                    return state.tagStart == state.indented ? state.stringStartCol + 1 : state.indented + indentUnit;
                if (context && context.noIndent)
                    return CodeMirror.Pass;
                if (state.tokenize != inTag && state.tokenize != inText)
                    return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
                if (state.tagName)
                    return multilineTagIndentPastTag ? state.tagStart + state.tagName.length + 2 : state.tagStart + indentUnit * multilineTagIndentFactor;
                if (alignCDATA && /<!\[CDATA\[/.test(textAfter))
                    return 0;
                var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
                if (tagAfter && tagAfter[1])
                    for (; context; ) {
                        if (context.tagName == tagAfter[2]) {
                            context = context.prev;
                            break
                        }
                        if (!Kludges.implicitlyClosed.hasOwnProperty(context.tagName))
                            break;
                        context = context.prev
                    }
                else if (tagAfter)
                    for (; context; ) {
                        var grabbers = Kludges.contextGrabbers[context.tagName];
                        if (!grabbers || !grabbers.hasOwnProperty(tagAfter[2]))
                            break;
                        context = context.prev
                    }
                for (; context && !context.startOfLine; )
                    context = context.prev;
                return context ? context.indent + indentUnit : 0
            },
            electricInput: /<\/[\s\w:]+>$/,
            blockCommentStart: "\x3c!--",
            blockCommentEnd: "--\x3e",
            configuration: parserConfig.htmlMode ? "html" : "xml",
            helperType: parserConfig.htmlMode ? "html" : "xml"
        }
    }),
    CodeMirror.defineMIME("text/xml", "xml"),
    CodeMirror.defineMIME("application/xml", "xml"),
    CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html", {
        name: "xml",
        htmlMode: !0
    })
}),
function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("javascript", function(config, parserConfig) {
        function readRegexp(stream) {
            for (var next, escaped = !1, inSet = !1; null != (next = stream.next()); ) {
                if (!escaped) {
                    if ("/" == next && !inSet)
                        return;
                    "[" == next ? inSet = !0 : inSet && "]" == next && (inSet = !1)
                }
                escaped = !escaped && "\\" == next
            }
        }
        function ret(tp, style, cont) {
            return type = tp,
            content = cont,
            style
        }
        function tokenBase(stream, state) {
            var ch = stream.next();
            if ('"' == ch || "'" == ch)
                return state.tokenize = tokenString(ch),
                state.tokenize(stream, state);
            if ("." == ch && stream.match(/^\d+(?:[eE][+\-]?\d+)?/))
                return ret("number", "number");
            if ("." == ch && stream.match(".."))
                return ret("spread", "meta");
            if (/[\[\]{}\(\),;\:\.]/.test(ch))
                return ret(ch);
            if ("=" == ch && stream.eat(">"))
                return ret("=>", "operator");
            if ("0" == ch && stream.eat(/x/i))
                return stream.eatWhile(/[\da-f]/i),
                ret("number", "number");
            if (/\d/.test(ch))
                return stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/),
                ret("number", "number");
            if ("/" == ch)
                return stream.eat("*") ? (state.tokenize = tokenComment,
                tokenComment(stream, state)) : stream.eat("/") ? (stream.skipToEnd(),
                ret("comment", "comment")) : "operator" == state.lastType || "keyword c" == state.lastType || "sof" == state.lastType || /^[\[{}\(,;:]$/.test(state.lastType) ? (readRegexp(stream),
                stream.eatWhile(/[gimy]/),
                ret("regexp", "string-2")) : (stream.eatWhile(isOperatorChar),
                ret("operator", "operator", stream.current()));
            if ("`" == ch)
                return state.tokenize = tokenQuasi,
                tokenQuasi(stream, state);
            if ("#" == ch)
                return stream.skipToEnd(),
                ret("error", "error");
            if (isOperatorChar.test(ch))
                return stream.eatWhile(isOperatorChar),
                ret("operator", "operator", stream.current());
            if (wordRE.test(ch)) {
                stream.eatWhile(wordRE);
                var word = stream.current()
                  , known = keywords.propertyIsEnumerable(word) && keywords[word];
                return known && "." != state.lastType ? ret(known.type, known.style, word) : ret("variable", "variable", word)
            }
        }
        function tokenString(quote) {
            return function(stream, state) {
                var next, escaped = !1;
                if (jsonldMode && "@" == stream.peek() && stream.match(isJsonldKeyword))
                    return state.tokenize = tokenBase,
                    ret("jsonld-keyword", "meta");
                for (; null != (next = stream.next()) && (next != quote || escaped); )
                    escaped = !escaped && "\\" == next;
                return escaped || (state.tokenize = tokenBase),
                ret("string", "string")
            }
        }
        function tokenComment(stream, state) {
            for (var ch, maybeEnd = !1; ch = stream.next(); ) {
                if ("/" == ch && maybeEnd) {
                    state.tokenize = tokenBase;
                    break
                }
                maybeEnd = "*" == ch
            }
            return ret("comment", "comment")
        }
        function tokenQuasi(stream, state) {
            for (var next, escaped = !1; null != (next = stream.next()); ) {
                if (!escaped && ("`" == next || "$" == next && stream.eat("{"))) {
                    state.tokenize = tokenBase;
                    break
                }
                escaped = !escaped && "\\" == next
            }
            return ret("quasi", "string-2", stream.current())
        }
        function findFatArrow(stream, state) {
            state.fatArrowAt && (state.fatArrowAt = null);
            var arrow = stream.string.indexOf("=>", stream.start);
            if (!(arrow < 0)) {
                for (var depth = 0, sawSomething = !1, pos = arrow - 1; pos >= 0; --pos) {
                    var ch = stream.string.charAt(pos)
                      , bracket = brackets.indexOf(ch);
                    if (bracket >= 0 && bracket < 3) {
                        if (!depth) {
                            ++pos;
                            break
                        }
                        if (0 == --depth)
                            break
                    } else if (bracket >= 3 && bracket < 6)
                        ++depth;
                    else if (wordRE.test(ch))
                        sawSomething = !0;
                    else if (sawSomething && !depth) {
                        ++pos;
                        break
                    }
                }
                sawSomething && !depth && (state.fatArrowAt = pos)
            }
        }
        function JSLexical(indented, column, type, align, prev, info) {
            this.indented = indented,
            this.column = column,
            this.type = type,
            this.prev = prev,
            this.info = info,
            null != align && (this.align = align)
        }
        function inScope(state, varname) {
            for (var v = state.localVars; v; v = v.next)
                if (v.name == varname)
                    return !0;
            for (var cx = state.context; cx; cx = cx.prev)
                for (var v = cx.vars; v; v = v.next)
                    if (v.name == varname)
                        return !0
        }
        function parseJS(state, style, type, content, stream) {
            var cc = state.cc;
            for (cx.state = state,
            cx.stream = stream,
            cx.marked = null,
            cx.cc = cc,
            cx.style = style,
            state.lexical.hasOwnProperty("align") || (state.lexical.align = !0); ; ) {
                if ((cc.length ? cc.pop() : jsonMode ? expression : statement)(type, content)) {
                    for (; cc.length && cc[cc.length - 1].lex; )
                        cc.pop()();
                    return cx.marked ? cx.marked : "variable" == type && inScope(state, content) ? "variable-2" : style
                }
            }
        }
        function pass() {
            for (var i = arguments.length - 1; i >= 0; i--)
                cx.cc.push(arguments[i])
        }
        function cont() {
            return pass.apply(null, arguments),
            !0
        }
        function register(varname) {
            function inList(list) {
                for (var v = list; v; v = v.next)
                    if (v.name == varname)
                        return !0;
                return !1
            }
            var state = cx.state;
            if (state.context) {
                if (cx.marked = "def",
                inList(state.localVars))
                    return;
                state.localVars = {
                    name: varname,
                    next: state.localVars
                }
            } else {
                if (inList(state.globalVars))
                    return;
                parserConfig.globalVars && (state.globalVars = {
                    name: varname,
                    next: state.globalVars
                })
            }
        }
        function pushcontext() {
            cx.state.context = {
                prev: cx.state.context,
                vars: cx.state.localVars
            },
            cx.state.localVars = defaultVars
        }
        function popcontext() {
            cx.state.localVars = cx.state.context.vars,
            cx.state.context = cx.state.context.prev
        }
        function pushlex(type, info) {
            var result = function() {
                var state = cx.state
                  , indent = state.indented;
                if ("stat" == state.lexical.type)
                    indent = state.lexical.indented;
                else
                    for (var outer = state.lexical; outer && ")" == outer.type && outer.align; outer = outer.prev)
                        indent = outer.indented;
                state.lexical = new JSLexical(indent,cx.stream.column(),type,null,state.lexical,info)
            };
            return result.lex = !0,
            result
        }
        function poplex() {
            var state = cx.state;
            state.lexical.prev && (")" == state.lexical.type && (state.indented = state.lexical.indented),
            state.lexical = state.lexical.prev)
        }
        function expect(wanted) {
            function exp(type) {
                return type == wanted ? cont() : ";" == wanted ? pass() : cont(exp)
            }
            return exp
        }
        function statement(type, value) {
            return "var" == type ? cont(pushlex("vardef", value.length), vardef, expect(";"), poplex) : "keyword a" == type ? cont(pushlex("form"), expression, statement, poplex) : "keyword b" == type ? cont(pushlex("form"), statement, poplex) : "{" == type ? cont(pushlex("}"), block, poplex) : ";" == type ? cont() : "if" == type ? ("else" == cx.state.lexical.info && cx.state.cc[cx.state.cc.length - 1] == poplex && cx.state.cc.pop()(),
            cont(pushlex("form"), expression, statement, poplex, maybeelse)) : "function" == type ? cont(functiondef) : "for" == type ? cont(pushlex("form"), forspec, statement, poplex) : "variable" == type ? cont(pushlex("stat"), maybelabel) : "switch" == type ? cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"), block, poplex, poplex) : "case" == type ? cont(expression, expect(":")) : "default" == type ? cont(expect(":")) : "catch" == type ? cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext) : "module" == type ? cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex) : "class" == type ? cont(pushlex("form"), className, poplex) : "export" == type ? cont(pushlex("form"), afterExport, poplex) : "import" == type ? cont(pushlex("form"), afterImport, poplex) : pass(pushlex("stat"), expression, expect(";"), poplex)
        }
        function expression(type) {
            return expressionInner(type, !1)
        }
        function expressionNoComma(type) {
            return expressionInner(type, !0)
        }
        function expressionInner(type, noComma) {
            if (cx.state.fatArrowAt == cx.stream.start) {
                var body = noComma ? arrowBodyNoComma : arrowBody;
                if ("(" == type)
                    return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
                if ("variable" == type)
                    return pass(pushcontext, pattern, expect("=>"), body, popcontext)
            }
            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
            return atomicTypes.hasOwnProperty(type) ? cont(maybeop) : "function" == type ? cont(functiondef, maybeop) : "keyword c" == type ? cont(noComma ? maybeexpressionNoComma : maybeexpression) : "(" == type ? cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop) : "operator" == type || "spread" == type ? cont(noComma ? expressionNoComma : expression) : "[" == type ? cont(pushlex("]"), arrayLiteral, poplex, maybeop) : "{" == type ? contCommasep(objprop, "}", null, maybeop) : "quasi" == type ? pass(quasi, maybeop) : cont()
        }
        function maybeexpression(type) {
            return type.match(/[;\}\)\],]/) ? pass() : pass(expression)
        }
        function maybeexpressionNoComma(type) {
            return type.match(/[;\}\)\],]/) ? pass() : pass(expressionNoComma)
        }
        function maybeoperatorComma(type, value) {
            return "," == type ? cont(expression) : maybeoperatorNoComma(type, value, !1)
        }
        function maybeoperatorNoComma(type, value, noComma) {
            var me = 0 == noComma ? maybeoperatorComma : maybeoperatorNoComma
              , expr = 0 == noComma ? expression : expressionNoComma;
            return "=>" == type ? cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext) : "operator" == type ? /\+\+|--/.test(value) ? cont(me) : "?" == value ? cont(expression, expect(":"), expr) : cont(expr) : "quasi" == type ? pass(quasi, me) : ";" != type ? "(" == type ? contCommasep(expressionNoComma, ")", "call", me) : "." == type ? cont(property, me) : "[" == type ? cont(pushlex("]"), maybeexpression, expect("]"), poplex, me) : void 0 : void 0
        }
        function quasi(type, value) {
            return "quasi" != type ? pass() : "${" != value.slice(value.length - 2) ? cont(quasi) : cont(expression, continueQuasi)
        }
        function continueQuasi(type) {
            if ("}" == type)
                return cx.marked = "string-2",
                cx.state.tokenize = tokenQuasi,
                cont(quasi)
        }
        function arrowBody(type) {
            return findFatArrow(cx.stream, cx.state),
            pass("{" == type ? statement : expression)
        }
        function arrowBodyNoComma(type) {
            return findFatArrow(cx.stream, cx.state),
            pass("{" == type ? statement : expressionNoComma)
        }
        function maybelabel(type) {
            return ":" == type ? cont(poplex, statement) : pass(maybeoperatorComma, expect(";"), poplex)
        }
        function property(type) {
            if ("variable" == type)
                return cx.marked = "property",
                cont()
        }
        function objprop(type, value) {
            return "variable" == type || "keyword" == cx.style ? (cx.marked = "property",
            cont("get" == value || "set" == value ? getterSetter : afterprop)) : "number" == type || "string" == type ? (cx.marked = jsonldMode ? "property" : cx.style + " property",
            cont(afterprop)) : "jsonld-keyword" == type ? cont(afterprop) : "[" == type ? cont(expression, expect("]"), afterprop) : void 0
        }
        function getterSetter(type) {
            return "variable" != type ? pass(afterprop) : (cx.marked = "property",
            cont(functiondef))
        }
        function afterprop(type) {
            return ":" == type ? cont(expressionNoComma) : "(" == type ? pass(functiondef) : void 0
        }
        function commasep(what, end) {
            function proceed(type) {
                if ("," == type) {
                    var lex = cx.state.lexical;
                    return "call" == lex.info && (lex.pos = (lex.pos || 0) + 1),
                    cont(what, proceed)
                }
                return type == end ? cont() : cont(expect(end))
            }
            return function(type) {
                return type == end ? cont() : pass(what, proceed)
            }
        }
        function contCommasep(what, end, info) {
            for (var i = 3; i < arguments.length; i++)
                cx.cc.push(arguments[i]);
            return cont(pushlex(end, info), commasep(what, end), poplex)
        }
        function block(type) {
            return "}" == type ? cont() : pass(statement, block)
        }
        function maybetype(type) {
            if (isTS && ":" == type)
                return cont(typedef)
        }
        function typedef(type) {
            if ("variable" == type)
                return cx.marked = "variable-3",
                cont()
        }
        function vardef() {
            return pass(pattern, maybetype, maybeAssign, vardefCont)
        }
        function pattern(type, value) {
            return "variable" == type ? (register(value),
            cont()) : "[" == type ? contCommasep(pattern, "]") : "{" == type ? contCommasep(proppattern, "}") : void 0
        }
        function proppattern(type, value) {
            return "variable" != type || cx.stream.match(/^\s*:/, !1) ? ("variable" == type && (cx.marked = "property"),
            cont(expect(":"), pattern, maybeAssign)) : (register(value),
            cont(maybeAssign))
        }
        function maybeAssign(_type, value) {
            if ("=" == value)
                return cont(expressionNoComma)
        }
        function vardefCont(type) {
            if ("," == type)
                return cont(vardef)
        }
        function maybeelse(type, value) {
            if ("keyword b" == type && "else" == value)
                return cont(pushlex("form", "else"), statement, poplex)
        }
        function forspec(type) {
            if ("(" == type)
                return cont(pushlex(")"), forspec1, expect(")"), poplex)
        }
        function forspec1(type) {
            return "var" == type ? cont(vardef, expect(";"), forspec2) : ";" == type ? cont(forspec2) : "variable" == type ? cont(formaybeinof) : pass(expression, expect(";"), forspec2)
        }
        function formaybeinof(_type, value) {
            return "in" == value || "of" == value ? (cx.marked = "keyword",
            cont(expression)) : cont(maybeoperatorComma, forspec2)
        }
        function forspec2(type, value) {
            return ";" == type ? cont(forspec3) : "in" == value || "of" == value ? (cx.marked = "keyword",
            cont(expression)) : pass(expression, expect(";"), forspec3)
        }
        function forspec3(type) {
            ")" != type && cont(expression)
        }
        function functiondef(type, value) {
            return "*" == value ? (cx.marked = "keyword",
            cont(functiondef)) : "variable" == type ? (register(value),
            cont(functiondef)) : "(" == type ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext) : void 0
        }
        function funarg(type) {
            return "spread" == type ? cont(funarg) : pass(pattern, maybetype)
        }
        function className(type, value) {
            if ("variable" == type)
                return register(value),
                cont(classNameAfter)
        }
        function classNameAfter(type, value) {
            return "extends" == value ? cont(expression, classNameAfter) : "{" == type ? cont(pushlex("}"), classBody, poplex) : void 0
        }
        function classBody(type, value) {
            return "variable" == type || "keyword" == cx.style ? (cx.marked = "property",
            "get" == value || "set" == value ? cont(classGetterSetter, functiondef, classBody) : cont(functiondef, classBody)) : "*" == value ? (cx.marked = "keyword",
            cont(classBody)) : ";" == type ? cont(classBody) : "}" == type ? cont() : void 0
        }
        function classGetterSetter(type) {
            return "variable" != type ? pass() : (cx.marked = "property",
            cont())
        }
        function afterModule(type, value) {
            return "string" == type ? cont(statement) : "variable" == type ? (register(value),
            cont(maybeFrom)) : void 0
        }
        function afterExport(_type, value) {
            return "*" == value ? (cx.marked = "keyword",
            cont(maybeFrom, expect(";"))) : "default" == value ? (cx.marked = "keyword",
            cont(expression, expect(";"))) : pass(statement)
        }
        function afterImport(type) {
            return "string" == type ? cont() : pass(importSpec, maybeFrom)
        }
        function importSpec(type, value) {
            return "{" == type ? contCommasep(importSpec, "}") : ("variable" == type && register(value),
            cont())
        }
        function maybeFrom(_type, value) {
            if ("from" == value)
                return cx.marked = "keyword",
                cont(expression)
        }
        function arrayLiteral(type) {
            return "]" == type ? cont() : pass(expressionNoComma, maybeArrayComprehension)
        }
        function maybeArrayComprehension(type) {
            return "for" == type ? pass(comprehension, expect("]")) : "," == type ? cont(commasep(maybeexpressionNoComma, "]")) : pass(commasep(expressionNoComma, "]"))
        }
        function comprehension(type) {
            return "for" == type ? cont(forspec, comprehension) : "if" == type ? cont(expression, comprehension) : void 0
        }
        var type, content, indentUnit = config.indentUnit, statementIndent = parserConfig.statementIndent, jsonldMode = parserConfig.jsonld, jsonMode = parserConfig.json || jsonldMode, isTS = parserConfig.typescript, wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/, keywords = function() {
            function kw(type) {
                return {
                    type: type,
                    style: "keyword"
                }
            }
            var A = kw("keyword a")
              , B = kw("keyword b")
              , C = kw("keyword c")
              , operator = kw("operator")
              , atom = {
                type: "atom",
                style: "atom"
            }
              , jsKeywords = {
                if: kw("if"),
                while: A,
                with: A,
                else: B,
                do: B,
                try: B,
                finally: B,
                return: C,
                break: C,
                continue: C,
                new: C,
                delete: C,
                throw: C,
                debugger: C,
                var: kw("var"),
                const: kw("var"),
                let: kw("var"),
                function: kw("function"),
                catch: kw("catch"),
                for: kw("for"),
                switch: kw("switch"),
                case: kw("case"),
                default: kw("default"),
                in: operator,
                typeof: operator,
                instanceof: operator,
                true: atom,
                false: atom,
                null: atom,
                undefined: atom,
                NaN: atom,
                Infinity: atom,
                this: kw("this"),
                module: kw("module"),
                class: kw("class"),
                super: kw("atom"),
                yield: C,
                export: kw("export"),
                import: kw("import"),
                extends: C
            };
            if (isTS) {
                var type = {
                    type: "variable",
                    style: "variable-3"
                }
                  , tsKeywords = {
                    interface: kw("interface"),
                    extends: kw("extends"),
                    constructor: kw("constructor"),
                    public: kw("public"),
                    private: kw("private"),
                    protected: kw("protected"),
                    static: kw("static"),
                    string: type,
                    number: type,
                    bool: type,
                    any: type
                };
                for (var attr in tsKeywords)
                    jsKeywords[attr] = tsKeywords[attr]
            }
            return jsKeywords
        }(), isOperatorChar = /[+\-*&%=<>!?|~^]/, isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/, brackets = "([{}])", atomicTypes = {
            atom: !0,
            number: !0,
            variable: !0,
            string: !0,
            regexp: !0,
            this: !0,
            "jsonld-keyword": !0
        }, cx = {
            state: null,
            column: null,
            marked: null,
            cc: null
        }, defaultVars = {
            name: "this",
            next: {
                name: "arguments"
            }
        };
        return poplex.lex = !0,
        {
            startState: function(basecolumn) {
                var state = {
                    tokenize: tokenBase,
                    lastType: "sof",
                    cc: [],
                    lexical: new JSLexical((basecolumn || 0) - indentUnit,0,"block",!1),
                    localVars: parserConfig.localVars,
                    context: parserConfig.localVars && {
                        vars: parserConfig.localVars
                    },
                    indented: 0
                };
                return parserConfig.globalVars && "object" == typeof parserConfig.globalVars && (state.globalVars = parserConfig.globalVars),
                state
            },
            token: function(stream, state) {
                if (stream.sol() && (state.lexical.hasOwnProperty("align") || (state.lexical.align = !1),
                state.indented = stream.indentation(),
                findFatArrow(stream, state)),
                state.tokenize != tokenComment && stream.eatSpace())
                    return null;
                var style = state.tokenize(stream, state);
                return "comment" == type ? style : (state.lastType = "operator" != type || "++" != content && "--" != content ? type : "incdec",
                parseJS(state, style, type, content, stream))
            },
            indent: function(state, textAfter) {
                if (state.tokenize == tokenComment)
                    return CodeMirror.Pass;
                if (state.tokenize != tokenBase)
                    return 0;
                var firstChar = textAfter && textAfter.charAt(0)
                  , lexical = state.lexical;
                if (!/^\s*else\b/.test(textAfter))
                    for (var i = state.cc.length - 1; i >= 0; --i) {
                        var c = state.cc[i];
                        if (c == poplex)
                            lexical = lexical.prev;
                        else if (c != maybeelse)
                            break
                    }
                "stat" == lexical.type && "}" == firstChar && (lexical = lexical.prev),
                statementIndent && ")" == lexical.type && "stat" == lexical.prev.type && (lexical = lexical.prev);
                var type = lexical.type
                  , closing = firstChar == type;
                return "vardef" == type ? lexical.indented + ("operator" == state.lastType || "," == state.lastType ? lexical.info + 1 : 0) : "form" == type && "{" == firstChar ? lexical.indented : "form" == type ? lexical.indented + indentUnit : "stat" == type ? lexical.indented + ("operator" == state.lastType || "," == state.lastType ? statementIndent || indentUnit : 0) : "switch" != lexical.info || closing || 0 == parserConfig.doubleIndentSwitch ? lexical.align ? lexical.column + (closing ? 0 : 1) : lexical.indented + (closing ? 0 : indentUnit) : lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit)
            },
            electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            blockCommentStart: jsonMode ? null : "/*",
            blockCommentEnd: jsonMode ? null : "*/",
            lineComment: jsonMode ? null : "//",
            fold: "brace",
            helperType: jsonMode ? "json" : "javascript",
            jsonldMode: jsonldMode,
            jsonMode: jsonMode
        }
    }),
    CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/),
    CodeMirror.defineMIME("text/javascript", "javascript"),
    CodeMirror.defineMIME("text/ecmascript", "javascript"),
    CodeMirror.defineMIME("application/javascript", "javascript"),
    CodeMirror.defineMIME("application/x-javascript", "javascript"),
    CodeMirror.defineMIME("application/ecmascript", "javascript"),
    CodeMirror.defineMIME("application/json", {
        name: "javascript",
        json: !0
    }),
    CodeMirror.defineMIME("application/x-json", {
        name: "javascript",
        json: !0
    }),
    CodeMirror.defineMIME("application/ld+json", {
        name: "javascript",
        jsonld: !0
    }),
    CodeMirror.defineMIME("text/typescript", {
        name: "javascript",
        typescript: !0
    }),
    CodeMirror.defineMIME("application/typescript", {
        name: "javascript",
        typescript: !0
    })
}),
function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
}(function(CodeMirror) {
    "use strict";
    function keySet(array) {
        for (var keys = {}, i = 0; i < array.length; ++i)
            keys[array[i]] = !0;
        return keys
    }
    function tokenCComment(stream, state) {
        for (var ch, maybeEnd = !1; null != (ch = stream.next()); ) {
            if (maybeEnd && "/" == ch) {
                state.tokenize = null;
                break
            }
            maybeEnd = "*" == ch
        }
        return ["comment", "comment"]
    }
    function tokenSGMLComment(stream, state) {
        return stream.skipTo("--\x3e") ? (stream.match("--\x3e"),
        state.tokenize = null) : stream.skipToEnd(),
        ["comment", "comment"]
    }
    CodeMirror.defineMode("css", function(config, parserConfig) {
        function ret(style, tp) {
            return type = tp,
            style
        }
        function tokenBase(stream, state) {
            var ch = stream.next();
            if (tokenHooks[ch]) {
                var result = tokenHooks[ch](stream, state);
                if (!1 !== result)
                    return result
            }
            return "@" == ch ? (stream.eatWhile(/[\w\\\-]/),
            ret("def", stream.current())) : "=" == ch || ("~" == ch || "|" == ch) && stream.eat("=") ? ret(null, "compare") : '"' == ch || "'" == ch ? (state.tokenize = tokenString(ch),
            state.tokenize(stream, state)) : "#" == ch ? (stream.eatWhile(/[\w\\\-]/),
            ret("atom", "hash")) : "!" == ch ? (stream.match(/^\s*\w*/),
            ret("keyword", "important")) : /\d/.test(ch) || "." == ch && stream.eat(/\d/) ? (stream.eatWhile(/[\w.%]/),
            ret("number", "unit")) : "-" !== ch ? /[,+>*\/]/.test(ch) ? ret(null, "select-op") : "." == ch && stream.match(/^-?[_a-z][_a-z0-9-]*/i) ? ret("qualifier", "qualifier") : /[:;{}\[\]\(\)]/.test(ch) ? ret(null, ch) : "u" == ch && stream.match("rl(") ? (stream.backUp(1),
            state.tokenize = tokenParenthesized,
            ret("property", "word")) : /[\w\\\-]/.test(ch) ? (stream.eatWhile(/[\w\\\-]/),
            ret("property", "word")) : ret(null, null) : /[\d.]/.test(stream.peek()) ? (stream.eatWhile(/[\w.%]/),
            ret("number", "unit")) : stream.match(/^\w+-/) ? ret("meta", "meta") : void 0
        }
        function tokenString(quote) {
            return function(stream, state) {
                for (var ch, escaped = !1; null != (ch = stream.next()); ) {
                    if (ch == quote && !escaped) {
                        ")" == quote && stream.backUp(1);
                        break
                    }
                    escaped = !escaped && "\\" == ch
                }
                return (ch == quote || !escaped && ")" != quote) && (state.tokenize = null),
                ret("string", "string")
            }
        }
        function tokenParenthesized(stream, state) {
            return stream.next(),
            stream.match(/\s*[\"\')]/, !1) ? state.tokenize = null : state.tokenize = tokenString(")"),
            ret(null, "(")
        }
        function Context(type, indent, prev) {
            this.type = type,
            this.indent = indent,
            this.prev = prev
        }
        function pushContext(state, stream, type) {
            return state.context = new Context(type,stream.indentation() + indentUnit,state.context),
            type
        }
        function popContext(state) {
            return state.context = state.context.prev,
            state.context.type
        }
        function pass(type, stream, state) {
            return states[state.context.type](type, stream, state)
        }
        function popAndPass(type, stream, state, n) {
            for (var i = n || 1; i > 0; i--)
                state.context = state.context.prev;
            return pass(type, stream, state)
        }
        function wordAsValue(stream) {
            var word = stream.current().toLowerCase();
            override = valueKeywords.hasOwnProperty(word) ? "atom" : colorKeywords.hasOwnProperty(word) ? "keyword" : "variable"
        }
        parserConfig.propertyKeywords || (parserConfig = CodeMirror.resolveMode("text/css"));
        var type, override, indentUnit = config.indentUnit, tokenHooks = parserConfig.tokenHooks, mediaTypes = parserConfig.mediaTypes || {}, mediaFeatures = parserConfig.mediaFeatures || {}, propertyKeywords = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {}, colorKeywords = parserConfig.colorKeywords || {}, valueKeywords = parserConfig.valueKeywords || {}, fontProperties = parserConfig.fontProperties || {}, allowNested = parserConfig.allowNested, states = {};
        return states.top = function(type, stream, state) {
            if ("{" == type)
                return pushContext(state, stream, "block");
            if ("}" == type && state.context.prev)
                return popContext(state);
            if ("@media" == type)
                return pushContext(state, stream, "media");
            if ("@font-face" == type)
                return "font_face_before";
            if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type))
                return "keyframes";
            if (type && "@" == type.charAt(0))
                return pushContext(state, stream, "at");
            if ("hash" == type)
                override = "builtin";
            else if ("word" == type)
                override = "tag";
            else {
                if ("variable-definition" == type)
                    return "maybeprop";
                if ("interpolation" == type)
                    return pushContext(state, stream, "interpolation");
                if (":" == type)
                    return "pseudo";
                if (allowNested && "(" == type)
                    return pushContext(state, stream, "parens")
            }
            return state.context.type
        }
        ,
        states.block = function(type, stream, state) {
            if ("word" == type) {
                var word = stream.current().toLowerCase();
                return propertyKeywords.hasOwnProperty(word) ? (override = "property",
                "maybeprop") : nonStandardPropertyKeywords.hasOwnProperty(word) ? (override = "string-2",
                "maybeprop") : allowNested ? (override = stream.match(/^\s*:(?:\s|$)/, !1) ? "property" : "tag",
                "block") : (override += " error",
                "maybeprop")
            }
            return "meta" == type ? "block" : allowNested || "hash" != type && "qualifier" != type ? states.top(type, stream, state) : (override = "error",
            "block")
        }
        ,
        states.maybeprop = function(type, stream, state) {
            return ":" == type ? pushContext(state, stream, "prop") : pass(type, stream, state)
        }
        ,
        states.prop = function(type, stream, state) {
            if (";" == type)
                return popContext(state);
            if ("{" == type && allowNested)
                return pushContext(state, stream, "propBlock");
            if ("}" == type || "{" == type)
                return popAndPass(type, stream, state);
            if ("(" == type)
                return pushContext(state, stream, "parens");
            if ("hash" != type || /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
                if ("word" == type)
                    wordAsValue(stream);
                else if ("interpolation" == type)
                    return pushContext(state, stream, "interpolation")
            } else
                override += " error";
            return "prop"
        }
        ,
        states.propBlock = function(type, _stream, state) {
            return "}" == type ? popContext(state) : "word" == type ? (override = "property",
            "maybeprop") : state.context.type
        }
        ,
        states.parens = function(type, stream, state) {
            return "{" == type || "}" == type ? popAndPass(type, stream, state) : ")" == type ? popContext(state) : "(" == type ? pushContext(state, stream, "parens") : ("word" == type && wordAsValue(stream),
            "parens")
        }
        ,
        states.pseudo = function(type, stream, state) {
            return "word" == type ? (override = "variable-3",
            state.context.type) : pass(type, stream, state)
        }
        ,
        states.media = function(type, stream, state) {
            if ("(" == type)
                return pushContext(state, stream, "media_parens");
            if ("}" == type)
                return popAndPass(type, stream, state);
            if ("{" == type)
                return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
            if ("word" == type) {
                var word = stream.current().toLowerCase();
                override = "only" == word || "not" == word || "and" == word ? "keyword" : mediaTypes.hasOwnProperty(word) ? "attribute" : mediaFeatures.hasOwnProperty(word) ? "property" : "error"
            }
            return state.context.type
        }
        ,
        states.media_parens = function(type, stream, state) {
            return ")" == type ? popContext(state) : "{" == type || "}" == type ? popAndPass(type, stream, state, 2) : states.media(type, stream, state)
        }
        ,
        states.font_face_before = function(type, stream, state) {
            return "{" == type ? pushContext(state, stream, "font_face") : pass(type, stream, state)
        }
        ,
        states.font_face = function(type, stream, state) {
            return "}" == type ? popContext(state) : "word" == type ? (override = fontProperties.hasOwnProperty(stream.current().toLowerCase()) ? "property" : "error",
            "maybeprop") : "font_face"
        }
        ,
        states.keyframes = function(type, stream, state) {
            return "word" == type ? (override = "variable",
            "keyframes") : "{" == type ? pushContext(state, stream, "top") : pass(type, stream, state)
        }
        ,
        states.at = function(type, stream, state) {
            return ";" == type ? popContext(state) : "{" == type || "}" == type ? popAndPass(type, stream, state) : ("word" == type ? override = "tag" : "hash" == type && (override = "builtin"),
            "at")
        }
        ,
        states.interpolation = function(type, stream, state) {
            return "}" == type ? popContext(state) : "{" == type || ";" == type ? popAndPass(type, stream, state) : ("variable" != type && (override = "error"),
            "interpolation")
        }
        ,
        {
            startState: function(base) {
                return {
                    tokenize: null,
                    state: "top",
                    context: new Context("top",base || 0,null)
                }
            },
            token: function(stream, state) {
                if (!state.tokenize && stream.eatSpace())
                    return null;
                var style = (state.tokenize || tokenBase)(stream, state);
                return style && "object" == typeof style && (type = style[1],
                style = style[0]),
                override = style,
                state.state = states[state.state](type, stream, state),
                override
            },
            indent: function(state, textAfter) {
                var cx = state.context
                  , ch = textAfter && textAfter.charAt(0)
                  , indent = cx.indent;
                return "prop" != cx.type || "}" != ch && ")" != ch || (cx = cx.prev),
                !cx.prev || ("}" != ch || "block" != cx.type && "top" != cx.type && "interpolation" != cx.type && "font_face" != cx.type) && (")" != ch || "parens" != cx.type && "media_parens" != cx.type) && ("{" != ch || "at" != cx.type && "media" != cx.type) || (indent = cx.indent - indentUnit,
                cx = cx.prev),
                indent
            },
            electricChars: "}",
            blockCommentStart: "/*",
            blockCommentEnd: "*/",
            fold: "brace"
        }
    });
    var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"]
      , mediaTypes = keySet(mediaTypes_)
      , mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"]
      , mediaFeatures = keySet(mediaFeatures_)
      , propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-position", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"]
      , propertyKeywords = keySet(propertyKeywords_)
      , nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"]
      , nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_)
      , colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]
      , colorKeywords = keySet(colorKeywords_)
      , valueKeywords_ = ["above", "absolute", "activeborder", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "single", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "x-large", "x-small", "xor", "xx-large", "xx-small"]
      , valueKeywords = keySet(valueKeywords_)
      , fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"]
      , fontProperties = keySet(fontProperties_)
      , allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
    CodeMirror.registerHelper("hintWords", "css", allWords),
    CodeMirror.defineMIME("text/css", {
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        fontProperties: fontProperties,
        tokenHooks: {
            "<": function(stream, state) {
                return !!stream.match("!--") && (state.tokenize = tokenSGMLComment,
                tokenSGMLComment(stream, state))
            },
            "/": function(stream, state) {
                return !!stream.eat("*") && (state.tokenize = tokenCComment,
                tokenCComment(stream, state))
            }
        },
        name: "css"
    }),
    CodeMirror.defineMIME("text/x-scss", {
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        fontProperties: fontProperties,
        allowNested: !0,
        tokenHooks: {
            "/": function(stream, state) {
                return stream.eat("/") ? (stream.skipToEnd(),
                ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment,
                tokenCComment(stream, state)) : ["operator", "operator"]
            },
            ":": function(stream) {
                return !!stream.match(/\s*\{/) && [null, "{"]
            },
            $: function(stream) {
                return stream.match(/^[\w-]+/),
                stream.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"]
            },
            "#": function(stream) {
                return !!stream.eat("{") && [null, "interpolation"]
            }
        },
        name: "css",
        helperType: "scss"
    }),
    CodeMirror.defineMIME("text/x-less", {
        mediaTypes: mediaTypes,
        mediaFeatures: mediaFeatures,
        propertyKeywords: propertyKeywords,
        nonStandardPropertyKeywords: nonStandardPropertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        fontProperties: fontProperties,
        allowNested: !0,
        tokenHooks: {
            "/": function(stream, state) {
                return stream.eat("/") ? (stream.skipToEnd(),
                ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment,
                tokenCComment(stream, state)) : ["operator", "operator"]
            },
            "@": function(stream) {
                return !stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, !1) && (stream.eatWhile(/[\w\\\-]/),
                stream.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"])
            },
            "&": function() {
                return ["atom", "atom"]
            }
        },
        name: "css",
        helperType: "less"
    })
}),
function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod) : mod(CodeMirror)
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("htmlmixed", function(config, parserConfig) {
        function html(stream, state) {
            var tagName = state.htmlState.tagName;
            tagName && (tagName = tagName.toLowerCase());
            var style = htmlMode.token(stream, state.htmlState);
            if ("script" == tagName && /\btag\b/.test(style) && ">" == stream.current()) {
                var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i);
                scriptType = scriptType ? scriptType[1] : "",
                scriptType && /[\"\']/.test(scriptType.charAt(0)) && (scriptType = scriptType.slice(1, scriptType.length - 1));
                for (var i = 0; i < scriptTypes.length; ++i) {
                    var tp = scriptTypes[i];
                    if ("string" == typeof tp.matches ? scriptType == tp.matches : tp.matches.test(scriptType)) {
                        tp.mode && (state.token = script,
                        state.localMode = tp.mode,
                        state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, "")));
                        break
                    }
                }
            } else
                "style" == tagName && /\btag\b/.test(style) && ">" == stream.current() && (state.token = css,
                state.localMode = cssMode,
                state.localState = cssMode.startState(htmlMode.indent(state.htmlState, "")));
            return style
        }
        function maybeBackup(stream, pat, style) {
            var cur = stream.current()
              , close = cur.search(pat);
            return close > -1 ? stream.backUp(cur.length - close) : cur.match(/<\/?$/) && (stream.backUp(cur.length),
            stream.match(pat, !1) || stream.match(cur)),
            style
        }
        function script(stream, state) {
            return stream.match(/^<\/\s*script\s*>/i, !1) ? (state.token = html,
            state.localState = state.localMode = null,
            null) : maybeBackup(stream, /<\/\s*script\s*>/, state.localMode.token(stream, state.localState))
        }
        function css(stream, state) {
            return stream.match(/^<\/\s*style\s*>/i, !1) ? (state.token = html,
            state.localState = state.localMode = null,
            null) : maybeBackup(stream, /<\/\s*style\s*>/, cssMode.token(stream, state.localState))
        }
        var htmlMode = CodeMirror.getMode(config, {
            name: "xml",
            htmlMode: !0,
            multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
            multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
        })
          , cssMode = CodeMirror.getMode(config, "css")
          , scriptTypes = []
          , scriptTypesConf = parserConfig && parserConfig.scriptTypes;
        if (scriptTypes.push({
            matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i,
            mode: CodeMirror.getMode(config, "javascript")
        }),
        scriptTypesConf)
            for (var i = 0; i < scriptTypesConf.length; ++i) {
                var conf = scriptTypesConf[i];
                scriptTypes.push({
                    matches: conf.matches,
                    mode: conf.mode && CodeMirror.getMode(config, conf.mode)
                })
            }
        return scriptTypes.push({
            matches: /./,
            mode: CodeMirror.getMode(config, "text/plain")
        }),
        {
            startState: function() {
                return {
                    token: html,
                    localMode: null,
                    localState: null,
                    htmlState: htmlMode.startState()
                }
            },
            copyState: function(state) {
                if (state.localState)
                    var local = CodeMirror.copyState(state.localMode, state.localState);
                return {
                    token: state.token,
                    localMode: state.localMode,
                    localState: local,
                    htmlState: CodeMirror.copyState(htmlMode, state.htmlState)
                }
            },
            token: function(stream, state) {
                return state.token(stream, state)
            },
            indent: function(state, textAfter) {
                return !state.localMode || /^\s*<\//.test(textAfter) ? htmlMode.indent(state.htmlState, textAfter) : state.localMode.indent ? state.localMode.indent(state.localState, textAfter) : CodeMirror.Pass
            },
            innerMode: function(state) {
                return {
                    state: state.localState || state.htmlState,
                    mode: state.localMode || htmlMode
                }
            }
        }
    }, "xml", "javascript", "css"),
    CodeMirror.defineMIME("text/html", "htmlmixed")
}),
function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror", require("../xml/xml"), require("../meta"))) : "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../xml/xml", "../meta"], mod) : mod(CodeMirror)
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {
        function getMode(name) {
            if (CodeMirror.findModeByName) {
                var found = CodeMirror.findModeByName(name);
                found && (name = found.mime || found.mimes[0])
            }
            var mode = CodeMirror.getMode(cmCfg, name);
            return "null" == mode.name ? null : mode
        }
        function switchInline(stream, state, f) {
            return state.f = state.inline = f,
            f(stream, state)
        }
        function switchBlock(stream, state, f) {
            return state.f = state.block = f,
            f(stream, state)
        }
        function blankLine(state) {
            return state.linkTitle = !1,
            state.em = !1,
            state.strong = !1,
            state.strikethrough = !1,
            state.quote = 0,
            htmlFound || state.f != htmlBlock || (state.f = inlineNormal,
            state.block = blockNormal),
            state.trailingSpace = 0,
            state.trailingSpaceNewLine = !1,
            state.thisLineHasContent = !1,
            null
        }
        function blockNormal(stream, state) {
            var sol = stream.sol()
              , prevLineIsList = !1 !== state.list;
            !1 !== state.list && state.indentationDiff >= 0 ? (state.indentationDiff < 4 && (state.indentation -= state.indentationDiff),
            state.list = null) : !1 !== state.list && state.indentation > 0 ? (state.list = null,
            state.listDepth = Math.floor(state.indentation / 4)) : !1 !== state.list && (state.list = !1,
            state.listDepth = 0);
            var match = null;
            if (state.indentationDiff >= 4)
                return state.indentation -= 4,
                stream.skipToEnd(),
                code;
            if (stream.eatSpace())
                return null;
            if (match = stream.match(atxHeaderRE))
                return state.header = match[0].length <= 6 ? match[0].length : 6,
                modeCfg.highlightFormatting && (state.formatting = "header"),
                state.f = state.inline,
                getType(state);
            if (state.prevLineHasContent && (match = stream.match(setextHeaderRE)))
                return state.header = "=" == match[0].charAt(0) ? 1 : 2,
                modeCfg.highlightFormatting && (state.formatting = "header"),
                state.f = state.inline,
                getType(state);
            if (stream.eat(">"))
                return state.indentation++,
                state.quote = sol ? 1 : state.quote + 1,
                modeCfg.highlightFormatting && (state.formatting = "quote"),
                stream.eatSpace(),
                getType(state);
            if ("[" === stream.peek())
                return switchInline(stream, state, footnoteLink);
            if (stream.match(hrRE, !0))
                return hr;
            if ((!state.prevLineHasContent || prevLineIsList) && (stream.match(ulRE, !1) || stream.match(olRE, !1))) {
                var listType = null;
                return stream.match(ulRE, !0) ? listType = "ul" : (stream.match(olRE, !0),
                listType = "ol"),
                state.indentation += 4,
                state.list = !0,
                state.listDepth++,
                modeCfg.taskLists && stream.match(taskListRE, !1) && (state.taskList = !0),
                state.f = state.inline,
                modeCfg.highlightFormatting && (state.formatting = ["list", "list-" + listType]),
                getType(state)
            }
            return modeCfg.fencedCodeBlocks && stream.match(/^```[ \t]*([\w+#]*)/, !0) ? (state.localMode = getMode(RegExp.$1),
            state.localMode && (state.localState = state.localMode.startState()),
            state.f = state.block = local,
            modeCfg.highlightFormatting && (state.formatting = "code-block"),
            state.code = !0,
            getType(state)) : switchInline(stream, state, state.inline)
        }
        function htmlBlock(stream, state) {
            var style = htmlMode.token(stream, state.htmlState);
            return (htmlFound && null === state.htmlState.tagStart && !state.htmlState.context || state.md_inside && stream.current().indexOf(">") > -1) && (state.f = inlineNormal,
            state.block = blockNormal,
            state.htmlState = null),
            style
        }
        function local(stream, state) {
            return stream.sol() && stream.match("```", !1) ? (state.localMode = state.localState = null,
            state.f = state.block = leavingLocal,
            null) : state.localMode ? state.localMode.token(stream, state.localState) : (stream.skipToEnd(),
            code)
        }
        function leavingLocal(stream, state) {
            stream.match("```"),
            state.block = blockNormal,
            state.f = inlineNormal,
            modeCfg.highlightFormatting && (state.formatting = "code-block"),
            state.code = !0;
            var returnType = getType(state);
            return state.code = !1,
            returnType
        }
        function getType(state) {
            var styles = [];
            if (state.formatting) {
                styles.push(formatting),
                "string" == typeof state.formatting && (state.formatting = [state.formatting]);
                for (var i = 0; i < state.formatting.length; i++)
                    styles.push(formatting + "-" + state.formatting[i]),
                    "header" === state.formatting[i] && styles.push(formatting + "-" + state.formatting[i] + "-" + state.header),
                    "quote" === state.formatting[i] && (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote ? styles.push(formatting + "-" + state.formatting[i] + "-" + state.quote) : styles.push("error"))
            }
            if (state.taskOpen)
                return styles.push("meta"),
                styles.length ? styles.join(" ") : null;
            if (state.taskClosed)
                return styles.push("property"),
                styles.length ? styles.join(" ") : null;
            if (state.linkHref)
                return styles.push(linkhref),
                styles.length ? styles.join(" ") : null;
            if (state.strong && styles.push(strong),
            state.em && styles.push(em),
            state.strikethrough && styles.push(strikethrough),
            state.linkText && styles.push(linktext),
            state.code && styles.push(code),
            state.header && (styles.push(header),
            styles.push(header + "-" + state.header)),
            state.quote && (styles.push(quote),
            !modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote ? styles.push(quote + "-" + state.quote) : styles.push(quote + "-" + modeCfg.maxBlockquoteDepth)),
            !1 !== state.list) {
                var listMod = (state.listDepth - 1) % 3;
                listMod ? 1 === listMod ? styles.push(list2) : styles.push(list3) : styles.push(list1)
            }
            return state.trailingSpaceNewLine ? styles.push("trailing-space-new-line") : state.trailingSpace && styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b")),
            styles.length ? styles.join(" ") : null
        }
        function handleText(stream, state) {
            if (stream.match(textRE, !0))
                return getType(state)
        }
        function inlineNormal(stream, state) {
            var style = state.text(stream, state);
            if (void 0 !== style)
                return style;
            if (state.list)
                return state.list = null,
                getType(state);
            if (state.taskList) {
                return "x" !== stream.match(taskListRE, !0)[1] ? state.taskOpen = !0 : state.taskClosed = !0,
                modeCfg.highlightFormatting && (state.formatting = "task"),
                state.taskList = !1,
                getType(state)
            }
            if (state.taskOpen = !1,
            state.taskClosed = !1,
            state.header && stream.match(/^#+$/, !0))
                return modeCfg.highlightFormatting && (state.formatting = "header"),
                getType(state);
            var sol = stream.sol()
              , ch = stream.next();
            if ("\\" === ch && (stream.next(),
            modeCfg.highlightFormatting)) {
                var type = getType(state);
                return type ? type + " formatting-escape" : "formatting-escape"
            }
            if (state.linkTitle) {
                state.linkTitle = !1;
                var matchCh = ch;
                "(" === ch && (matchCh = ")"),
                matchCh = (matchCh + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
                var regex = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;
                if (stream.match(new RegExp(regex), !0))
                    return linkhref
            }
            if ("`" === ch) {
                var previousFormatting = state.formatting;
                modeCfg.highlightFormatting && (state.formatting = "code");
                var t = getType(state)
                  , before = stream.pos;
                stream.eatWhile("`");
                var difference = 1 + stream.pos - before;
                return state.code ? difference === codeDepth ? (state.code = !1,
                t) : (state.formatting = previousFormatting,
                getType(state)) : (codeDepth = difference,
                state.code = !0,
                getType(state))
            }
            if (state.code)
                return getType(state);
            if ("!" === ch && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, !1))
                return stream.match(/\[[^\]]*\]/),
                state.inline = state.f = linkHref,
                image;
            if ("[" === ch && stream.match(/.*\](\(| ?\[)/, !1))
                return state.linkText = !0,
                modeCfg.highlightFormatting && (state.formatting = "link"),
                getType(state);
            if ("]" === ch && state.linkText) {
                modeCfg.highlightFormatting && (state.formatting = "link");
                var type = getType(state);
                return state.linkText = !1,
                state.inline = state.f = linkHref,
                type
            }
            if ("<" === ch && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, !1)) {
                state.f = state.inline = linkInline,
                modeCfg.highlightFormatting && (state.formatting = "link");
                var type = getType(state);
                return type ? type += " " : type = "",
                type + linkinline
            }
            if ("<" === ch && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, !1)) {
                state.f = state.inline = linkInline,
                modeCfg.highlightFormatting && (state.formatting = "link");
                var type = getType(state);
                return type ? type += " " : type = "",
                type + linkemail
            }
            if ("<" === ch && stream.match(/^\w/, !1)) {
                if (-1 != stream.string.indexOf(">")) {
                    /markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(stream.string.substring(1, stream.string.indexOf(">"))) && (state.md_inside = !0)
                }
                return stream.backUp(1),
                state.htmlState = CodeMirror.startState(htmlMode),
                switchBlock(stream, state, htmlBlock)
            }
            if ("<" === ch && stream.match(/^\/\w*?>/))
                return state.md_inside = !1,
                "tag";
            var ignoreUnderscore = !1;
            if (!modeCfg.underscoresBreakWords && "_" === ch && "_" !== stream.peek() && stream.match(/(\w)/, !1)) {
                var prevPos = stream.pos - 2;
                if (prevPos >= 0) {
                    var prevCh = stream.string.charAt(prevPos);
                    "_" !== prevCh && prevCh.match(/(\w)/, !1) && (ignoreUnderscore = !0)
                }
            }
            if ("*" === ch || "_" === ch && !ignoreUnderscore)
                if (sol && " " === stream.peek())
                    ;
                else {
                    if (state.strong === ch && stream.eat(ch)) {
                        modeCfg.highlightFormatting && (state.formatting = "strong");
                        var t = getType(state);
                        return state.strong = !1,
                        t
                    }
                    if (!state.strong && stream.eat(ch))
                        return state.strong = ch,
                        modeCfg.highlightFormatting && (state.formatting = "strong"),
                        getType(state);
                    if (state.em === ch) {
                        modeCfg.highlightFormatting && (state.formatting = "em");
                        var t = getType(state);
                        return state.em = !1,
                        t
                    }
                    if (!state.em)
                        return state.em = ch,
                        modeCfg.highlightFormatting && (state.formatting = "em"),
                        getType(state)
                }
            else if (" " === ch && (stream.eat("*") || stream.eat("_"))) {
                if (" " === stream.peek())
                    return getType(state);
                stream.backUp(1)
            }
            if (modeCfg.strikethrough)
                if ("~" === ch && stream.eatWhile(ch)) {
                    if (state.strikethrough) {
                        modeCfg.highlightFormatting && (state.formatting = "strikethrough");
                        var t = getType(state);
                        return state.strikethrough = !1,
                        t
                    }
                    if (stream.match(/^[^\s]/, !1))
                        return state.strikethrough = !0,
                        modeCfg.highlightFormatting && (state.formatting = "strikethrough"),
                        getType(state)
                } else if (" " === ch && stream.match(/^~~/, !0)) {
                    if (" " === stream.peek())
                        return getType(state);
                    stream.backUp(2)
                }
            return " " === ch && (stream.match(/ +$/, !1) ? state.trailingSpace++ : state.trailingSpace && (state.trailingSpaceNewLine = !0)),
            getType(state)
        }
        function linkInline(stream, state) {
            if (">" === stream.next()) {
                state.f = state.inline = inlineNormal,
                modeCfg.highlightFormatting && (state.formatting = "link");
                var type = getType(state);
                return type ? type += " " : type = "",
                type + linkinline
            }
            return stream.match(/^[^>]+/, !0),
            linkinline
        }
        function linkHref(stream, state) {
            if (stream.eatSpace())
                return null;
            var ch = stream.next();
            return "(" === ch || "[" === ch ? (state.f = state.inline = getLinkHrefInside("(" === ch ? ")" : "]"),
            modeCfg.highlightFormatting && (state.formatting = "link-string"),
            state.linkHref = !0,
            getType(state)) : "error"
        }
        function getLinkHrefInside(endChar) {
            return function(stream, state) {
                if (stream.next() === endChar) {
                    state.f = state.inline = inlineNormal,
                    modeCfg.highlightFormatting && (state.formatting = "link-string");
                    var returnState = getType(state);
                    return state.linkHref = !1,
                    returnState
                }
                return stream.match(inlineRE(endChar), !0) && stream.backUp(1),
                state.linkHref = !0,
                getType(state)
            }
        }
        function footnoteLink(stream, state) {
            return stream.match(/^[^\]]*\]:/, !1) ? (state.f = footnoteLinkInside,
            stream.next(),
            modeCfg.highlightFormatting && (state.formatting = "link"),
            state.linkText = !0,
            getType(state)) : switchInline(stream, state, inlineNormal)
        }
        function footnoteLinkInside(stream, state) {
            if (stream.match(/^\]:/, !0)) {
                state.f = state.inline = footnoteUrl,
                modeCfg.highlightFormatting && (state.formatting = "link");
                var returnType = getType(state);
                return state.linkText = !1,
                returnType
            }
            return stream.match(/^[^\]]+/, !0),
            linktext
        }
        function footnoteUrl(stream, state) {
            return stream.eatSpace() ? null : (stream.match(/^[^\s]+/, !0),
            void 0 === stream.peek() ? state.linkTitle = !0 : stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, !0),
            state.f = state.inline = inlineNormal,
            linkhref)
        }
        function inlineRE(endChar) {
            return savedInlineRE[endChar] || (endChar = (endChar + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"),
            savedInlineRE[endChar] = new RegExp("^(?:[^\\\\]|\\\\.)*?(" + endChar + ")")),
            savedInlineRE[endChar]
        }
        var htmlFound = CodeMirror.modes.hasOwnProperty("xml")
          , htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {
            name: "xml",
            htmlMode: !0
        } : "text/plain");
        void 0 === modeCfg.highlightFormatting && (modeCfg.highlightFormatting = !1),
        void 0 === modeCfg.maxBlockquoteDepth && (modeCfg.maxBlockquoteDepth = 0),
        void 0 === modeCfg.underscoresBreakWords && (modeCfg.underscoresBreakWords = !0),
        void 0 === modeCfg.fencedCodeBlocks && (modeCfg.fencedCodeBlocks = !1),
        void 0 === modeCfg.taskLists && (modeCfg.taskLists = !1),
        void 0 === modeCfg.strikethrough && (modeCfg.strikethrough = !1);
        var codeDepth = 0
          , header = "header"
          , code = "comment"
          , quote = "quote"
          , list1 = "variable-2"
          , list2 = "variable-3"
          , list3 = "keyword"
          , hr = "hr"
          , image = "tag"
          , formatting = "formatting"
          , linkinline = "link"
          , linkemail = "link"
          , linktext = "link"
          , linkhref = "string"
          , em = "em"
          , strong = "strong"
          , strikethrough = "strikethrough"
          , hrRE = /^([*\-=_])(?:\s*\1){2,}\s*$/
          , ulRE = /^[*\-+]\s+/
          , olRE = /^[0-9]+\.\s+/
          , taskListRE = /^\[(x| )\](?=\s)/
          , atxHeaderRE = /^#+/
          , setextHeaderRE = /^(?:\={1,}|-{1,})$/
          , textRE = /^[^#!\[\]*_\\<>` "'(~]+/
          , savedInlineRE = []
          , mode = {
            startState: function() {
                return {
                    f: blockNormal,
                    prevLineHasContent: !1,
                    thisLineHasContent: !1,
                    block: blockNormal,
                    htmlState: null,
                    indentation: 0,
                    inline: inlineNormal,
                    text: handleText,
                    formatting: !1,
                    linkText: !1,
                    linkHref: !1,
                    linkTitle: !1,
                    em: !1,
                    strong: !1,
                    header: 0,
                    taskList: !1,
                    list: !1,
                    listDepth: 0,
                    quote: 0,
                    trailingSpace: 0,
                    trailingSpaceNewLine: !1,
                    strikethrough: !1
                }
            },
            copyState: function(s) {
                return {
                    f: s.f,
                    prevLineHasContent: s.prevLineHasContent,
                    thisLineHasContent: s.thisLineHasContent,
                    block: s.block,
                    htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
                    indentation: s.indentation,
                    localMode: s.localMode,
                    localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,
                    inline: s.inline,
                    text: s.text,
                    formatting: !1,
                    linkTitle: s.linkTitle,
                    em: s.em,
                    strong: s.strong,
                    strikethrough: s.strikethrough,
                    header: s.header,
                    taskList: s.taskList,
                    list: s.list,
                    listDepth: s.listDepth,
                    quote: s.quote,
                    trailingSpace: s.trailingSpace,
                    trailingSpaceNewLine: s.trailingSpaceNewLine,
                    md_inside: s.md_inside
                }
            },
            token: function(stream, state) {
                if (state.formatting = !1,
                stream.sol()) {
                    var forceBlankLine = !!state.header;
                    if (state.header = 0,
                    stream.match(/^\s*$/, !0) || forceBlankLine)
                        return state.prevLineHasContent = !1,
                        blankLine(state),
                        forceBlankLine ? this.token(stream, state) : null;
                    state.prevLineHasContent = state.thisLineHasContent,
                    state.thisLineHasContent = !0,
                    state.taskList = !1,
                    state.code = !1,
                    state.trailingSpace = 0,
                    state.trailingSpaceNewLine = !1,
                    state.f = state.block;
                    var indentation = stream.match(/^\s*/, !0)[0].replace(/\t/g, "    ").length
                      , difference = 4 * Math.floor((indentation - state.indentation) / 4);
                    difference > 4 && (difference = 4);
                    var adjustedIndentation = state.indentation + difference;
                    if (state.indentationDiff = adjustedIndentation - state.indentation,
                    state.indentation = adjustedIndentation,
                    indentation > 0)
                        return null
                }
                return state.f(stream, state)
            },
            innerMode: function(state) {
                return state.block == htmlBlock ? {
                    state: state.htmlState,
                    mode: htmlMode
                } : state.localState ? {
                    state: state.localState,
                    mode: state.localMode
                } : {
                    state: state,
                    mode: mode
                }
            },
            blankLine: blankLine,
            getType: getType,
            fold: "markdown"
        };
        return mode
    }, "xml"),
    CodeMirror.defineMIME("text/x-markdown", "markdown")
}),
function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
}(function(CodeMirror) {
    "use strict";
    CodeMirror.overlayMode = function(base, overlay, combine) {
        return {
            startState: function() {
                return {
                    base: CodeMirror.startState(base),
                    overlay: CodeMirror.startState(overlay),
                    basePos: 0,
                    baseCur: null,
                    overlayPos: 0,
                    overlayCur: null,
                    streamSeen: null
                }
            },
            copyState: function(state) {
                return {
                    base: CodeMirror.copyState(base, state.base),
                    overlay: CodeMirror.copyState(overlay, state.overlay),
                    basePos: state.basePos,
                    baseCur: null,
                    overlayPos: state.overlayPos,
                    overlayCur: null
                }
            },
            token: function(stream, state) {
                return (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) && (state.streamSeen = stream,
                state.basePos = state.overlayPos = stream.start),
                stream.start == state.basePos && (state.baseCur = base.token(stream, state.base),
                state.basePos = stream.pos),
                stream.start == state.overlayPos && (stream.pos = stream.start,
                state.overlayCur = overlay.token(stream, state.overlay),
                state.overlayPos = stream.pos),
                stream.pos = Math.min(state.basePos, state.overlayPos),
                null == state.overlayCur ? state.baseCur : null != state.baseCur && state.overlay.combineTokens || combine && null == state.overlay.combineTokens ? state.baseCur + " " + state.overlayCur : state.overlayCur
            },
            indent: base.indent && function(state, textAfter) {
                return base.indent(state.base, textAfter)
            }
            ,
            electricChars: base.electricChars,
            innerMode: function(state) {
                return {
                    state: state.base,
                    mode: base
                }
            },
            blankLine: function(state) {
                base.blankLine && base.blankLine(state.base),
                overlay.blankLine && overlay.blankLine(state.overlay)
            }
        }
    }
}),
function(mod) {
    "object" == typeof exports && "object" == typeof module ? mod(require("../../lib/codemirror"), require("../markdown/markdown"), require("../../addon/mode/overlay")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod) : mod(CodeMirror)
}(function(CodeMirror) {
    "use strict";
    CodeMirror.defineMode("gfm", function(config, modeConfig) {
        function blankLine(state) {
            return state.code = !1,
            null
        }
        var codeDepth = 0
          , gfmOverlay = {
            startState: function() {
                return {
                    code: !1,
                    codeBlock: !1,
                    ateSpace: !1
                }
            },
            copyState: function(s) {
                return {
                    code: s.code,
                    codeBlock: s.codeBlock,
                    ateSpace: s.ateSpace
                }
            },
            token: function(stream, state) {
                if (state.combineTokens = null,
                state.codeBlock)
                    return stream.match(/^```/) ? (state.codeBlock = !1,
                    null) : (stream.skipToEnd(),
                    null);
                if (stream.sol() && (state.code = !1),
                stream.sol() && stream.match(/^```/))
                    return stream.skipToEnd(),
                    state.codeBlock = !0,
                    null;
                if ("`" === stream.peek()) {
                    stream.next();
                    var before = stream.pos;
                    stream.eatWhile("`");
                    var difference = 1 + stream.pos - before;
                    return state.code ? difference === codeDepth && (state.code = !1) : (codeDepth = difference,
                    state.code = !0),
                    null
                }
                if (state.code)
                    return stream.next(),
                    null;
                if (stream.eatSpace())
                    return state.ateSpace = !0,
                    null;
                if (stream.sol() || state.ateSpace) {
                    if (state.ateSpace = !1,
                    stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/))
                        return state.combineTokens = !0,
                        "link";
                    if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/))
                        return state.combineTokens = !0,
                        "link"
                }
                return stream.match(/^((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?«»“”‘’]))/i) && "](" != stream.string.slice(stream.start - 2, stream.start) ? (state.combineTokens = !0,
                "link") : (stream.next(),
                null)
            },
            blankLine: blankLine
        }
          , markdownConfig = {
            underscoresBreakWords: !1,
            taskLists: !0,
            fencedCodeBlocks: !0,
            strikethrough: !0
        };
        for (var attr in modeConfig)
            markdownConfig[attr] = modeConfig[attr];
        return markdownConfig.name = "markdown",
        CodeMirror.defineMIME("gfmBase", markdownConfig),
        CodeMirror.overlayMode(CodeMirror.getMode(config, "gfmBase"), gfmOverlay)
    }, "markdown")
}),
angular.module("ui.codemirror", []).constant("uiCodemirrorConfig", {}).directive("uiCodemirror", uiCodemirrorDirective),
uiCodemirrorDirective.$inject = ["$timeout", "uiCodemirrorConfig"],
function() {
    function Lexer(options) {
        this.tokens = [],
        this.tokens.links = {},
        this.options = options || marked.defaults,
        this.rules = block.normal,
        this.options.gfm && (this.options.tables ? this.rules = block.tables : this.rules = block.gfm)
    }
    function InlineLexer(links, options) {
        if (this.options = options || marked.defaults,
        this.links = links,
        this.rules = inline.normal,
        this.renderer = this.options.renderer || new Renderer,
        this.renderer.options = this.options,
        !this.links)
            throw new Error("Tokens array requires a `links` property.");
        this.options.gfm ? this.options.breaks ? this.rules = inline.breaks : this.rules = inline.gfm : this.options.pedantic && (this.rules = inline.pedantic)
    }
    function Renderer(options) {
        this.options = options || {}
    }
    function Parser(options) {
        this.tokens = [],
        this.token = null,
        this.options = options || marked.defaults,
        this.options.renderer = this.options.renderer || new Renderer,
        this.renderer = this.options.renderer,
        this.renderer.options = this.options
    }
    function escape(html, encode) {
        return html.replace(encode ? /&/g : /&(?!#?\w+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;")
    }
    function unescape(html) {
        return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function(_, n) {
            return n = n.toLowerCase(),
            "colon" === n ? ":" : "#" === n.charAt(0) ? "x" === n.charAt(1) ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1)) : ""
        })
    }
    function replace(regex, opt) {
        return regex = regex.source,
        opt = opt || "",
        function self(name, val) {
            return name ? (val = val.source || val,
            val = val.replace(/(^|[^\[])\^/g, "$1"),
            regex = regex.replace(name, val),
            self) : new RegExp(regex,opt)
        }
    }
    function noop() {}
    function merge(obj) {
        for (var target, key, i = 1; i < arguments.length; i++) {
            target = arguments[i];
            for (key in target)
                Object.prototype.hasOwnProperty.call(target, key) && (obj[key] = target[key])
        }
        return obj
    }
    function marked(src, opt, callback) {
        if (callback || "function" == typeof opt) {
            callback || (callback = opt,
            opt = null),
            opt = merge({}, marked.defaults, opt || {});
            var tokens, pending, highlight = opt.highlight, i = 0;
            try {
                tokens = Lexer.lex(src, opt)
            } catch (e) {
                return callback(e)
            }
            pending = tokens.length;
            var done = function(err) {
                if (err)
                    return opt.highlight = highlight,
                    callback(err);
                var out;
                try {
                    out = Parser.parse(tokens, opt)
                } catch (e) {
                    err = e
                }
                return opt.highlight = highlight,
                err ? callback(err) : callback(null, out)
            };
            if (!highlight || highlight.length < 3)
                return done();
            if (delete opt.highlight,
            !pending)
                return done();
            for (; i < tokens.length; i++)
                !function(token) {
                    "code" !== token.type ? --pending || done() : highlight(token.text, token.lang, function(err, code) {
                        return err ? done(err) : null == code || code === token.text ? --pending || done() : (token.text = code,
                        token.escaped = !0,
                        void (--pending || done()))
                    })
                }(tokens[i])
        } else
            try {
                return opt && (opt = merge({}, marked.defaults, opt)),
                Parser.parse(Lexer.lex(src, opt), opt)
            } catch (e) {
                if (e.message += "\nPlease report this to https://github.com/chjj/marked.",
                (opt || marked.defaults).silent)
                    return "<p>An error occured:</p><pre>" + escape(e.message + "", !0) + "</pre>";
                throw e
            }
    }
    var block = {
        newline: /^\n+/,
        code: /^( {4}[^\n]+\n*)+/,
        fences: noop,
        hr: /^( *[-*_]){3,} *(?:\n+|$)/,
        heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
        nptable: noop,
        lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
        blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
        list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
        html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
        table: noop,
        paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
        text: /^[^\n]+/
    };
    block.bullet = /(?:[*+-]|\d+\.)/,
    block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/,
    block.item = replace(block.item, "gm")(/bull/g, block.bullet)(),
    block.list = replace(block.list)(/bull/g, block.bullet)("hr", "\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))")("def", "\\n+(?=" + block.def.source + ")")(),
    block.blockquote = replace(block.blockquote)("def", block.def)(),
    block._tag = "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b",
    block.html = replace(block.html)("comment", /<!--[\s\S]*?-->/)("closed", /<(tag)[\s\S]+?<\/\1>/)("closing", /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, block._tag)(),
    block.paragraph = replace(block.paragraph)("hr", block.hr)("heading", block.heading)("lheading", block.lheading)("blockquote", block.blockquote)("tag", "<" + block._tag)("def", block.def)(),
    block.normal = merge({}, block),
    block.gfm = merge({}, block.normal, {
        fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
        paragraph: /^/,
        heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
    }),
    block.gfm.paragraph = replace(block.paragraph)("(?!", "(?!" + block.gfm.fences.source.replace("\\1", "\\2") + "|" + block.list.source.replace("\\1", "\\3") + "|")(),
    block.tables = merge({}, block.gfm, {
        nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
        table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
    }),
    Lexer.rules = block,
    Lexer.lex = function(src, options) {
        return new Lexer(options).lex(src)
    }
    ,
    Lexer.prototype.lex = function(src) {
        return src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ").replace(/\u00a0/g, " ").replace(/\u2424/g, "\n"),
        this.token(src, !0)
    }
    ,
    Lexer.prototype.token = function(src, top, bq) {
        for (var next, loose, cap, bull, b, item, space, i, l, src = src.replace(/^ +$/gm, ""); src; )
            if ((cap = this.rules.newline.exec(src)) && (src = src.substring(cap[0].length),
            cap[0].length > 1 && this.tokens.push({
                type: "space"
            })),
            cap = this.rules.code.exec(src))
                src = src.substring(cap[0].length),
                cap = cap[0].replace(/^ {4}/gm, ""),
                this.tokens.push({
                    type: "code",
                    text: this.options.pedantic ? cap : cap.replace(/\n+$/, "")
                });
            else if (cap = this.rules.fences.exec(src))
                src = src.substring(cap[0].length),
                this.tokens.push({
                    type: "code",
                    lang: cap[2],
                    text: cap[3] || ""
                });
            else if (cap = this.rules.heading.exec(src))
                src = src.substring(cap[0].length),
                this.tokens.push({
                    type: "heading",
                    depth: cap[1].length,
                    text: cap[2]
                });
            else if (top && (cap = this.rules.nptable.exec(src))) {
                for (src = src.substring(cap[0].length),
                item = {
                    type: "table",
                    header: cap[1].replace(/^ *| *\| *$/g, "").split(/ *\| */),
                    align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                    cells: cap[3].replace(/\n$/, "").split("\n")
                },
                i = 0; i < item.align.length; i++)
                    /^ *-+: *$/.test(item.align[i]) ? item.align[i] = "right" : /^ *:-+: *$/.test(item.align[i]) ? item.align[i] = "center" : /^ *:-+ *$/.test(item.align[i]) ? item.align[i] = "left" : item.align[i] = null;
                for (i = 0; i < item.cells.length; i++)
                    item.cells[i] = item.cells[i].split(/ *\| */);
                this.tokens.push(item)
            } else if (cap = this.rules.lheading.exec(src))
                src = src.substring(cap[0].length),
                this.tokens.push({
                    type: "heading",
                    depth: "=" === cap[2] ? 1 : 2,
                    text: cap[1]
                });
            else if (cap = this.rules.hr.exec(src))
                src = src.substring(cap[0].length),
                this.tokens.push({
                    type: "hr"
                });
            else if (cap = this.rules.blockquote.exec(src))
                src = src.substring(cap[0].length),
                this.tokens.push({
                    type: "blockquote_start"
                }),
                cap = cap[0].replace(/^ *> ?/gm, ""),
                this.token(cap, top, !0),
                this.tokens.push({
                    type: "blockquote_end"
                });
            else if (cap = this.rules.list.exec(src)) {
                for (src = src.substring(cap[0].length),
                bull = cap[2],
                this.tokens.push({
                    type: "list_start",
                    ordered: bull.length > 1
                }),
                cap = cap[0].match(this.rules.item),
                next = !1,
                l = cap.length,
                i = 0; i < l; i++)
                    item = cap[i],
                    space = item.length,
                    item = item.replace(/^ *([*+-]|\d+\.) +/, ""),
                    ~item.indexOf("\n ") && (space -= item.length,
                    item = this.options.pedantic ? item.replace(/^ {1,4}/gm, "") : item.replace(new RegExp("^ {1," + space + "}","gm"), "")),
                    this.options.smartLists && i !== l - 1 && (b = block.bullet.exec(cap[i + 1])[0],
                    bull === b || bull.length > 1 && b.length > 1 || (src = cap.slice(i + 1).join("\n") + src,
                    i = l - 1)),
                    loose = next || /\n\n(?!\s*$)/.test(item),
                    i !== l - 1 && (next = "\n" === item.charAt(item.length - 1),
                    loose || (loose = next)),
                    this.tokens.push({
                        type: loose ? "loose_item_start" : "list_item_start"
                    }),
                    this.token(item, !1, bq),
                    this.tokens.push({
                        type: "list_item_end"
                    });
                this.tokens.push({
                    type: "list_end"
                })
            } else if (cap = this.rules.html.exec(src))
                src = src.substring(cap[0].length),
                this.tokens.push({
                    type: this.options.sanitize ? "paragraph" : "html",
                    pre: !this.options.sanitizer && ("pre" === cap[1] || "script" === cap[1] || "style" === cap[1]),
                    text: cap[0]
                });
            else if (!bq && top && (cap = this.rules.def.exec(src)))
                src = src.substring(cap[0].length),
                this.tokens.links[cap[1].toLowerCase()] = {
                    href: cap[2],
                    title: cap[3]
                };
            else if (top && (cap = this.rules.table.exec(src))) {
                for (src = src.substring(cap[0].length),
                item = {
                    type: "table",
                    header: cap[1].replace(/^ *| *\| *$/g, "").split(/ *\| */),
                    align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                    cells: cap[3].replace(/(?: *\| *)?\n$/, "").split("\n")
                },
                i = 0; i < item.align.length; i++)
                    /^ *-+: *$/.test(item.align[i]) ? item.align[i] = "right" : /^ *:-+: *$/.test(item.align[i]) ? item.align[i] = "center" : /^ *:-+ *$/.test(item.align[i]) ? item.align[i] = "left" : item.align[i] = null;
                for (i = 0; i < item.cells.length; i++)
                    item.cells[i] = item.cells[i].replace(/^ *\| *| *\| *$/g, "").split(/ *\| */);
                this.tokens.push(item)
            } else if (top && (cap = this.rules.paragraph.exec(src)))
                src = src.substring(cap[0].length),
                this.tokens.push({
                    type: "paragraph",
                    text: "\n" === cap[1].charAt(cap[1].length - 1) ? cap[1].slice(0, -1) : cap[1]
                });
            else if (cap = this.rules.text.exec(src))
                src = src.substring(cap[0].length),
                this.tokens.push({
                    type: "text",
                    text: cap[0]
                });
            else if (src)
                throw new Error("Infinite loop on byte: " + src.charCodeAt(0));
        return this.tokens
    }
    ;
    var inline = {
        escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
        autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
        url: noop,
        tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
        link: /^!?\[(inside)\]\(href\)/,
        reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
        nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
        strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
        em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
        code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
        br: /^ {2,}\n(?!\s*$)/,
        del: noop,
        text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
    };
    inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/,
    inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/,
    inline.link = replace(inline.link)("inside", inline._inside)("href", inline._href)(),
    inline.reflink = replace(inline.reflink)("inside", inline._inside)(),
    inline.normal = merge({}, inline),
    inline.pedantic = merge({}, inline.normal, {
        strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
    }),
    inline.gfm = merge({}, inline.normal, {
        escape: replace(inline.escape)("])", "~|])")(),
        url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
        del: /^~~(?=\S)([\s\S]*?\S)~~/,
        text: replace(inline.text)("]|", "~]|")("|", "|https?://|")()
    }),
    inline.breaks = merge({}, inline.gfm, {
        br: replace(inline.br)("{2,}", "*")(),
        text: replace(inline.gfm.text)("{2,}", "*")()
    }),
    InlineLexer.rules = inline,
    InlineLexer.output = function(src, links, options) {
        return new InlineLexer(links,options).output(src)
    }
    ,
    InlineLexer.prototype.output = function(src) {
        for (var link, text, href, cap, out = ""; src; )
            if (cap = this.rules.escape.exec(src))
                src = src.substring(cap[0].length),
                out += cap[1];
            else if (cap = this.rules.autolink.exec(src))
                src = src.substring(cap[0].length),
                "@" === cap[2] ? (text = ":" === cap[1].charAt(6) ? this.mangle(cap[1].substring(7)) : this.mangle(cap[1]),
                href = this.mangle("mailto:") + text) : (text = escape(cap[1]),
                href = text),
                out += this.renderer.link(href, null, text);
            else if (this.inLink || !(cap = this.rules.url.exec(src))) {
                if (cap = this.rules.tag.exec(src))
                    !this.inLink && /^<a /i.test(cap[0]) ? this.inLink = !0 : this.inLink && /^<\/a>/i.test(cap[0]) && (this.inLink = !1),
                    src = src.substring(cap[0].length),
                    out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
                else if (cap = this.rules.link.exec(src))
                    src = src.substring(cap[0].length),
                    this.inLink = !0,
                    out += this.outputLink(cap, {
                        href: cap[2],
                        title: cap[3]
                    }),
                    this.inLink = !1;
                else if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
                    if (src = src.substring(cap[0].length),
                    link = (cap[2] || cap[1]).replace(/\s+/g, " "),
                    !(link = this.links[link.toLowerCase()]) || !link.href) {
                        out += cap[0].charAt(0),
                        src = cap[0].substring(1) + src;
                        continue
                    }
                    this.inLink = !0,
                    out += this.outputLink(cap, link),
                    this.inLink = !1
                } else if (cap = this.rules.strong.exec(src))
                    src = src.substring(cap[0].length),
                    out += this.renderer.strong(this.output(cap[2] || cap[1]));
                else if (cap = this.rules.em.exec(src))
                    src = src.substring(cap[0].length),
                    out += this.renderer.em(this.output(cap[2] || cap[1]));
                else if (cap = this.rules.code.exec(src))
                    src = src.substring(cap[0].length),
                    out += this.renderer.codespan(escape(cap[2], !0));
                else if (cap = this.rules.br.exec(src))
                    src = src.substring(cap[0].length),
                    out += this.renderer.br();
                else if (cap = this.rules.del.exec(src))
                    src = src.substring(cap[0].length),
                    out += this.renderer.del(this.output(cap[1]));
                else if (cap = this.rules.text.exec(src))
                    src = src.substring(cap[0].length),
                    out += this.renderer.text(escape(this.smartypants(cap[0])));
                else if (src)
                    throw new Error("Infinite loop on byte: " + src.charCodeAt(0))
            } else
                src = src.substring(cap[0].length),
                text = escape(cap[1]),
                href = text,
                out += this.renderer.link(href, null, text);
        return out
    }
    ,
    InlineLexer.prototype.outputLink = function(cap, link) {
        var href = escape(link.href)
          , title = link.title ? escape(link.title) : null;
        return "!" !== cap[0].charAt(0) ? this.renderer.link(href, title, this.output(cap[1])) : this.renderer.image(href, title, escape(cap[1]))
    }
    ,
    InlineLexer.prototype.smartypants = function(text) {
        return this.options.smartypants ? text.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014\/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014\/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…") : text
    }
    ,
    InlineLexer.prototype.mangle = function(text) {
        if (!this.options.mangle)
            return text;
        for (var ch, out = "", l = text.length, i = 0; i < l; i++)
            ch = text.charCodeAt(i),
            Math.random() > .5 && (ch = "x" + ch.toString(16)),
            out += "&#" + ch + ";";
        return out
    }
    ,
    Renderer.prototype.code = function(code, lang, escaped) {
        if (this.options.highlight) {
            var out = this.options.highlight(code, lang);
            null != out && out !== code && (escaped = !0,
            code = out)
        }
        return lang ? '<pre><code class="' + this.options.langPrefix + escape(lang, !0) + '">' + (escaped ? code : escape(code, !0)) + "\n</code></pre>\n" : "<pre><code>" + (escaped ? code : escape(code, !0)) + "\n</code></pre>"
    }
    ,
    Renderer.prototype.blockquote = function(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n"
    }
    ,
    Renderer.prototype.html = function(html) {
        return html
    }
    ,
    Renderer.prototype.heading = function(text, level, raw) {
        return "<h" + level + ' id="' + this.options.headerPrefix + raw.toLowerCase().replace(/[^\w]+/g, "-") + '">' + text + "</h" + level + ">\n"
    }
    ,
    Renderer.prototype.hr = function() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n"
    }
    ,
    Renderer.prototype.list = function(body, ordered) {
        var type = ordered ? "ol" : "ul";
        return "<" + type + ">\n" + body + "</" + type + ">\n"
    }
    ,
    Renderer.prototype.listitem = function(text) {
        return "<li>" + text + "</li>\n"
    }
    ,
    Renderer.prototype.paragraph = function(text) {
        return "<p>" + text + "</p>\n"
    }
    ,
    Renderer.prototype.table = function(header, body) {
        return "<table>\n<thead>\n" + header + "</thead>\n<tbody>\n" + body + "</tbody>\n</table>\n"
    }
    ,
    Renderer.prototype.tablerow = function(content) {
        return "<tr>\n" + content + "</tr>\n"
    }
    ,
    Renderer.prototype.tablecell = function(content, flags) {
        var type = flags.header ? "th" : "td";
        return (flags.align ? "<" + type + ' style="text-align:' + flags.align + '">' : "<" + type + ">") + content + "</" + type + ">\n"
    }
    ,
    Renderer.prototype.strong = function(text) {
        return "<strong>" + text + "</strong>"
    }
    ,
    Renderer.prototype.em = function(text) {
        return "<em>" + text + "</em>"
    }
    ,
    Renderer.prototype.codespan = function(text) {
        return "<code>" + text + "</code>"
    }
    ,
    Renderer.prototype.br = function() {
        return this.options.xhtml ? "<br/>" : "<br>"
    }
    ,
    Renderer.prototype.del = function(text) {
        return "<del>" + text + "</del>"
    }
    ,
    Renderer.prototype.link = function(href, title, text) {
        if (this.options.sanitize) {
            try {
                var prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase()
            } catch (e) {
                return ""
            }
            if (0 === prot.indexOf("javascript:") || 0 === prot.indexOf("vbscript:") || 0 === prot.indexOf("data:"))
                return ""
        }
        var out = '<a href="' + href + '"';
        return title && (out += ' title="' + title + '"'),
        out += ">" + text + "</a>"
    }
    ,
    Renderer.prototype.image = function(href, title, text) {
        var out = '<img src="' + href + '" alt="' + text + '"';
        return title && (out += ' title="' + title + '"'),
        out += this.options.xhtml ? "/>" : ">"
    }
    ,
    Renderer.prototype.text = function(text) {
        return text
    }
    ,
    Parser.parse = function(src, options, renderer) {
        return new Parser(options,renderer).parse(src)
    }
    ,
    Parser.prototype.parse = function(src) {
        this.inline = new InlineLexer(src.links,this.options,this.renderer),
        this.tokens = src.reverse();
        for (var out = ""; this.next(); )
            out += this.tok();
        return out
    }
    ,
    Parser.prototype.next = function() {
        return this.token = this.tokens.pop()
    }
    ,
    Parser.prototype.peek = function() {
        return this.tokens[this.tokens.length - 1] || 0
    }
    ,
    Parser.prototype.parseText = function() {
        for (var body = this.token.text; "text" === this.peek().type; )
            body += "\n" + this.next().text;
        return this.inline.output(body)
    }
    ,
    Parser.prototype.tok = function() {
        switch (this.token.type) {
        case "space":
            return "";
        case "hr":
            return this.renderer.hr();
        case "heading":
            return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text);
        case "code":
            return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
        case "table":
            var i, row, cell, j, header = "", body = "";
            for (cell = "",
            i = 0; i < this.token.header.length; i++)
                ({
                    header: !0,
                    align: this.token.align[i]
                }),
                cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), {
                    header: !0,
                    align: this.token.align[i]
                });
            for (header += this.renderer.tablerow(cell),
            i = 0; i < this.token.cells.length; i++) {
                for (row = this.token.cells[i],
                cell = "",
                j = 0; j < row.length; j++)
                    cell += this.renderer.tablecell(this.inline.output(row[j]), {
                        header: !1,
                        align: this.token.align[j]
                    });
                body += this.renderer.tablerow(cell)
            }
            return this.renderer.table(header, body);
        case "blockquote_start":
            for (var body = ""; "blockquote_end" !== this.next().type; )
                body += this.tok();
            return this.renderer.blockquote(body);
        case "list_start":
            for (var body = "", ordered = this.token.ordered; "list_end" !== this.next().type; )
                body += this.tok();
            return this.renderer.list(body, ordered);
        case "list_item_start":
            for (var body = ""; "list_item_end" !== this.next().type; )
                body += "text" === this.token.type ? this.parseText() : this.tok();
            return this.renderer.listitem(body);
        case "loose_item_start":
            for (var body = ""; "list_item_end" !== this.next().type; )
                body += this.tok();
            return this.renderer.listitem(body);
        case "html":
            var html = this.token.pre || this.options.pedantic ? this.token.text : this.inline.output(this.token.text);
            return this.renderer.html(html);
        case "paragraph":
            return this.renderer.paragraph(this.inline.output(this.token.text));
        case "text":
            return this.renderer.paragraph(this.parseText())
        }
    }
    ,
    noop.exec = noop,
    marked.options = marked.setOptions = function(opt) {
        return merge(marked.defaults, opt),
        marked
    }
    ,
    marked.defaults = {
        gfm: !0,
        tables: !0,
        breaks: !1,
        pedantic: !1,
        sanitize: !1,
        sanitizer: null,
        mangle: !0,
        smartLists: !1,
        silent: !1,
        highlight: null,
        langPrefix: "lang-",
        smartypants: !1,
        headerPrefix: "",
        renderer: new Renderer,
        xhtml: !1
    },
    marked.Parser = Parser,
    marked.parser = Parser.parse,
    marked.Renderer = Renderer,
    marked.Lexer = Lexer,
    marked.lexer = Lexer.lex,
    marked.InlineLexer = InlineLexer,
    marked.inlineLexer = InlineLexer.output,
    marked.parse = marked,
    "undefined" != typeof module && "object" == typeof exports ? module.exports = marked : "function" == typeof define && define.amd ? define(function() {
        return marked
    }) : this.marked = marked
}
.call(function() {
    return this || ("undefined" != typeof window ? window : global)
}()),
function() {
    function use(name) {
        _p.r([moduleMapping[name]])
    }
    var _p = {
        r: function(index) {
            if (_p[index].inited)
                return _p[index].value;
            if ("function" != typeof _p[index].value)
                return _p[index].inited = !0,
                _p[index].value;
            var module = {
                exports: {}
            }
              , returnValue = _p[index].value(null, module.exports, module);
            if (_p[index].inited = !0,
            _p[index].value = returnValue,
            void 0 !== returnValue)
                return returnValue;
            for (var key in module.exports)
                if (module.exports.hasOwnProperty(key))
                    return _p[index].inited = !0,
                    _p[index].value = module.exports,
                    module.exports
        }
    };
    _p[0] = {
        value: function(require) {
            function parseTime(str) {
                var value = parseFloat(str, 10);
                return /ms/.test(str) ? value : /s/.test(str) ? 1e3 * value : /min/.test(str) ? 60 * value * 1e3 : value
            }
            var Timeline = _p.r(8)
              , easingTable = _p.r(1)
              , Animator = _p.r(11).createClass("Animator", {
                constructor: function(beginValue, finishValue, setter) {
                    if (1 == arguments.length) {
                        var opt = arguments[0];
                        this.beginValue = opt.beginValue,
                        this.finishValue = opt.finishValue,
                        this.setter = opt.setter
                    } else
                        this.beginValue = beginValue,
                        this.finishValue = finishValue,
                        this.setter = setter
                },
                start: function(target, duration, easing, delay, callback) {
                    2 === arguments.length && "object" == typeof duration && (easing = duration.easing,
                    delay = duration.delay,
                    callback = duration.callback,
                    duration = duration.duration),
                    4 === arguments.length && "function" == typeof delay && (callback = delay,
                    delay = 0);
                    var timeline = this.create(target, duration, easing, callback);
                    return delay = parseTime(delay),
                    delay > 0 ? setTimeout(function() {
                        timeline.play()
                    }, delay) : timeline.play(),
                    timeline
                },
                create: function(target, duration, easing, callback) {
                    var timeline;
                    return duration = duration && parseTime(duration) || Animator.DEFAULT_DURATION,
                    easing = easing || Animator.DEFAULT_EASING,
                    "string" == typeof easing && (easing = easingTable[easing]),
                    timeline = new Timeline(this,target,duration,easing),
                    "function" == typeof callback && timeline.on("finish", callback),
                    timeline
                },
                reverse: function() {
                    return new Animator(this.finishValue,this.beginValue,this.setter)
                }
            });
            Animator.DEFAULT_DURATION = 300,
            Animator.DEFAULT_EASING = "linear";
            var Shape = _p.r(60);
            return _p.r(11).extendClass(Shape, {
                animate: function(animator, duration, easing, delay, callback) {
                    function dequeue() {
                        queue.shift(),
                        queue.length && setTimeout(queue[0].t.play.bind(queue[0].t), queue[0].d)
                    }
                    var queue = this._KityAnimateQueue = this._KityAnimateQueue || []
                      , timeline = animator.create(this, duration, easing, callback);
                    return timeline.on("finish", dequeue),
                    queue.push({
                        t: timeline,
                        d: delay
                    }),
                    1 == queue.length && setTimeout(timeline.play.bind(timeline), delay),
                    this
                },
                timeline: function() {
                    return this._KityAnimateQueue[0].t
                },
                stop: function() {
                    var queue = this._KityAnimateQueue;
                    if (queue)
                        for (; queue.length; )
                            queue.shift().t.stop();
                    return this
                }
            }),
            Animator
        }
    },
    _p[1] = {
        value: function(require, exports, module) {
            var easings = {
                linear: function(t, b, c, d) {
                    return c * (t / d) + b
                },
                swing: function(t, b, c, d) {
                    return easings.easeOutQuad(t, b, c, d)
                },
                ease: function(t, b, c, d) {
                    return easings.easeInOutCubic(t, b, c, d)
                },
                easeInQuad: function(t, b, c, d) {
                    return c * (t /= d) * t + b
                },
                easeOutQuad: function(t, b, c, d) {
                    return -c * (t /= d) * (t - 2) + b
                },
                easeInOutQuad: function(t, b, c, d) {
                    return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b
                },
                easeInCubic: function(t, b, c, d) {
                    return c * (t /= d) * t * t + b
                },
                easeOutCubic: function(t, b, c, d) {
                    return c * ((t = t / d - 1) * t * t + 1) + b
                },
                easeInOutCubic: function(t, b, c, d) {
                    return (t /= d / 2) < 1 ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b
                },
                easeInQuart: function(t, b, c, d) {
                    return c * (t /= d) * t * t * t + b
                },
                easeOutQuart: function(t, b, c, d) {
                    return -c * ((t = t / d - 1) * t * t * t - 1) + b
                },
                easeInOutQuart: function(t, b, c, d) {
                    return (t /= d / 2) < 1 ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b
                },
                easeInQuint: function(t, b, c, d) {
                    return c * (t /= d) * t * t * t * t + b
                },
                easeOutQuint: function(t, b, c, d) {
                    return c * ((t = t / d - 1) * t * t * t * t + 1) + b
                },
                easeInOutQuint: function(t, b, c, d) {
                    return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b
                },
                easeInSine: function(t, b, c, d) {
                    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b
                },
                easeOutSine: function(t, b, c, d) {
                    return c * Math.sin(t / d * (Math.PI / 2)) + b
                },
                easeInOutSine: function(t, b, c, d) {
                    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b
                },
                easeInExpo: function(t, b, c, d) {
                    return 0 === t ? b : c * Math.pow(2, 10 * (t / d - 1)) + b
                },
                easeOutExpo: function(t, b, c, d) {
                    return t == d ? b + c : c * (1 - Math.pow(2, -10 * t / d)) + b
                },
                easeInOutExpo: function(t, b, c, d) {
                    return 0 === t ? b : t == d ? b + c : (t /= d / 2) < 1 ? c / 2 * Math.pow(2, 10 * (t - 1)) + b : c / 2 * (2 - Math.pow(2, -10 * --t)) + b
                },
                easeInCirc: function(t, b, c, d) {
                    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b
                },
                easeOutCirc: function(t, b, c, d) {
                    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b
                },
                easeInOutCirc: function(t, b, c, d) {
                    return (t /= d / 2) < 1 ? -c / 2 * (Math.sqrt(1 - t * t) - 1) + b : c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b
                },
                easeInElastic: function(t, b, c, d) {
                    var s = 1.70158
                      , p = 0
                      , a = c;
                    return 0 === t ? b : 1 == (t /= d) ? b + c : (p || (p = .3 * d),
                    a < Math.abs(c) ? (a = c,
                    s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a),
                    -a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) + b)
                },
                easeOutElastic: function(t, b, c, d) {
                    var s = 1.70158
                      , p = 0
                      , a = c;
                    return 0 === t ? b : 1 == (t /= d) ? b + c : (p || (p = .3 * d),
                    a < Math.abs(c) ? (a = c,
                    s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a),
                    a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b)
                },
                easeInOutElastic: function(t, b, c, d) {
                    var s = 1.70158
                      , p = 0
                      , a = c;
                    if (0 === t)
                        return b;
                    if (2 == (t /= d / 2))
                        return b + c;
                    if (p || (p = d * (.3 * 1.5)),
                    a < Math.abs(c)) {
                        a = c;
                        var s = p / 4
                    } else
                        var s = p / (2 * Math.PI) * Math.asin(c / a);
                    return t < 1 ? a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * -.5 + b : a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b
                },
                easeInBack: function(t, b, c, d, s) {
                    return void 0 == s && (s = 1.70158),
                    c * (t /= d) * t * ((s + 1) * t - s) + b
                },
                easeOutBack: function(t, b, c, d, s) {
                    return void 0 == s && (s = 1.70158),
                    c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b
                },
                easeInOutBack: function(t, b, c, d, s) {
                    return void 0 == s && (s = 1.70158),
                    (t /= d / 2) < 1 ? c / 2 * (t * t * ((1 + (s *= 1.525)) * t - s)) + b : c / 2 * ((t -= 2) * t * ((1 + (s *= 1.525)) * t + s) + 2) + b
                },
                easeInBounce: function(t, b, c, d) {
                    return c - easings.easeOutBounce(d - t, 0, c, d) + b
                },
                easeOutBounce: function(t, b, c, d) {
                    return (t /= d) < 1 / 2.75 ? c * (7.5625 * t * t) + b : t < 2 / 2.75 ? c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b : t < 2.5 / 2.75 ? c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b : c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b
                },
                easeInOutBounce: function(t, b, c, d) {
                    return t < d / 2 ? .5 * easings.easeInBounce(2 * t, 0, c, d) + b : .5 * easings.easeOutBounce(2 * t - d, 0, c, d) + .5 * c + b
                }
            };
            return easings
        }
    },
    _p[2] = {
        value: function(require, exports) {
            function pushFrame(frame) {
                1 === pendingFrames.push(frame) && (frameRequestId = requestAnimationFrame(executePendingFrames))
            }
            function executePendingFrames() {
                var frames = pendingFrames;
                for (pendingFrames = []; frames.length; )
                    executeFrame(frames.pop());
                frameRequestId = 0
            }
            function requestFrame(action) {
                var frame = initFrame(action);
                return pushFrame(frame),
                frame
            }
            function releaseFrame(frame) {
                var index = pendingFrames.indexOf(frame);
                ~index && pendingFrames.splice(index, 1),
                0 === pendingFrames.length && cancelAnimationFrame(frameRequestId)
            }
            function initFrame(action) {
                var frame = {
                    index: 0,
                    time: +new Date,
                    elapsed: 0,
                    action: action,
                    next: function() {
                        pushFrame(frame)
                    }
                };
                return frame
            }
            function executeFrame(frame) {
                var time = +new Date
                  , dur = time - frame.time;
                dur > 200 && (dur = 1e3 / 60),
                frame.dur = dur,
                frame.elapsed += dur,
                frame.time = time,
                frame.action.call(null, frame),
                frame.index++
            }
            var frameRequestId, requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(fn) {
                return setTimeout(fn, 1e3 / 60)
            }
            , cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.clearTimeout, pendingFrames = [];
            exports.requestFrame = requestFrame,
            exports.releaseFrame = releaseFrame
        }
    },
    _p[3] = {
        value: function(require) {
            var Animator = _p.r(0)
              , g = _p.r(34)
              , Path = _p.r(46)
              , Shape = _p.r(60)
              , MotionAnimator = _p.r(11).createClass("MotionAnimator", {
                base: Animator,
                constructor: function(path, doRotate) {
                    var me = this;
                    this.callBase({
                        beginValue: 0,
                        finishValue: 1,
                        setter: function(target, value) {
                            var path = me.motionPath instanceof Path ? me.motionPath.getPathData() : me.motionPath
                              , point = g.pointAtPath(path, value);
                            target.setTranslate(point.x, point.y),
                            this.doRotate && target.setRotate(point.tan.getAngle())
                        }
                    }),
                    this.doRotate = doRotate,
                    this.motionPath = path
                }
            });
            return _p.r(11).extendClass(Shape, {
                motion: function(path, duration, easing, delay, callback) {
                    return this.animate(new MotionAnimator(path), duration, easing, delay, callback)
                }
            }),
            MotionAnimator
        }
    },
    _p[4] = {
        value: function(require) {
            var Animator = _p.r(0)
              , OpacityAnimator = _p.r(11).createClass("OpacityAnimator", {
                base: Animator,
                constructor: function(opacity) {
                    this.callBase({
                        beginValue: function(target) {
                            return target.getOpacity()
                        },
                        finishValue: opacity,
                        setter: function(target, value) {
                            target.setOpacity(value)
                        }
                    })
                }
            })
              , Shape = _p.r(60);
            return _p.r(11).extendClass(Shape, {
                fxOpacity: function(opacity, duration, easing, delay, callback) {
                    return this.animate(new OpacityAnimator(opacity), duration, easing, delay, callback)
                },
                fadeTo: function() {
                    return this.fxOpacity.apply(this, arguments)
                },
                fadeIn: function() {
                    return this.fxOpacity.apply(this, [1].concat([].slice.call(arguments)))
                },
                fadeOut: function() {
                    return this.fxOpacity.apply(this, [0].concat([].slice.call(arguments)))
                }
            }),
            OpacityAnimator
        }
    },
    _p[5] = {
        value: function(require) {
            var Animator = _p.r(0)
              , g = _p.r(34)
              , PathAnimator = _p.r(11).createClass("OpacityAnimator", {
                base: Animator,
                constructor: function(path) {
                    this.callBase({
                        beginValue: function(target) {
                            return this.beginPath = target.getPathData(),
                            0
                        },
                        finishValue: 1,
                        setter: function(target, value) {
                            target.setPathData(g.pathTween(this.beginPath, path, value))
                        }
                    })
                }
            })
              , Path = _p.r(46);
            return _p.r(11).extendClass(Path, {
                fxPath: function(path, duration, easing, delay, callback) {
                    return this.animate(new PathAnimator(path), duration, easing, delay, callback)
                }
            }),
            PathAnimator
        }
    },
    _p[6] = {
        value: function(require) {
            var Animator = _p.r(0)
              , RotateAnimator = _p.r(11).createClass("RotateAnimator", {
                base: Animator,
                constructor: function(deg) {
                    this.callBase({
                        beginValue: 0,
                        finishValue: deg,
                        setter: function(target, value, timeline) {
                            var delta = timeline.getDelta();
                            target.rotate(delta, ax, ay)
                        }
                    })
                }
            })
              , Shape = _p.r(60);
            return _p.r(11).extendClass(Shape, {
                fxRotate: function(deg, duration, easing, delay, callback) {
                    return this.animate(new RotateAnimator(deg), duration, easing, delay, callback)
                }
            }),
            RotateAnimator
        }
    },
    _p[7] = {
        value: function(require) {
            var Animator = _p.r(0)
              , ScaleAnimator = _p.r(11).createClass("ScaleAnimator", {
                base: Animator,
                constructor: function(sx, sy) {
                    this.callBase({
                        beginValue: 0,
                        finishValue: 1,
                        setter: function(target, value, timeline) {
                            var delta = timeline.getDelta()
                              , kx = Math.pow(sx, delta)
                              , ky = Math.pow(sy, delta);
                            target.scale(ky, kx)
                        }
                    })
                }
            })
              , Shape = _p.r(60);
            return _p.r(11).extendClass(Shape, {
                fxScale: function(sx, sy, duration, easing, delay, callback) {
                    return this.animate(new ScaleAnimator(sx,sy), duration, easing, delay, callback)
                }
            }),
            ScaleAnimator
        }
    },
    _p[8] = {
        value: function(require) {
            function getPercentValue(b, f, p) {
                return utils.paralle(b, f, function(b, f) {
                    return b + (f - b) * p
                })
            }
            function getDelta(v1, v2) {
                return utils.paralle(v1, v2, function(v1, v2) {
                    return v2 - v1
                })
            }
            function TimelineEvent(timeline, type, param) {
                this.timeline = timeline,
                this.target = timeline.target,
                this.type = type;
                for (var name in param)
                    param.hasOwnProperty(name) && (this[name] = param[name])
            }
            var EventHandler = _p.r(33)
              , utils = _p.r(12)
              , frame = _p.r(2)
              , Timeline = _p.r(11).createClass("Timeline", {
                mixins: [EventHandler],
                constructor: function(animator, target, duration, easing) {
                    this.callMixin(),
                    this.target = target,
                    this.time = 0,
                    this.duration = duration,
                    this.easing = easing,
                    this.animator = animator,
                    this.beginValue = animator.beginValue,
                    this.finishValue = animator.finishValue,
                    this.setter = animator.setter,
                    this.status = "ready"
                },
                nextFrame: function(frame) {
                    "playing" == this.status && (this.time += frame.dur,
                    this.setValue(this.getValue()),
                    this.time >= this.duration && this.timeUp(),
                    frame.next())
                },
                getPlayTime: function() {
                    return this.rollbacking ? this.duration - this.time : this.time
                },
                getTimeProportion: function() {
                    return this.getPlayTime() / this.duration
                },
                getValueProportion: function() {
                    return this.easing(this.getPlayTime(), 0, 1, this.duration)
                },
                getValue: function() {
                    return getPercentValue(this.beginValue, this.finishValue, this.getValueProportion())
                },
                setValue: function(value) {
                    this.lastValue = this.currentValue,
                    this.currentValue = value,
                    this.setter.call(this.target, this.target, value, this)
                },
                getDelta: function() {
                    return this.lastValue = void 0 === this.lastValue ? this.beginValue : this.lastValue,
                    getDelta(this.lastValue, this.currentValue)
                },
                play: function() {
                    var lastStatus = this.status;
                    switch (this.status = "playing",
                    lastStatus) {
                    case "ready":
                        utils.isFunction(this.beginValue) && (this.beginValue = this.beginValue.call(this.target, this.target)),
                        utils.isFunction(this.finishValue) && (this.finishValue = this.finishValue.call(this.target, this.target)),
                        this.time = 0,
                        this.setValue(this.beginValue),
                        this.frame = frame.requestFrame(this.nextFrame.bind(this));
                        break;
                    case "finished":
                    case "stoped":
                        this.time = 0,
                        this.frame = frame.requestFrame(this.nextFrame.bind(this));
                        break;
                    case "paused":
                        this.frame.next()
                    }
                    return this.fire("play", new TimelineEvent(this,"play",{
                        lastStatus: lastStatus
                    })),
                    this
                },
                pause: function() {
                    return this.status = "paused",
                    this.fire("pause", new TimelineEvent(this,"pause")),
                    frame.releaseFrame(this.frame),
                    this
                },
                stop: function() {
                    return this.status = "stoped",
                    this.setValue(this.finishValue),
                    this.rollbacking = !1,
                    this.fire("stop", new TimelineEvent(this,"stop")),
                    frame.releaseFrame(this.frame),
                    this
                },
                timeUp: function() {
                    this.repeatOption ? (this.time = 0,
                    this.rollback ? this.rollbacking ? (this.decreaseRepeat(),
                    this.rollbacking = !1) : (this.rollbacking = !0,
                    this.fire("rollback", new TimelineEvent(this,"rollback"))) : this.decreaseRepeat(),
                    this.repeatOption ? this.fire("repeat", new TimelineEvent(this,"repeat")) : this.finish()) : this.finish()
                },
                finish: function() {
                    this.setValue(this.finishValue),
                    this.status = "finished",
                    this.fire("finish", new TimelineEvent(this,"finish")),
                    frame.releaseFrame(this.frame)
                },
                decreaseRepeat: function() {
                    !0 !== this.repeatOption && this.repeatOption--
                },
                repeat: function(repeat, rollback) {
                    return this.repeatOption = repeat,
                    this.rollback = rollback,
                    this
                }
            });
            return Timeline.requestFrame = frame.requestFrame,
            Timeline.releaseFrame = frame.releaseFrame,
            Timeline
        }
    },
    _p[9] = {
        value: function(require) {
            var Animator = _p.r(0)
              , TranslateAnimator = _p.r(11).createClass("TranslateAnimator", {
                base: Animator,
                constructor: function(x, y) {
                    this.callBase({
                        x: 0,
                        y: 0
                    }, {
                        x: x,
                        y: y
                    }, function(target, value, timeline) {
                        var delta = timeline.getDelta();
                        target.translate(delta.x, delta.y)
                    })
                }
            })
              , Shape = _p.r(60);
            return _p.r(11).extendClass(Shape, {
                fxTranslate: function(x, y, duration, easing, delay, callback) {
                    return this.animate(new TranslateAnimator(x,y), duration, easing, delay, callback)
                }
            }),
            TranslateAnimator
        }
    },
    _p[10] = {
        value: function() {
            return function() {
                var browser, agent = navigator.userAgent.toLowerCase(), opera = window.opera;
                browser = {
                    platform: function(navigator) {
                        return {
                            win32: "Win",
                            macintel: "Mac"
                        }[navigator.platform.toLowerCase()] || "Lux"
                    }(navigator),
                    lb: function(agent) {
                        return !!~agent.indexOf("lbbrowser") && (~agent.indexOf("msie") ? "ie" : "chrome")
                    }(agent),
                    sg: /se[\s\S]+metasr/.test(agent),
                    bd: !!~agent.indexOf("bidubrowser"),
                    edge: !!~agent.indexOf("edge"),
                    chrome: !1,
                    opera: !!opera && opera.version,
                    webkit: agent.indexOf(" applewebkit/") > -1,
                    mac: agent.indexOf("macintosh") > -1
                },
                browser.ie = !browser.lb && /(msie\s|trident.*rv:)([\w.]+)/.test(agent),
                browser.gecko = "Gecko" == navigator.product && !browser.webkit && !browser.opera && !browser.ie;
                var version = 0;
                if (browser.ie && (version = 1 * (agent.match(/(msie\s|trident.*rv:)([\w.]+)/)[2] || 0),
                browser.ie11Compat = 11 == document.documentMode,
                browser.ie9Compat = 9 == document.documentMode),
                browser.gecko) {
                    var geckoRelease = agent.match(/rv:([\d\.]+)/);
                    geckoRelease && (geckoRelease = geckoRelease[1].split("."),
                    version = 1e4 * geckoRelease[0] + 100 * (geckoRelease[1] || 0) + 1 * (geckoRelease[2] || 0))
                }
                return !/chrome\/(\d+\.\d)/i.test(agent) || browser.bd || browser.opera || browser.lb || browser.sg || browser.edge || (browser.chrome = +RegExp.$1),
                /(\d+\.\d)?(?:\.\d)?\s+safari\/?(\d+\.\d+)?/i.test(agent) && !/chrome/i.test(agent) && (browser.safari = +(RegExp.$1 || RegExp.$2)),
                browser.opera && (version = parseFloat(opera.version())),
                browser.webkit && (version = parseFloat(agent.match(/ applewebkit\/(\d+)/)[1])),
                browser.bd && (version = parseFloat(agent.match(/bidubrowser\/(\d+)/)[1])),
                browser.opera && (version = parseFloat(agent.match(/opr\/(\d+)/)[1])),
                browser.edge && (version = parseFloat(agent.match(/edge\/(\d+)/)[1])),
                browser.version = version,
                browser.isCompatible = !browser.mobile && (browser.ie && version >= 6 || browser.gecko && version >= 10801 || browser.opera && version >= 9.5 || browser.air && version >= 1 || browser.webkit && version >= 522 || !1),
                browser
            }()
        }
    },
    _p[11] = {
        value: function(require, exports) {
            function Class() {}
            function checkBaseConstructorCall(targetClass, classname) {
                if (!/this\.callBase/.test(targetClass.toString()))
                    throw new Error(classname + " : 类构造函数没有调用父类的构造函数！为了安全，请调用父类的构造函数")
            }
            function inherit(constructor, BaseClass, classname) {
                var KityClass = eval("(function " + classname + "( __inherit__flag ) {if( __inherit__flag != KITY_INHERIT_FLAG ) {KityClass.__KityConstructor.apply(this, arguments);}this.__KityClassName = KityClass.__KityClassName;})");
                KityClass.__KityConstructor = constructor,
                KityClass.prototype = new BaseClass(KITY_INHERIT_FLAG);
                for (var methodName in BaseClass.prototype)
                    BaseClass.prototype.hasOwnProperty(methodName) && 0 !== methodName.indexOf("__Kity") && (KityClass.prototype[methodName] = BaseClass.prototype[methodName]);
                return KityClass.prototype.constructor = KityClass,
                KityClass
            }
            function mixin(NewClass, mixins) {
                if (!1 == mixins instanceof Array)
                    return NewClass;
                var i, proto, method, length = mixins.length;
                for (NewClass.__KityMixins = {
                    constructor: []
                },
                i = 0; i < length; i++) {
                    proto = mixins[i].prototype;
                    for (method in proto)
                        !1 !== proto.hasOwnProperty(method) && 0 !== method.indexOf("__Kity") && ("constructor" === method ? NewClass.__KityMixins.constructor.push(proto[method]) : NewClass.prototype[method] = NewClass.__KityMixins[method] = proto[method])
                }
                return NewClass
            }
            function extend(BaseClass, extension) {
                extension.__KityClassName && (extension = extension.prototype);
                for (var methodName in extension)
                    if (extension.hasOwnProperty(methodName) && methodName.indexOf("__Kity") && "constructor" != methodName) {
                        var method = BaseClass.prototype[methodName] = extension[methodName];
                        method.__KityMethodClass = BaseClass,
                        method.__KityMethodName = methodName
                    }
                return BaseClass
            }
            exports.Class = Class,
            Class.__KityClassName = "Class",
            Class.prototype.base = function(name) {
                return arguments.callee.caller.__KityMethodClass.__KityBaseClass.prototype[name].apply(this, Array.prototype.slice.call(arguments, 1))
            }
            ,
            Class.prototype.callBase = function() {
                var caller = arguments.callee.caller;
                return caller.__KityMethodClass.__KityBaseClass.prototype[caller.__KityMethodName].apply(this, arguments)
            }
            ,
            Class.prototype.mixin = function(name) {
                var caller = arguments.callee.caller
                  , mixins = caller.__KityMethodClass.__KityMixins;
                return mixins ? mixins[name].apply(this, Array.prototype.slice.call(arguments, 1)) : this
            }
            ,
            Class.prototype.callMixin = function() {
                var caller = arguments.callee.caller
                  , methodName = caller.__KityMethodName
                  , mixins = caller.__KityMethodClass.__KityMixins;
                if (!mixins)
                    return this;
                var method = mixins[methodName];
                if ("constructor" == methodName) {
                    for (var i = 0, l = method.length; i < l; i++)
                        method[i].call(this);
                    return this
                }
                return method.apply(this, arguments)
            }
            ,
            Class.prototype.pipe = function(fn) {
                return "function" == typeof fn && fn.call(this, this),
                this
            }
            ,
            Class.prototype.getType = function() {
                return this.__KityClassName
            }
            ,
            Class.prototype.getClass = function() {
                return this.constructor
            }
            ;
            var KITY_INHERIT_FLAG = "__KITY_INHERIT_FLAG_" + +new Date;
            exports.createClass = function(classname, defines) {
                var constructor, NewClass, BaseClass;
                return 1 === arguments.length && (defines = arguments[0],
                classname = "AnonymousClass"),
                BaseClass = defines.base || Class,
                defines.hasOwnProperty("constructor") ? (constructor = defines.constructor,
                BaseClass != Class && checkBaseConstructorCall(constructor, classname)) : constructor = function() {
                    this.callBase.apply(this, arguments),
                    this.callMixin.apply(this, arguments)
                }
                ,
                NewClass = inherit(constructor, BaseClass, classname),
                NewClass = mixin(NewClass, defines.mixins),
                NewClass.__KityClassName = constructor.__KityClassName = classname,
                NewClass.__KityBaseClass = constructor.__KityBaseClass = BaseClass,
                NewClass.__KityMethodName = constructor.__KityMethodName = "constructor",
                NewClass.__KityMethodClass = constructor.__KityMethodClass = NewClass,
                delete defines.mixins,
                delete defines.constructor,
                delete defines.base,
                NewClass = extend(NewClass, defines)
            }
            ,
            exports.extendClass = extend
        }
    },
    _p[12] = {
        value: function() {
            var utils = {
                each: function(obj, iterator, context) {
                    if (null !== obj)
                        if (obj.length === +obj.length) {
                            for (var i = 0, l = obj.length; i < l; i++)
                                if (!1 === iterator.call(context, obj[i], i, obj))
                                    return !1
                        } else
                            for (var key in obj)
                                if (obj.hasOwnProperty(key) && !1 === iterator.call(context, obj[key], key, obj))
                                    return !1
                },
                extend: function(t) {
                    for (var a = arguments, notCover = !!this.isBoolean(a[a.length - 1]) && a[a.length - 1], len = this.isBoolean(a[a.length - 1]) ? a.length - 1 : a.length, i = 1; i < len; i++) {
                        var x = a[i];
                        for (var k in x)
                            notCover && t.hasOwnProperty(k) || (t[k] = x[k])
                    }
                    return t
                },
                deepExtend: function(t, s) {
                    for (var a = arguments, notCover = !!this.isBoolean(a[a.length - 1]) && a[a.length - 1], len = this.isBoolean(a[a.length - 1]) ? a.length - 1 : a.length, i = 1; i < len; i++) {
                        var x = a[i];
                        for (var k in x)
                            notCover && t.hasOwnProperty(k) || (this.isObject(t[k]) && this.isObject(x[k]) ? this.deepExtend(t[k], x[k], notCover) : t[k] = x[k])
                    }
                    return t
                },
                clone: function(obj) {
                    var cloned = {};
                    for (var m in obj)
                        obj.hasOwnProperty(m) && (cloned[m] = obj[m]);
                    return cloned
                },
                copy: function(obj) {
                    return "object" != typeof obj ? obj : "function" == typeof obj ? null : JSON.parse(JSON.stringify(obj))
                },
                queryPath: function(path, obj) {
                    for (var arr = path.split("."), i = 0, tmp = obj, l = arr.length; i < l; ) {
                        if (!(arr[i]in tmp))
                            return;
                        if (tmp = tmp[arr[i]],
                        ++i >= l || void 0 === tmp)
                            return tmp
                    }
                },
                getValue: function(value, defaultValue) {
                    return void 0 !== value ? value : defaultValue
                },
                flatten: function(arr) {
                    var i, result = [], length = arr.length;
                    for (i = 0; i < length; i++)
                        arr[i]instanceof Array ? result = result.concat(utils.flatten(arr[i])) : result.push(arr[i]);
                    return result
                },
                paralle: function(v1, v2, op) {
                    var Class, index, name, value;
                    if (v1 instanceof Array) {
                        for (value = [],
                        index = 0; index < v1.length; index++)
                            value.push(utils.paralle(v1[index], v2[index], op));
                        return value
                    }
                    if (v1 instanceof Object) {
                        if ((Class = v1.getClass && v1.getClass()) && Class.parse)
                            v1 = v1.valueOf(),
                            v2 = v2.valueOf(),
                            value = utils.paralle(v1, v2, op),
                            value = Class.parse(value);
                        else {
                            value = {};
                            for (name in v1)
                                v1.hasOwnProperty(name) && v2.hasOwnProperty(name) && (value[name] = utils.paralle(v1[name], v2[name], op))
                        }
                        return value
                    }
                    return !1 === isNaN(parseFloat(v1)) ? op(v1, v2) : value
                },
                parallelize: function(op) {
                    return function(v1, v2) {
                        return utils.paralle(v1, v2, op)
                    }
                }
            };
            return utils.each(["String", "Function", "Array", "Number", "RegExp", "Object", "Boolean"], function(v) {
                utils["is" + v] = function(obj) {
                    return Object.prototype.toString.apply(obj) == "[object " + v + "]"
                }
            }),
            utils
        }
    },
    _p[13] = {
        value: function(require, exports, module) {
            var Effect = _p.r(16)
              , Utils = _p.r(12)
              , ColorMatrixEffect = _p.r(11).createClass("ColorMatrixEffect", {
                base: Effect,
                constructor: function(type, input) {
                    this.callBase(Effect.NAME_COLOR_MATRIX),
                    this.set("type", Utils.getValue(type, ColorMatrixEffect.TYPE_MATRIX)),
                    this.set("in", Utils.getValue(input, Effect.INPUT_SOURCE_GRAPHIC))
                }
            });
            return Utils.extend(ColorMatrixEffect, {
                TYPE_MATRIX: "matrix",
                TYPE_SATURATE: "saturate",
                TYPE_HUE_ROTATE: "hueRotate",
                TYPE_LUMINANCE_TO_ALPHA: "luminanceToAlpha",
                MATRIX_ORIGINAL: "10000010000010000010".split("").join(" "),
                MATRIX_EMPTY: "00000000000000000000".split("").join(" ")
            }),
            ColorMatrixEffect
        }
    },
    _p[14] = {
        value: function(require, exports, module) {
            var Effect = _p.r(16)
              , Utils = _p.r(12)
              , CompositeEffect = _p.r(11).createClass("CompositeEffect", {
                base: Effect,
                constructor: function(operator, input, input2) {
                    this.callBase(Effect.NAME_COMPOSITE),
                    this.set("operator", Utils.getValue(operator, CompositeEffect.OPERATOR_OVER)),
                    input && this.set("in", input),
                    input2 && this.set("in2", input2)
                }
            });
            return Utils.extend(CompositeEffect, {
                OPERATOR_OVER: "over",
                OPERATOR_IN: "in",
                OPERATOR_OUT: "out",
                OPERATOR_ATOP: "atop",
                OPERATOR_XOR: "xor",
                OPERATOR_ARITHMETIC: "arithmetic"
            }),
            CompositeEffect
        }
    },
    _p[15] = {
        value: function(require, exports, module) {
            var Effect = _p.r(16)
              , Utils = _p.r(12)
              , ConvolveMatrixEffect = _p.r(11).createClass("ConvolveMatrixEffect", {
                base: Effect,
                constructor: function(edgeMode, input) {
                    this.callBase(Effect.NAME_CONVOLVE_MATRIX),
                    this.set("edgeMode", Utils.getValue(edgeMode, ConvolveMatrixEffect.MODE_DUPLICATE)),
                    this.set("in", Utils.getValue(input, Effect.INPUT_SOURCE_GRAPHIC))
                }
            });
            return Utils.extend(ConvolveMatrixEffect, {
                MODE_DUPLICATE: "duplicate",
                MODE_WRAP: "wrap",
                MODE_NONE: "none"
            }),
            ConvolveMatrixEffect
        }
    },
    _p[16] = {
        value: function(require, exports, module) {
            var svg = _p.r(67)
              , Effect = _p.r(11).createClass("Effect", {
                constructor: function(type) {
                    this.node = svg.createNode(type)
                },
                getId: function() {
                    return this.node.id
                },
                setId: function(id) {
                    return this.node.id = id,
                    this
                },
                set: function(key, value) {
                    return this.node.setAttribute(key, value),
                    this
                },
                get: function(key) {
                    return this.node.getAttribute(key)
                },
                getNode: function() {
                    return this.node
                },
                toString: function() {
                    return this.node.getAttribute("result") || ""
                }
            });
            return _p.r(12).extend(Effect, {
                NAME_GAUSSIAN_BLUR: "feGaussianBlur",
                NAME_OFFSET: "feOffset",
                NAME_COMPOSITE: "feComposite",
                NAME_COLOR_MATRIX: "feColorMatrix",
                NAME_CONVOLVE_MATRIX: "feConvolveMatrix",
                INPUT_SOURCE_GRAPHIC: "SourceGraphic",
                INPUT_SOURCE_ALPHA: "SourceAlpha",
                INPUT_BACKGROUND_IMAGE: "BackgroundImage",
                INPUT_BACKGROUND_ALPHA: "BackgroundAlpha",
                INPUT_FILL_PAINT: "FillPaint",
                INPUT_STROKE_PAINT: "StrokePaint"
            }),
            Effect
        }
    },
    _p[17] = {
        value: function(require, exports, module) {
            var Effect = _p.r(16)
              , Utils = _p.r(12);
            return _p.r(11).createClass("GaussianblurEffect", {
                base: Effect,
                constructor: function(stdDeviation, input) {
                    this.callBase(Effect.NAME_GAUSSIAN_BLUR),
                    this.set("stdDeviation", Utils.getValue(stdDeviation, 1)),
                    this.set("in", Utils.getValue(input, Effect.INPUT_SOURCE_GRAPHIC))
                }
            })
        }
    },
    _p[18] = {
        value: function(require, exports, module) {
            var Effect = _p.r(16)
              , Utils = _p.r(12);
            return _p.r(11).createClass("OffsetEffect", {
                base: Effect,
                constructor: function(dx, dy, input) {
                    this.callBase(Effect.NAME_OFFSET),
                    this.set("dx", Utils.getValue(dx, 0)),
                    this.set("dy", Utils.getValue(dy, 0)),
                    this.set("in", Utils.getValue(input, Effect.INPUT_SOURCE_GRAPHIC))
                }
            })
        }
    },
    _p[19] = {
        value: function(require) {
            return _p.r(11).createClass("EffectContainer", {
                base: _p.r(29),
                addEffect: function(point, pos) {
                    return this.addItem.apply(this, arguments)
                },
                prependEffect: function() {
                    return this.prependItem.apply(this, arguments)
                },
                appendEffect: function() {
                    return this.appendItem.apply(this, arguments)
                },
                removeEffect: function(pos) {
                    return this.removeItem.apply(this, arguments)
                },
                addEffects: function() {
                    return this.addItems.apply(this, arguments)
                },
                setEffects: function() {
                    return this.setItems.apply(this, arguments)
                },
                getEffect: function() {
                    return this.getItem.apply(this, arguments)
                },
                getEffects: function() {
                    return this.getItems.apply(this, arguments)
                },
                getFirstEffect: function() {
                    return this.getFirstItem.apply(this, arguments)
                },
                getLastEffect: function() {
                    return this.getLastItem.apply(this, arguments)
                },
                handleAdd: function(effectItem, pos) {
                    var count = this.getEffects().length
                      , nextEffectItem = this.getItem(pos + 1);
                    if (count === pos + 1)
                        return void this.node.appendChild(effectItem.getNode());
                    this.node.insertBefore(effectItem.getNode(), nextEffectItem.getNode())
                }
            })
        }
    },
    _p[20] = {
        value: function(require, exports, module) {
            var svg = _p.r(67)
              , Class = _p.r(11)
              , Filter = Class.createClass("Filter", {
                mixins: [_p.r(19)],
                constructor: function(x, y, width, height) {
                    this.node = svg.createNode("filter"),
                    void 0 !== x && this.set("x", x),
                    void 0 !== y && this.set("y", y),
                    void 0 !== width && this.set("width", width),
                    void 0 !== height && this.set("height", height)
                },
                getId: function() {
                    return this.id
                },
                setId: function(id) {
                    return this.node.id = id,
                    this
                },
                set: function(key, value) {
                    return this.node.setAttribute(key, value),
                    this
                },
                get: function(key) {
                    return this.node.getAttribute(key)
                },
                getNode: function() {
                    return this.node
                }
            })
              , Shape = _p.r(60);
            return Class.extendClass(Shape, {
                applyFilter: function(filter) {
                    var filterId = filter.get("id");
                    return filterId && this.node.setAttribute("filter", "url(#" + filterId + ")"),
                    this
                }
            }),
            Filter
        }
    },
    _p[21] = {
        value: function(require, exports, module) {
            var GaussianblurEffect = _p.r(17);
            return _p.r(11).createClass("GaussianblurFilter", {
                base: _p.r(20),
                constructor: function(stdDeviation) {
                    this.callBase(),
                    this.addEffect(new GaussianblurEffect(stdDeviation))
                }
            })
        }
    },
    _p[22] = {
        value: function(require, exports, module) {
            var GaussianblurEffect = _p.r(17)
              , Effect = _p.r(16)
              , ColorMatrixEffect = _p.r(13)
              , Color = _p.r(28)
              , Utils = _p.r(12)
              , CompositeEffect = _p.r(14)
              , OffsetEffect = _p.r(18);
            return _p.r(11).createClass("ProjectionFilter", {
                base: _p.r(20),
                constructor: function(stdDeviation, dx, dy) {
                    this.callBase(),
                    this.gaussianblurEffect = new GaussianblurEffect(stdDeviation,Effect.INPUT_SOURCE_ALPHA),
                    this.gaussianblurEffect.set("result", "gaussianblur"),
                    this.addEffect(this.gaussianblurEffect),
                    this.offsetEffect = new OffsetEffect(dx,dy,this.gaussianblurEffect),
                    this.offsetEffect.set("result", "offsetBlur"),
                    this.addEffect(this.offsetEffect),
                    this.colorMatrixEffect = new ColorMatrixEffect(ColorMatrixEffect.TYPE_MATRIX,this.offsetEffect),
                    this.colorMatrixEffect.set("values", ColorMatrixEffect.MATRIX_ORIGINAL),
                    this.colorMatrixEffect.set("result", "colorOffsetBlur"),
                    this.addEffect(this.colorMatrixEffect),
                    this.compositeEffect = new CompositeEffect(CompositeEffect.OPERATOR_OVER,Effect.INPUT_SOURCE_GRAPHIC,this.colorMatrixEffect),
                    this.addEffect(this.compositeEffect)
                },
                setColor: function(color) {
                    var matrix = null
                      , colorValue = [];
                    if (Utils.isString(color) && (color = Color.parse(color)),
                    !color)
                        return this;
                    matrix = ColorMatrixEffect.MATRIX_EMPTY.split(" "),
                    colorValue.push(color.get("r")),
                    colorValue.push(color.get("g")),
                    colorValue.push(color.get("b"));
                    for (var i = 0, len = colorValue.length; i < len; i++)
                        matrix[5 * i + 3] = colorValue[i] / 255;
                    return matrix[18] = color.get("a"),
                    this.colorMatrixEffect.set("values", matrix.join(" ")),
                    this
                },
                setOpacity: function(opacity) {
                    var matrix = this.colorMatrixEffect.get("values").split(" ");
                    return matrix[18] = opacity,
                    this.colorMatrixEffect.set("values", matrix.join(" ")),
                    this
                },
                setOffset: function(dx, dy) {
                    this.setOffsetX(dx),
                    this.setOffsetY(dy)
                },
                setOffsetX: function(dx) {
                    this.offsetEffect.set("dx", dx)
                },
                setOffsetY: function(dy) {
                    this.offsetEffect.set("dy", dy)
                },
                setDeviation: function(deviation) {
                    this.gaussianblurEffect.set("stdDeviation", deviation)
                }
            })
        }
    },
    _p[23] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("Bezier", {
                mixins: [_p.r(51)],
                base: _p.r(46),
                constructor: function(bezierPoints) {
                    this.callBase(),
                    bezierPoints = bezierPoints || [],
                    this.changeable = !0,
                    this.setBezierPoints(bezierPoints)
                },
                getBezierPoints: function() {
                    return this.getPoints()
                },
                setBezierPoints: function(bezierPoints) {
                    return this.setPoints(bezierPoints)
                },
                onContainerChanged: function() {
                    this.changeable && this.update()
                },
                update: function() {
                    var drawer = null
                      , bezierPoints = this.getBezierPoints();
                    if (!(bezierPoints.length < 2)) {
                        drawer = this.getDrawer(),
                        drawer.clear();
                        var vertex = bezierPoints[0].getVertex()
                          , forward = null
                          , backward = null;
                        drawer.moveTo(vertex.x, vertex.y);
                        for (var i = 1, len = bezierPoints.length; i < len; i++)
                            vertex = bezierPoints[i].getVertex(),
                            backward = bezierPoints[i].getBackward(),
                            forward = bezierPoints[i - 1].getForward(),
                            drawer.bezierTo(forward.x, forward.y, backward.x, backward.y, vertex.x, vertex.y);
                        return this
                    }
                }
            })
        }
    },
    _p[24] = {
        value: function(require, exports, module) {
            var ShapePoint = _p.r(63)
              , Vector = _p.r(73)
              , BezierPoint = _p.r(11).createClass("BezierPoint", {
                constructor: function(x, y, isSmooth) {
                    this.vertex = new ShapePoint(x,y),
                    this.forward = new ShapePoint(x,y),
                    this.backward = new ShapePoint(x,y),
                    this.setSmooth(void 0 === isSmooth || isSmooth),
                    this.setSymReflaction(!0)
                },
                clone: function() {
                    var newPoint = new BezierPoint
                      , tmp = null;
                    return tmp = this.getVertex(),
                    newPoint.setVertex(tmp.x, tmp.y),
                    tmp = this.getForward(),
                    newPoint.setForward(tmp.x, tmp.y),
                    tmp = this.getBackward(),
                    newPoint.setBackward(tmp.x, tmp.y),
                    newPoint.setSymReflaction(this.isSymReflaction),
                    newPoint.setSmooth(this.isSmooth()),
                    newPoint
                },
                setVertex: function(x, y) {
                    return this.vertex.setPoint(x, y),
                    this.update(),
                    this
                },
                moveTo: function(x, y) {
                    var oldForward = this.forward.getPoint()
                      , oldBackward = this.backward.getPoint()
                      , oldVertex = this.vertex.getPoint()
                      , distance = {
                        left: x - oldVertex.x,
                        top: y - oldVertex.y
                    };
                    this.forward.setPoint(oldForward.x + distance.left, oldForward.y + distance.top),
                    this.backward.setPoint(oldBackward.x + distance.left, oldBackward.y + distance.top),
                    this.vertex.setPoint(x, y),
                    this.update()
                },
                setForward: function(x, y) {
                    return this.forward.setPoint(x, y),
                    this.smooth && this.updateAnother(this.forward, this.backward),
                    this.update(),
                    this.lastControlPointSet = this.forward,
                    this
                },
                setBackward: function(x, y) {
                    return this.backward.setPoint(x, y),
                    this.smooth && this.updateAnother(this.backward, this.forward),
                    this.update(),
                    this.lastControlPointSet = this.backward,
                    this
                },
                setSymReflaction: function(value) {
                    return this.symReflaction = value,
                    this.smooth && this.setSmooth(!0),
                    this
                },
                isSymReflaction: function() {
                    return this.symReflaction
                },
                updateAnother: function(p, q) {
                    var v = this.getVertex()
                      , pv = Vector.fromPoints(p.getPoint(), v)
                      , vq = Vector.fromPoints(v, q.getPoint());
                    return vq = pv.normalize(this.isSymReflaction() ? pv.length() : vq.length()),
                    q.setPoint(v.x + vq.x, v.y + vq.y),
                    this
                },
                setSmooth: function(isSmooth) {
                    var lc;
                    return this.smooth = !!isSmooth,
                    this.smooth && (lc = this.lastControlPointSet) && this.updateAnother(lc, lc == this.forward ? this.backward : this.forward),
                    this
                },
                isSmooth: function() {
                    return this.smooth
                },
                getVertex: function() {
                    return this.vertex.getPoint()
                },
                getForward: function() {
                    return this.forward.getPoint()
                },
                getBackward: function() {
                    return this.backward.getPoint()
                },
                update: function() {
                    if (!this.container)
                        return this;
                    this.container.update && this.container.update(this)
                }
            });
            return BezierPoint
        }
    },
    _p[25] = {
        value: function(require, exports, module) {
            var Box = _p.r(11).createClass("Box", {
                constructor: function(x, y, width, height) {
                    var box = arguments[0];
                    box && "object" == typeof box && (x = box.x,
                    y = box.y,
                    width = box.width,
                    height = box.height),
                    width < 0 && (x -= width = -width),
                    height < 0 && (y -= height = -height),
                    this.x = x || 0,
                    this.y = y || 0,
                    this.width = width || 0,
                    this.height = height || 0,
                    this.left = this.x,
                    this.right = this.x + this.width,
                    this.top = this.y,
                    this.bottom = this.y + this.height,
                    this.cx = this.x + this.width / 2,
                    this.cy = this.y + this.height / 2
                },
                getRangeX: function() {
                    return [this.left, this.right]
                },
                getRangeY: function() {
                    return [this.top, this.bottom]
                },
                merge: function(another) {
                    if (this.isEmpty())
                        return new Box(another.x,another.y,another.width,another.height);
                    var left = Math.min(this.left, another.left)
                      , right = Math.max(this.right, another.right)
                      , top = Math.min(this.top, another.top)
                      , bottom = Math.max(this.bottom, another.bottom);
                    return new Box(left,top,right - left,bottom - top)
                },
                intersect: function(another) {
                    !another instanceof Box && (another = new Box(another));
                    var left = Math.max(this.left, another.left)
                      , right = Math.min(this.right, another.right)
                      , top = Math.max(this.top, another.top)
                      , bottom = Math.min(this.bottom, another.bottom);
                    return left > right || top > bottom ? new Box : new Box(left,top,right - left,bottom - top)
                },
                expand: function(top, right, bottom, left) {
                    if (arguments.length < 1)
                        return new Box(this);
                    arguments.length < 2 && (right = top),
                    arguments.length,
                    arguments.length < 4 && (left = right);
                    var x = this.left - left
                      , y = this.top - top
                      , width = this.width + right
                      , height = this.height + top;
                    return new Box(x,y,width,height)
                },
                valueOf: function() {
                    return [this.x, this.y, this.width, this.height]
                },
                toString: function() {
                    return this.valueOf().join(" ")
                },
                isEmpty: function() {
                    return !this.width || !this.height
                }
            });
            return Box.parse = function(any) {
                return "string" == typeof any ? Box.parse(any.split(/[\s,]+/).map(parseFloat)) : any instanceof Array ? new Box(any[0],any[1],any[2],any[3]) : "x"in any ? new Box(any) : null
            }
            ,
            Box
        }
    },
    _p[26] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("Circle", {
                base: _p.r(32),
                constructor: function(radius, cx, cy) {
                    this.callBase(radius, radius, cx, cy)
                },
                getRadius: function() {
                    return this.getRadiusX()
                },
                setRadius: function(radius) {
                    return this.callBase(radius, radius)
                }
            })
        }
    },
    _p[27] = {
        value: function(require, exports, module) {
            var Class = _p.r(11)
              , Shape = _p.r(60)
              , Clip = Class.createClass("Clip", {
                base: Shape,
                mixins: [_p.r(61)],
                constructor: function(paper) {
                    this.callBase("clipPath", paper)
                },
                clip: function(shape) {
                    return shape.getNode().setAttribute("clip-path", this),
                    this
                }
            });
            return Class.extendClass(Shape, {
                clipWith: function(clip) {
                    return clip instanceof Shape && (clip = new Clip(clip.getPaper()).addShape(clip)),
                    clip.clip(this),
                    this
                }
            }),
            Clip
        }
    },
    _p[28] = {
        value: function(require, exports, module) {
            var Utils = _p.r(12)
              , StandardColor = _p.r(64)
              , ColorUtils = {}
              , Color = _p.r(11).createClass("Color", {
                constructor: function() {
                    var colorValue = null;
                    "string" == typeof arguments[0] ? null === (colorValue = ColorUtils.parseToValue(arguments[0])) && (colorValue = {
                        r: 0,
                        g: 0,
                        b: 0,
                        h: 0,
                        s: 0,
                        l: 0,
                        a: 1
                    }) : (colorValue = {
                        r: 0 | arguments[0],
                        g: 0 | arguments[1],
                        b: 0 | arguments[2],
                        a: void 0 === arguments[3] ? 1 : parseFloat(arguments[3])
                    },
                    colorValue = ColorUtils.overflowFormat(colorValue),
                    colorValue = Utils.extend(colorValue, ColorUtils.rgbValueToHslValue(colorValue))),
                    this._color = colorValue
                },
                set: function(name, value) {
                    if (!Color._MAX_VALUE[name])
                        throw new Error("Color set(): Illegal parameter");
                    return "a" !== name && (value = Math.floor(value)),
                    "h" == name && (value = (value + 360) % 360),
                    this._color[name] = Math.max(Color._MIN_VALUE[name], Math.min(Color._MAX_VALUE[name], value)),
                    -1 !== "rgb".indexOf(name) ? this._color = Utils.extend(this._color, ColorUtils.rgbValueToHslValue(this._color)) : -1 !== "hsl".indexOf(name) && (this._color = Utils.extend(this._color, ColorUtils.hslValueToRGBValue(this._color))),
                    this
                },
                inc: function(name, value) {
                    return value = this.get(name) + value,
                    "h" == name ? value = (value + 360) % 360 : (value = Math.min(Color._MAX_VALUE[name], value),
                    value = Math.max(Color._MIN_VALUE[name], value)),
                    this.clone().set(name, value)
                },
                dec: function(name, value) {
                    return this.inc(name, -value)
                },
                clone: function() {
                    return new Color(this.toRGBA())
                },
                get: function(name) {
                    return Color._MAX_VALUE[name] ? this._color[name] : null
                },
                getValues: function() {
                    return Utils.clone(this._color)
                },
                valueOf: function() {
                    return this.getValues()
                },
                toRGB: function() {
                    return ColorUtils.toString(this._color, "rgb")
                },
                toRGBA: function() {
                    return ColorUtils.toString(this._color, "rgba")
                },
                toHEX: function() {
                    return ColorUtils.toString(this._color, "hex")
                },
                toHSL: function() {
                    return ColorUtils.toString(this._color, "hsl")
                },
                toHSLA: function() {
                    return ColorUtils.toString(this._color, "hsla")
                },
                toString: function() {
                    return 1 === this._color.a ? this.toRGB() : this.toRGBA()
                }
            });
            return Utils.extend(Color, {
                _MAX_VALUE: {
                    r: 255,
                    g: 255,
                    b: 255,
                    h: 360,
                    s: 100,
                    l: 100,
                    a: 1
                },
                _MIN_VALUE: {
                    r: 0,
                    g: 0,
                    b: 0,
                    h: 0,
                    s: 0,
                    l: 0,
                    a: 0
                },
                R: "r",
                G: "g",
                B: "b",
                H: "h",
                S: "s",
                L: "l",
                A: "a",
                parse: function(valStr) {
                    var rgbValue;
                    return Utils.isString(valStr) && (rgbValue = ColorUtils.parseToValue(valStr)),
                    Utils.isObject(valStr) && "r"in valStr && (rgbValue = valStr),
                    null === rgbValue ? new Color : new Color(rgbValue.r,rgbValue.g,rgbValue.b,rgbValue.a)
                },
                createHSL: function(h, s, l) {
                    return Color.createHSLA(h, s, l, 1)
                },
                createHSLA: function(h, s, l, a) {
                    var colorValue = null;
                    return s += "%",
                    l += "%",
                    colorValue = ["hsla(" + h, s, l, a + ")"],
                    Color.parse(colorValue.join(", "))
                },
                createRGB: function(r, g, b) {
                    return Color.createRGBA(r, g, b, 1)
                },
                createRGBA: function(r, g, b, a) {
                    return new Color(r,g,b,a)
                }
            }),
            Utils.extend(ColorUtils, {
                parseToValue: function(valStr) {
                    var rgbaValue = {};
                    if (valStr = StandardColor.EXTEND_STANDARD[valStr] || StandardColor.COLOR_STANDARD[valStr] || valStr,
                    /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(valStr))
                        rgbaValue = ColorUtils.hexToValue(valStr);
                    else if (/^(rgba?)/i.test(valStr))
                        rgbaValue = ColorUtils.rgbaToValue(valStr);
                    else {
                        if (!/^(hsla?)/i.test(valStr))
                            return null;
                        rgbaValue = ColorUtils.hslaToValue(valStr)
                    }
                    return ColorUtils.overflowFormat(rgbaValue)
                },
                hexToValue: function(hexStr) {
                    var result = {}
                      , keys = ["r", "g", "b"];
                    return /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(hexStr) ? (hexStr = RegExp.$1.split(""),
                    Utils.each(keys, function(key, index) {
                        3 === hexStr.length ? result[key] = ColorUtils.toNumber(hexStr[index] + hexStr[index]) : result[key] = ColorUtils.toNumber(hexStr[2 * index] + hexStr[2 * index + 1])
                    }),
                    result = Utils.extend(result, ColorUtils.rgbValueToHslValue(result)),
                    result.a = 1,
                    result) : null
                },
                rgbaToValue: function(rgbaStr) {
                    var result = {}
                      , hasAlpha = !1
                      , keys = ["r", "g", "b"];
                    return /^(rgba?)/i.test(rgbaStr) ? (hasAlpha = 4 === RegExp.$1.length,
                    rgbaStr = rgbaStr.replace(/^rgba?/i, "").replace(/\s+/g, "").replace(/[^0-9,.]/g, "").split(","),
                    Utils.each(keys, function(key, index) {
                        result[key] = 0 | rgbaStr[index]
                    }),
                    result = Utils.extend(result, ColorUtils.rgbValueToHslValue(result)),
                    result.a = hasAlpha ? parseFloat(rgbaStr[3]) : 1,
                    result) : null
                },
                hslaToValue: function(hslaStr) {
                    var result = {}
                      , hasAlpha = !1;
                    return /^(hsla?)/i.test(hslaStr) ? (hasAlpha = 4 === RegExp.$1.length,
                    hslaStr = hslaStr.replace(/^hsla?/i, "").replace(/\s+/g, "").replace(/[^0-9,.]/g, "").split(","),
                    result.h = 0 | hslaStr[0],
                    result.s = 0 | hslaStr[1],
                    result.l = 0 | hslaStr[2],
                    result = Utils.extend(result, ColorUtils.hslValueToRGBValue(result)),
                    result = ColorUtils.hslValueToRGBValue(result),
                    result.a = hasAlpha ? parseFloat(hslaStr[3]) : 1,
                    result) : null
                },
                hslValueToRGBValue: function(hslValue) {
                    function trans(v1, v2, vH) {
                        return vH < 0 ? vH += 1 : vH > 1 && (vH -= 1),
                        6 * vH < 1 ? v1 + 6 * (v2 - v1) * vH : 2 * vH < 1 ? v2 : 3 * vH < 2 ? v1 + 6 * (2 / 3 - vH) * (v2 - v1) : v1
                    }
                    var q = null
                      , p = null
                      , result = {};
                    return hslValue = Utils.extend({}, hslValue),
                    hslValue.h = hslValue.h / 360,
                    hslValue.s = hslValue.s / 100,
                    hslValue.l = hslValue.l / 100,
                    0 === hslValue.s ? result.r = result.g = result.b = hslValue.l : (q = hslValue.l < .5 ? hslValue.l * (1 + hslValue.s) : hslValue.l + hslValue.s - hslValue.l * hslValue.s,
                    p = 2 * hslValue.l - q,
                    result.r = trans(p, q, hslValue.h + 1 / 3),
                    result.g = trans(p, q, hslValue.h),
                    result.b = trans(p, q, hslValue.h - 1 / 3)),
                    result.r = Math.min(Math.round(255 * result.r), 255),
                    result.g = Math.min(Math.round(255 * result.g), 255),
                    result.b = Math.min(Math.round(255 * result.b), 255),
                    result
                },
                rgbValueToHslValue: function(rgbValue) {
                    var max = null
                      , min = null
                      , result = {};
                    return rgbValue = Utils.extend({}, rgbValue),
                    rgbValue.r = rgbValue.r / 255,
                    rgbValue.g = rgbValue.g / 255,
                    rgbValue.b = rgbValue.b / 255,
                    max = Math.max(rgbValue.r, rgbValue.g, rgbValue.b),
                    min = Math.min(rgbValue.r, rgbValue.g, rgbValue.b),
                    max === min ? result.h = 0 : max === rgbValue.r ? rgbValue.g >= rgbValue.b ? result.h = 60 * (rgbValue.g - rgbValue.b) / (max - min) : result.h = 60 * (rgbValue.g - rgbValue.b) / (max - min) + 360 : max === rgbValue.g ? result.h = 60 * (rgbValue.b - rgbValue.r) / (max - min) + 120 : max === rgbValue.b && (result.h = 60 * (rgbValue.r - rgbValue.g) / (max - min) + 240),
                    result.l = (max + min) / 2,
                    0 === result.l || max === min ? result.s = 0 : result.l > 0 && result.l <= .5 ? result.s = (max - min) / (max + min) : result.s = (max - min) / (2 - max - min),
                    result.h = Math.round(result.h),
                    result.s = Math.round(100 * result.s),
                    result.l = Math.round(100 * result.l),
                    result
                },
                toString: function(colorValue, type) {
                    var vals = [];
                    return colorValue = Utils.extend({}, colorValue),
                    -1 !== type.indexOf("hsl") && (colorValue.s += "%",
                    colorValue.l += "%"),
                    "hex" !== type ? (Utils.each(type.split(""), function(key) {
                        vals.push(colorValue[key])
                    }),
                    (type + "(" + vals.join(", ") + ")").toLowerCase()) : (vals.push(ColorUtils.toHexValue(+colorValue.r)),
                    vals.push(ColorUtils.toHexValue(+colorValue.g)),
                    vals.push(ColorUtils.toHexValue(+colorValue.b)),
                    ("#" + vals.join("")).toLowerCase())
                },
                toNumber: function(value) {
                    return 0 | Number("0x" + value)
                },
                toHexValue: function(value) {
                    var result = value.toString(16);
                    return 1 === result.length ? "0" + result : result
                },
                overflowFormat: function(value) {
                    var tmpValue = Utils.extend({}, value);
                    return Utils.each("rgba".split(""), function(key) {
                        tmpValue.hasOwnProperty(key) && (tmpValue[key] = Math.min(Color._MAX_VALUE[key], tmpValue[key]),
                        tmpValue[key] = Math.max(Color._MIN_VALUE[key], tmpValue[key]))
                    }),
                    tmpValue
                }
            }),
            Color
        }
    },
    _p[29] = {
        value: function(require, exports, module) {
            function itemRemove() {
                return this.container.removeItem(this),
                this
            }
            return _p.r(11).createClass("Container", {
                getItems: function() {
                    return this.items || (this.items = [])
                },
                getItem: function(index) {
                    return this.getItems()[index]
                },
                getFirstItem: function() {
                    return this.getItem(0)
                },
                getLastItem: function() {
                    return this.getItem(this.getItems().length - 1)
                },
                indexOf: function(item) {
                    return this.getItems().indexOf(item)
                },
                eachItem: function(fn) {
                    var i, items = this.getItems(), length = items.length;
                    for (i = 0; i < length; i++)
                        fn.call(this, i, items[i]);
                    return this
                },
                addItem: function(item, pos, noEvent) {
                    var items = this.getItems()
                      , length = items.length;
                    return ~items.indexOf(item) ? this : (pos >= 0 && pos < length || (pos = length),
                    items.splice(pos, 0, item),
                    "object" == typeof item && (item.container = this,
                    item.remove = itemRemove),
                    this.handleAdd(item, pos),
                    noEvent || this.onContainerChanged("add", [item]),
                    this)
                },
                addItems: function(items) {
                    for (var i = 0, l = items.length; i < l; i++)
                        this.addItem(items[i], -1, !0);
                    return this.onContainerChanged("add", items),
                    this
                },
                setItems: function(items) {
                    return this.clear().addItems(items)
                },
                appendItem: function(item) {
                    return this.addItem(item)
                },
                prependItem: function(item) {
                    return this.addItem(item, 0)
                },
                removeItem: function(pos, noEvent) {
                    if ("number" != typeof pos)
                        return this.removeItem(this.indexOf(pos));
                    var items = this.getItems()
                      , item = (items.length,
                    items[pos]);
                    return void 0 === item ? this : (items.splice(pos, 1),
                    item.container && delete item.container,
                    item.remove && delete item.remove,
                    this.handleRemove(item, pos),
                    noEvent || this.onContainerChanged("remove", [item]),
                    this)
                },
                clear: function() {
                    for (var item, removed = []; item = this.getFirstItem(); )
                        removed.push(item),
                        this.removeItem(0, !0);
                    return this.onContainerChanged("remove", removed),
                    this
                },
                onContainerChanged: function(type, items) {},
                handleAdd: function(item, index) {},
                handleRemove: function(item, index) {}
            })
        }
    },
    _p[30] = {
        value: function(require, exports, module) {
            var Utils = _p.r(12)
              , CurveUtil = {
                getCurvePanLines: function(points, smoothFactor) {
                    var centerPoints = CurveUtil.getCenterPoints(points)
                      , panLines = CurveUtil.getPanLine(points.length, centerPoints);
                    return CurveUtil.getMovedPanLines(points, panLines, smoothFactor)
                },
                getCenterPoints: function(points) {
                    for (var centerPoints = {}, key = null, i = 0, j = 0, len = points.length; i < len; i++)
                        j = i === len - 1 ? 0 : i + 1,
                        key = i + "," + j,
                        centerPoints[key] = {
                            x: (points[i].x + points[j].y) / 2,
                            y: (points[i].x + points[j].y) / 2
                        };
                    return centerPoints
                },
                getPanLine: function(length, points) {
                    for (var j, result = {}, pointIndex = null, i = 0; i < length; i++) {
                        var point1 = null
                          , point2 = null;
                        j = (i + 1) % length,
                        pointIndex = j,
                        point1 = points[i + "," + j],
                        i = j,
                        j = (i + 1) % length,
                        point2 = points[i + "," + j],
                        result[pointIndex] = {
                            points: [{
                                x: point1.x,
                                y: point1.y
                            }, {
                                x: point2.x,
                                y: point2.y
                            }],
                            center: {
                                x: (point1.x + point2.x) / 2,
                                y: (point1.y + point2.y) / 2
                            }
                        },
                        i = (pointIndex + length - 1) % length
                    }
                    return result
                },
                getMovedPanLines: function(points, panLines, smoothFactor) {
                    var result = {};
                    return Utils.each(points, function(point, index) {
                        var currentPanLine = panLines[index]
                          , center = currentPanLine.center
                          , distance = {
                            x: center.x - point.x,
                            y: center.y - point.y
                        }
                          , currentResult = result[index] = {
                            points: [],
                            center: {
                                x: point.x,
                                y: point.y
                            }
                        };
                        Utils.each(currentPanLine.points, function(controlPoint, index) {
                            var moved = {
                                x: controlPoint.x - distance.x,
                                y: controlPoint.y - distance.y
                            }
                              , vertex = currentResult.center
                              , dx = moved.x - vertex.x
                              , dy = moved.y - vertex.y;
                            moved.x = vertex.x + smoothFactor * dx,
                            moved.y = vertex.y + smoothFactor * dy,
                            currentResult.points.push(moved)
                        })
                    }),
                    result
                }
            };
            return _p.r(11).createClass("Curve", {
                base: _p.r(46),
                mixins: [_p.r(51)],
                constructor: function(points, isColse) {
                    this.callBase(),
                    this.setPoints(points || []),
                    this.closeState = !!isColse,
                    this.changeable = !0,
                    this.smoothFactor = 1,
                    this.update()
                },
                onContainerChanged: function() {
                    this.changeable && this.update()
                },
                setSmoothFactor: function(factor) {
                    return this.smoothFactor = factor < 0 ? 0 : factor,
                    this.update(),
                    this
                },
                getSmoothFactor: function() {
                    return this.smoothFactor
                },
                update: function() {
                    var points = this.getPoints()
                      , withControlPoints = null
                      , drawer = this.getDrawer()
                      , curPoint = null
                      , curControlPoint = null
                      , prevControlPoint = null;
                    if (drawer.clear(),
                    0 === points.length)
                        return this;
                    if (drawer.moveTo(points[0]),
                    1 === points.length)
                        return this;
                    if (2 === points.length)
                        return drawer.lineTo(points[1]),
                        this;
                    withControlPoints = CurveUtil.getCurvePanLines(points, this.getSmoothFactor());
                    for (var i = 1, len = points.length; i < len; i++)
                        curPoint = withControlPoints[i].center,
                        curControlPoint = this.closeState || i != len - 1 ? withControlPoints[i].points[0] : withControlPoints[i].center,
                        prevControlPoint = this.closeState || 1 != i ? withControlPoints[i - 1].points[1] : withControlPoints[i - 1].center,
                        drawer.bezierTo(prevControlPoint.x, prevControlPoint.y, curControlPoint.x, curControlPoint.y, curPoint.x, curPoint.y);
                    return this.closeState && (curPoint = withControlPoints[0].center,
                    curControlPoint = withControlPoints[0].points[0],
                    prevControlPoint = withControlPoints[points.length - 1].points[1],
                    drawer.bezierTo(prevControlPoint.x, prevControlPoint.y, curControlPoint.x, curControlPoint.y, curPoint.x, curPoint.y)),
                    this
                },
                close: function() {
                    return this.closeState = !0,
                    this.update()
                },
                open: function() {
                    return this.closeState = !1,
                    this.update()
                },
                isClose: function() {
                    return !!this.closeState
                }
            })
        }
    },
    _p[31] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("Data", {
                constructor: function() {
                    this._data = {}
                },
                setData: function(name, value) {
                    return this._data[name] = value,
                    this
                },
                getData: function(name) {
                    return this._data[name]
                },
                removeData: function(name) {
                    return delete this._data[name],
                    this
                }
            })
        }
    },
    _p[32] = {
        value: function(require, exports, module) {
            var Point = (_p.r(12),
            _p.r(50));
            return _p.r(11).createClass("Ellipse", {
                base: _p.r(46),
                constructor: function(rx, ry, cx, cy) {
                    this.callBase(),
                    this.rx = rx || 0,
                    this.ry = ry || 0,
                    this.cx = cx || 0,
                    this.cy = cy || 0,
                    this.update()
                },
                update: function() {
                    var rx = this.rx
                      , ry = this.ry
                      , x1 = this.cx + rx
                      , x2 = this.cx - rx
                      , y = this.cy
                      , drawer = this.getDrawer();
                    return drawer.clear(),
                    drawer.moveTo(x1, y),
                    drawer.arcTo(rx, ry, 0, 1, 1, x2, y),
                    drawer.arcTo(rx, ry, 0, 1, 1, x1, y),
                    this
                },
                getRadius: function() {
                    return {
                        x: this.rx,
                        y: this.ry
                    }
                },
                getRadiusX: function() {
                    return this.rx
                },
                getRadiusY: function() {
                    return this.ry
                },
                getCenter: function() {
                    return new Point(this.cx,this.cy)
                },
                getCenterX: function() {
                    return this.cx
                },
                getCenterY: function() {
                    return this.cy
                },
                setRadius: function(rx, ry) {
                    return this.rx = rx,
                    this.ry = ry,
                    this.update()
                },
                setRadiusX: function(rx) {
                    return this.rx = rx,
                    this.update()
                },
                setRadiusY: function(ry) {
                    return this.ry = ry,
                    this.update()
                },
                setCenter: function(cx, cy) {
                    if (1 == arguments.length) {
                        var p = Point.parse(arguments[0]);
                        cx = p.x,
                        cy = p.y
                    }
                    return this.cx = cx,
                    this.cy = cy,
                    this.update()
                },
                setCenterX: function(cx) {
                    return this.cx = cx,
                    this.update()
                },
                setCenterY: function(cy) {
                    return this.cy = cy,
                    this.update()
                }
            })
        }
    },
    _p[33] = {
        value: function(require, exports, module) {
            function _addEvent(type, handler, isOnce) {
                return isOnce = !!isOnce,
                Utils.isString(type) && (type = type.match(/\S+/g)),
                Utils.each(type, function(currentType) {
                    listen.call(this, this.node, currentType, handler, isOnce)
                }, this),
                this
            }
            function _removeEvent(type, handler) {
                var userHandlerList = null
                  , eventId = this._EVNET_UID
                  , isRemoveAll = void 0 === handler;
                return userHandlerList = USER_HANDLER_CACHE[eventId][type],
                isRemoveAll || (isRemoveAll = !0,
                Utils.each(userHandlerList, function(fn, index) {
                    fn === handler ? delete userHandlerList[index] : isRemoveAll = !1
                })),
                isRemoveAll && (deleteDomEvent(this.node, type, INNER_HANDLER_CACHE[eventId][type]),
                delete USER_HANDLER_CACHE[eventId][type],
                delete INNER_HANDLER_CACHE[eventId][type]),
                this
            }
            function listen(node, type, handler, isOnce) {
                var eid = this._EVNET_UID
                  , targetObject = this;
                INNER_HANDLER_CACHE[eid] || (INNER_HANDLER_CACHE[eid] = {}),
                INNER_HANDLER_CACHE[eid][type] || (INNER_HANDLER_CACHE[eid][type] = function(e) {
                    e = new ShapeEvent(e || window.event),
                    Utils.each(USER_HANDLER_CACHE[eid][type], function(fn) {
                        var result;
                        return fn && (result = fn.call(targetObject, e),
                        isOnce && targetObject.off(type, fn)),
                        result
                    }, targetObject)
                }
                ),
                USER_HANDLER_CACHE[eid] || (USER_HANDLER_CACHE[eid] = {}),
                USER_HANDLER_CACHE[eid][type] ? USER_HANDLER_CACHE[eid][type].push(handler) : (USER_HANDLER_CACHE[eid][type] = [handler],
                node && "on" + type in node && bindDomEvent(node, type, INNER_HANDLER_CACHE[eid][type]))
            }
            function bindDomEvent(node, type, handler) {
                node.addEventListener ? node.addEventListener(type, handler, !1) : node.attachEvent("on" + type, handler)
            }
            function deleteDomEvent(node, type, handler) {
                node.removeEventListener ? node.removeEventListener(type, handler, !1) : node.detachEvent(type, handler)
            }
            function sendMessage(messageObj, type, msg) {
                var event = null
                  , handler = null
                  , handlers = INNER_HANDLER_CACHE[messageObj._EVNET_UID];
                handlers && (handler = handlers[type]) && (event = Utils.extend({
                    type: type,
                    target: messageObj
                }, msg || {}),
                handler.call(messageObj, event))
            }
            !function() {
                function CustomEvent(event, params) {
                    params = params || {
                        bubbles: !1,
                        cancelable: !1,
                        detail: void 0
                    };
                    var evt = document.createEvent("CustomEvent");
                    return evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail),
                    evt
                }
                CustomEvent.prototype = window.Event.prototype,
                window.CustomEvent = CustomEvent
            }();
            var Utils = _p.r(12)
              , ShapeEvent = _p.r(62)
              , INNER_HANDLER_CACHE = {}
              , USER_HANDLER_CACHE = {}
              , guid = 0;
            return _p.r(11).createClass("EventHandler", {
                constructor: function() {
                    this._EVNET_UID = ++guid
                },
                addEventListener: function(type, handler) {
                    return _addEvent.call(this, type, handler, !1)
                },
                addOnceEventListener: function(type, handler) {
                    return _addEvent.call(this, type, handler, !0)
                },
                removeEventListener: function(type, handler) {
                    return _removeEvent.call(this, type, handler)
                },
                on: function(type, handler) {
                    return this.addEventListener.apply(this, arguments)
                },
                once: function(type, handler) {
                    return this.addOnceEventListener.apply(this, arguments)
                },
                off: function() {
                    return this.removeEventListener.apply(this, arguments)
                },
                fire: function(type, params) {
                    return this.trigger.apply(this, arguments)
                },
                trigger: function(type, params) {
                    return sendMessage(this, type, params),
                    this
                }
            })
        }
    },
    _p[34] = {
        value: function(require) {
            function pathClone(path) {
                var result, i, j, segment, segmentCopy;
                for (result = [],
                i = 0; i < path.length; i++)
                    for (segment = path[i],
                    result.push(segmentCopy = []),
                    j = 0; j < segment.length; j++)
                        segmentCopy.push(segment[j]);
                return path.isUniform && (result.isUniform = !0),
                path.isAbsolute && (result.isAbsolute = !0),
                path.isCurve && (result.isCurve = !0),
                result
            }
            function cacher(f, scope, postprocessor) {
                function repush(array, item) {
                    for (var i = 0, ii = array.length; i < ii; i++)
                        if (array[i] === item)
                            return array.push(array.splice(i, 1)[0])
                }
                function newf() {
                    var arg = Array.prototype.slice.call(arguments, 0)
                      , args = arg.join("␀")
                      , cache = newf.cache = newf.cache || {}
                      , count = newf.count = newf.count || [];
                    return cache.hasOwnProperty(args) ? (repush(count, args),
                    postprocessor ? postprocessor(cache[args]) : cache[args]) : (count.length >= 1e3 && delete cache[count.shift()],
                    count.push(args),
                    cache[args] = f.apply(scope, arg),
                    postprocessor ? postprocessor(cache[args]) : cache[args])
                }
                return newf
            }
            function a2c(x1, y1, rx, ry, angle, laf, sf, x2, y2, recursive) {
                var xy, h, x, y, rx2, ry2, k, cx, cy, f1, f2, df, f2old, x2old, y2old, c1, s1, c2, s2, t, hx, hy, m1, m2, m3, m4, newres, i, ii, math = Math, PI = math.PI, abs = Math.abs, _120 = 120 * PI / 180, rad = PI / 180 * (+angle || 0), res = [], rotate = function(x, y, rad) {
                    return {
                        x: x * math.cos(rad) - y * math.sin(rad),
                        y: x * math.sin(rad) + y * math.cos(rad)
                    }
                };
                if (recursive ? (f1 = recursive[0],
                f2 = recursive[1],
                cx = recursive[2],
                cy = recursive[3]) : (xy = rotate(x1, y1, -rad),
                x1 = xy.x,
                y1 = xy.y,
                xy = rotate(x2, y2, -rad),
                x2 = xy.x,
                y2 = xy.y,
                math.cos(PI / 180 * angle),
                math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2,
                h = x * x / (rx * rx) + y * y / (ry * ry),
                h > 1 && (h = math.sqrt(h),
                rx *= h,
                ry *= h),
                rx2 = rx * rx,
                ry2 = ry * ry,
                k = (laf == sf ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9)),
                f1 = x1 < cx ? PI - f1 : f1,
                f2 = x2 < cx ? PI - f2 : f2,
                f1 < 0 && (f1 = 2 * PI + f1),
                f2 < 0 && (f2 = 2 * PI + f2),
                sf && f1 > f2 && (f1 -= 2 * PI),
                !sf && f2 > f1 && (f2 -= 2 * PI)),
                df = f2 - f1,
                abs(df) > _120 && (f2old = f2,
                x2old = x2,
                y2old = y2,
                f2 = f1 + _120 * (sf && f2 > f1 ? 1 : -1),
                x2 = cx + rx * math.cos(f2),
                y2 = cy + ry * math.sin(f2),
                res = a2c(x2, y2, rx, ry, angle, 0, sf, x2old, y2old, [f2, f2old, cx, cy])),
                df = f2 - f1,
                c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2],
                m2[0] = 2 * m1[0] - m2[0],
                m2[1] = 2 * m1[1] - m2[1],
                recursive)
                    return [m2, m3, m4].concat(res);
                for (res = [m2, m3, m4].concat(res).join().split(","),
                newres = [],
                i = 0,
                ii = res.length; i < ii; i++)
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                return newres
            }
            function q2c(x1, y1, ax, ay, x2, y2) {
                return [1 / 3 * x1 + 2 / 3 * ax, 1 / 3 * y1 + 2 / 3 * ay, 1 / 3 * x2 + 2 / 3 * ax, 1 / 3 * y2 + 2 / 3 * ay, x2, y2]
            }
            function cutBezier(bezierArray, t) {
                var _ = function(t) {
                    return function(p, q) {
                        return p + t * (q - p)
                    }
                }(t || .5)
                  , ba = bezierArray
                  , ax = ba[0]
                  , ay = ba[1]
                  , bx = ba[2]
                  , by = ba[3]
                  , cx = ba[4]
                  , cy = ba[5]
                  , dx = ba[6]
                  , dy = ba[7]
                  , ex = _(ax, bx)
                  , ey = _(ay, by)
                  , fx = _(bx, cx)
                  , fy = _(by, cy)
                  , gx = _(cx, dx)
                  , gy = _(cy, dy)
                  , hx = _(ex, fx)
                  , hy = _(ey, fy)
                  , jx = _(fx, gx)
                  , jy = _(fy, gy)
                  , kx = _(hx, jx)
                  , ky = _(hy, jy);
                return [[ax, ay, ex, ey, hx, hy, kx, ky], [kx, ky, jx, jy, gx, gy, dx, dy]]
            }
            var utils = _p.r(12)
              , Point = _p.r(50)
              , Vector = _p.r(73)
              , Matrix = _p.r(43)
              , g = {}
              , pathCommand = /([achlmrqstvz])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?\s*)+)/gi
              , pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s*,?\s*/gi
              , paramCounts = {
                a: 7,
                c: 6,
                h: 1,
                l: 2,
                m: 2,
                q: 4,
                s: 4,
                t: 2,
                v: 1,
                z: 0
            };
            g.pathToString = function(pathSegment) {
                return pathSegment = pathSegment || this,
                "string" == typeof pathSegment ? pathSegment : pathSegment instanceof Array ? (pathSegment = utils.flatten(pathSegment),
                pathSegment.join(",").replace(/,?([achlmqrstvxz]),?/gi, "$1")) : void 0
            }
            ,
            g.parsePathString = cacher(function(pathString) {
                var data = [];
                return pathString.replace(pathCommand, function(a, b, c) {
                    var params = []
                      , name = b.toLowerCase();
                    if (c.replace(pathValues, function(a, b) {
                        b && params.push(+b)
                    }),
                    "m" == name && params.length > 2 && (data.push([b].concat(params.splice(0, 2))),
                    name = "l",
                    b = "m" == b ? "l" : "L"),
                    "r" == name)
                        data.push([b].concat(params));
                    else
                        for (; params.length >= paramCounts[name] && (data.push([b].concat(params.splice(0, paramCounts[name]))),
                        paramCounts[name]); )
                            ;
                }),
                data.isUniform = !0,
                data.toString = g.pathToString,
                data
            }),
            g.pathToAbsolute = cacher(function(path) {
                var r, pa, i, j, k, ii, jj, kk, pathArray = path.isUniform ? path : g.parsePathString(g.pathToString(path)), res = [], x = 0, y = 0, mx = 0, my = 0, start = 0;
                for ("M" == pathArray[0][0] && (x = +pathArray[0][1],
                y = +pathArray[0][2],
                mx = x,
                my = y,
                start++,
                res[0] = ["M", x, y]),
                i = start,
                ii = pathArray.length; i < ii; i++) {
                    if (res.push(r = []),
                    pa = pathArray[i],
                    pa[0] != pa[0].toUpperCase())
                        switch (r[0] = pa[0].toUpperCase(),
                        r[0]) {
                        case "A":
                            r[1] = pa[1],
                            r[2] = pa[2],
                            r[3] = pa[3],
                            r[4] = pa[4],
                            r[5] = pa[5],
                            r[6] = +(pa[6] + x),
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "M":
                            mx = +pa[1] + x,
                            my = +pa[2] + y;
                            break;
                        default:
                            for (j = 1,
                            jj = pa.length; j < jj; j++)
                                r[j] = +pa[j] + (j % 2 ? x : y)
                        }
                    else
                        for (k = 0,
                        kk = pa.length; k < kk; k++)
                            r[k] = pa[k];
                    switch (r[0]) {
                    case "Z":
                        x = mx,
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2],
                        my = r[r.length - 1];
                        break;
                    default:
                        x = r[r.length - 2],
                        y = r[r.length - 1]
                    }
                }
                return res.isUniform = !0,
                res.isAbsolute = !0,
                res.toString = g.pathToString,
                res
            }),
            g.pathToCurve = cacher(function(path) {
                var i, j, command, param, initPoint, currentPoint, endPoint, shouldClose, lastControlPoint, aussumedControlPoint, controlPoint1, controlPoint2, res = [];
                for (path.isAbsolute || (path = g.pathToAbsolute(path)),
                i = 0; i < path.length; i++)
                    if (command = path[i][0],
                    param = path[i].slice(1),
                    "M" != command) {
                        switch ("Z" == command && (shouldClose = !0,
                        command = "L",
                        param = initPoint),
                        endPoint = param.slice(param.length - 2),
                        "H" == command && (endPoint = [param[0], currentPoint[1]],
                        command = "L"),
                        "V" == command && (endPoint = [currentPoint[0], param[0]],
                        command = "L"),
                        "S" != command && "T" != command || (aussumedControlPoint = [currentPoint[0] + (currentPoint[0] - lastControlPoint[0]), currentPoint[1] + (currentPoint[1] - lastControlPoint[1])]),
                        command) {
                        case "L":
                            controlPoint1 = currentPoint,
                            controlPoint2 = endPoint;
                            break;
                        case "C":
                            controlPoint1 = param.slice(0, 2),
                            controlPoint2 = param.slice(2, 4);
                            break;
                        case "S":
                            controlPoint1 = aussumedControlPoint.slice(),
                            controlPoint2 = param.slice(0, 2);
                            break;
                        case "Q":
                            lastControlPoint = param.slice(0, 2),
                            param = q2c.apply(null, currentPoint.concat(param)),
                            controlPoint1 = param.slice(0, 2),
                            controlPoint2 = param.slice(2, 4);
                            break;
                        case "T":
                            param = q2c.apply(null, currentPoint.concat(aussumedControlPoint).concat(param)),
                            controlPoint1 = param.slice(0, 2),
                            controlPoint2 = param.slice(2, 4);
                            break;
                        case "A":
                            for (param = a2c.apply(null, currentPoint.concat(param)),
                            j = 0; j in param; )
                                controlPoint1 = param.slice(j, j + 2),
                                controlPoint2 = param.slice(j + 2, j + 4),
                                endPoint = param.slice(j + 4, j + 6),
                                res.push(["C"].concat(controlPoint1).concat(controlPoint2).concat(endPoint)),
                                j += 6
                        }
                        "A" != command && res.push(["C"].concat(controlPoint1).concat(controlPoint2).concat(endPoint)),
                        currentPoint = endPoint,
                        "Q" != command && (lastControlPoint = controlPoint2),
                        shouldClose && (res.push(["Z"]),
                        shouldClose = !1)
                    } else
                        initPoint = lastControlPoint = currentPoint = param,
                        res.push(path[i]);
                return res.isUniform = !0,
                res.isAbsolute = !0,
                res.isCurve = !0,
                res.toString = g.pathToString,
                res
            }),
            g.cutBezier = cacher(cutBezier),
            g.subBezier = function(bezierArray, t, t0) {
                var b2t = cutBezier(bezierArray, t)[0];
                return t0 ? cutBezier(b2t, t0 / t)[1] : b2t
            }
            ,
            g.pointAtBezier = function(bezierArray, t) {
                var b2t = cutBezier(bezierArray, t)[0]
                  , p = Point.parse(b2t.slice(6))
                  , c = Point.parse(b2t.slice(4, 2))
                  , v = Vector.fromPoints(c, p);
                return p.tan = 0 === t ? g.pointAtBezier(bezierArray, .01).tan : v.normalize(),
                p
            }
            ,
            g.bezierLength = cacher(function(bezierArray) {
                function f(x) {
                    var m = c0 * Math.pow(x, 4) + c1 * Math.pow(x, 3) + c2 * Math.pow(x, 2) + c3 * x + c4;
                    return m < 0 && (m = 0),
                    Math.pow(m, .5)
                }
                var cx0, cx1, cx2, cy0, cy1, cy2, c0, c1, c2, c3, c4, arr = bezierArray;
                return cx0 = -3 * arr[0] + 9 * arr[2] - 9 * arr[4] + 3 * arr[6],
                cx1 = 6 * arr[0] - 12 * arr[2] + 6 * arr[4],
                cx2 = -3 * arr[0] + 3 * arr[2],
                cy0 = -3 * arr[1] + 9 * arr[3] - 9 * arr[5] + 3 * arr[7],
                cy1 = 6 * arr[1] - 12 * arr[3] + 6 * arr[5],
                cy2 = -3 * arr[1] + 3 * arr[3],
                c0 = Math.pow(cx0, 2) + Math.pow(cy0, 2),
                c1 = 2 * (cx0 * cx1 + cy0 * cy1),
                c2 = 2 * (cx0 * cx2 + cy0 * cy2) + Math.pow(cx1, 2) + Math.pow(cy1, 2),
                c3 = 2 * (cx1 * cx2 + cy1 * cy2),
                c4 = Math.pow(cx2, 2) + Math.pow(cy2, 2),
                (f(0) + f(1) + 4 * (f(.125) + f(.375) + f(.625) + f(.875)) + 2 * (f(.25) + f(.5) + f(.75))) / 24
            });
            var getBezierPathSegmentRanges = cacher(function(pathSegment) {
                var i, ii, segment, position, bezierLength, segmentRanges, totalLength;
                for (segmentRanges = [],
                totalLength = 0,
                i = 0,
                ii = pathSegment.length; i < ii; i++)
                    segment = pathSegment[i],
                    "M" != segment[0] ? "Z" != segment[0] ? (bezierLength = g.bezierLength(position.concat(segment.slice(1))),
                    segmentRanges.push([totalLength, totalLength + bezierLength]),
                    totalLength += bezierLength,
                    position = segment.slice(4)) : segmentRanges.push(null) : (position = segment.slice(1),
                    segmentRanges.push(null));
                return segmentRanges.totalLength = totalLength,
                segmentRanges
            });
            g.subPath = function(path, t1, t0) {
                var dt;
                if (t0 = t0 || 0,
                dt = t1 - t0,
                dt -= 0 | dt,
                t0 -= 0 | t0,
                (t1 = t0 + dt) > 1)
                    return g.subPath(path, 1, t0).concat(g.subPath(path, t1 - 1));
                path.isCurve || (path = g.pathToCurve(path));
                var i, ii, a, b, d, position, bezier, subBezier, stared, segmentRanges = getBezierPathSegmentRanges(path), totalLength = segmentRanges.totalLength, t1Length = totalLength * t1, t0Length = totalLength * (t0 || 0), subPath = [];
                for (i = 0,
                ii = path.length; i < ii; i++)
                    if ("M" != path[i][0]) {
                        if ("Z" != path[i][0])
                            if (a = segmentRanges[i][0],
                            b = segmentRanges[i][1],
                            d = b - a,
                            bezier = position.concat(path[i].slice(1)),
                            t0Length > b)
                                position = bezier.slice(bezier.length - 2);
                            else {
                                if (t0Length >= a)
                                    subBezier = g.subBezier(bezier, Math.min((t1Length - a) / d, 1), (t0Length - a) / d),
                                    stared = !0,
                                    position = subBezier.slice(0, 2),
                                    subPath.push(["M"].concat(subBezier.slice(0, 2))),
                                    subPath.push(["C"].concat(subBezier.slice(2)));
                                else if (t1Length >= b)
                                    subPath.push(path[i].slice());
                                else {
                                    if (!(t1Length >= a))
                                        break;
                                    subBezier = g.subBezier(bezier, (t1Length - a) / d),
                                    subPath.push(["C"].concat(subBezier.slice(2))),
                                    stared = !1
                                }
                                position = bezier.slice(bezier.length - 2)
                            }
                    } else
                        position = path[i].slice(1),
                        stared && subPath.push(path[i].slice());
                return subPath.isAbsolute = !0,
                subPath.isCurve = !0,
                subPath.isUniform = !0,
                subPath.toString = g.pathToString,
                subPath
            }
            ,
            g.pointAtPath = function(path, t) {
                path.isCurve || (path = g.pathToCurve(path));
                var subPath = g.subPath(path, t)
                  , lastCurve = "Z" == subPath[subPath.length - 1][0] ? subPath[subPath.length - 2] : subPath[subPath.length - 1];
                lastCurve = lastCurve.slice(1);
                var p = Point.parse(lastCurve.slice(4))
                  , c = Point.parse(lastCurve.slice(2, 4));
                return p.tan = Vector.fromPoints(c, p).normalize(),
                p
            }
            ,
            g.pathLength = cacher(function(path) {
                return path.isCurve || (path = g.pathToCurve(path)),
                getBezierPathSegmentRanges(path).totalLength
            }),
            g.pathKeyPoints = cacher(function(path) {
                var i, ii, keyPoints;
                for (path.isCurve || (path = g.pathToCurve(path)),
                keyPoints = [],
                i = 0,
                ii = path.length; i < ii; i++)
                    "z" != path[i][0] && keyPoints.push(path[i].slice(path[i].length - 2));
                return keyPoints
            });
            var alignCurve = cacher(function(path1, path2) {
                function command(p, i) {
                    return p[i || p.i] && p[i || p.i][0]
                }
                function param(p, i) {
                    return p[i || p.i] && p[i || p.i].slice(1)
                }
                function point(p, i) {
                    var _param = param(p, i);
                    return _param && _param.slice(-2)
                }
                function fixZ(p) {
                    return "Z" == command(p) && (p.splice(p.i, 1),
                    !0)
                }
                function fixM(p) {
                    return "M" == command(p) && (p.o.splice(p.o.i, 0, ["M"].concat(point(p.o, p.o.i - 1))),
                    p.i++,
                    p.o.i++,
                    !0)
                }
                function fill(p) {
                    for (var lastPoint, i = 1; !lastPoint; )
                        lastPoint = point(p, p.length - i++);
                    for (p.o.i = p.i; p.length < p.o.length; )
                        fixZ(p.o) || fixM(p.o) || (p.push(["C"].concat(lastPoint).concat(lastPoint).concat(lastPoint)),
                        p.i++,
                        p.o.i++)
                }
                path1.isCurve || (path1 = g.pathToCurve(path1)),
                path2.isCurve || (path2 = g.pathToCurve(path2));
                var p1 = pathClone(path1)
                  , p2 = pathClone(path2);
                for (p1.i = 0,
                p2.i = 0,
                p1.o = p2,
                p2.o = p1; p1.i < p1.length && p2.i < p2.length; )
                    fixZ(p1) || fixZ(p2) || (command(p1) != command(p2) ? fixM(p1) || fixM(p2) || (p1.i++,
                    p2.i++) : (p1.i++,
                    p2.i++));
                return p1.i == p1.length && fill(p1),
                p2.i == p2.length && fill(p2),
                delete p1.i,
                delete p1.o,
                delete p2.i,
                delete p2.o,
                [p1, p2]
            });
            return g.alignCurve = alignCurve,
            g.pathTween = function(path1, path2, t) {
                if (0 === t)
                    return path1;
                if (1 === t)
                    return path2;
                var seg, i, j, aligned = alignCurve(path1, path2), result = [];
                for (path1 = aligned[0],
                path2 = aligned[1],
                i = 0; i < path1.length; i++)
                    for (result.push(seg = []),
                    seg.push(path1[i][0]),
                    j = 1; j < path1[i].length; j++)
                        seg.push(path1[i][j] + t * (path2[i][j] - path1[i][j]));
                return result.isUniform = result.isCurve = result.isAbsolute = !0,
                result
            }
            ,
            g.transformPath = cacher(function(path, matrix) {
                var i, ii, j, result, pair;
                for (path.isCurve || (path = g.pathToCurve(path)),
                result = [],
                i = 0,
                ii = path.length; i < ii; i++)
                    for (result.push([path[i][0]]),
                    j = 1; j < path[i].length; j += 2)
                        pair = path[i].slice(j, j + 2),
                        pair = matrix.transformPoint(Point.parse(pair)),
                        result.push(pair);
                return result
            }),
            _p.r(11).extendClass(Matrix, {
                transformPath: function(path) {
                    return g.transformPath(path, this)
                }
            }),
            g
        }
    },
    _p[35] = {
        value: function(require, exports, module) {
            var svg = _p.r(67)
              , Resource = _p.r(58)
              , Color = _p.r(28);
            return _p.r(11).createClass("GradientBrush", {
                base: Resource,
                constructor: function(gradientNodeType, paper) {
                    this.callBase(gradientNodeType, paper),
                    this.stops = []
                },
                addStop: function(offset, color, opacity) {
                    var gstop = svg.createNode("stop");
                    return color instanceof Color || (color = Color.parse(color)),
                    void 0 === opacity && (opacity = color.get("a")),
                    gstop.setAttribute("offset", offset),
                    gstop.setAttribute("stop-color", color.toRGB()),
                    opacity < 1 && gstop.setAttribute("stop-opacity", opacity),
                    this.node.appendChild(gstop),
                    this
                }
            })
        }
    },
    _p[36] = {
        value: function(require, exports, module) {
            var ShapeContainer = _p.r(61);
            return _p.r(11).createClass("Group", {
                mixins: [ShapeContainer],
                base: _p.r(60),
                constructor: function() {
                    this.callBase("g")
                }
            })
        }
    },
    _p[37] = {
        value: function(require, exports, module) {
            var ShapeContainer = _p.r(61);
            return _p.r(11).createClass("HyperLink", {
                mixins: [ShapeContainer],
                base: _p.r(60),
                constructor: function(url) {
                    this.callBase("a"),
                    this.setHref(url)
                },
                setHref: function(href) {
                    return this.node.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", href),
                    this
                },
                getHref: function() {
                    return this.node.getAttributeNS("xlink:href")
                },
                setTarget: function(target) {
                    return this.node.setAttribute("target", target),
                    this
                },
                getTarget: function() {
                    return this.node.getAttribute("target")
                }
            })
        }
    },
    _p[38] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("Image", {
                base: _p.r(60),
                constructor: function(url, width, height, x, y) {
                    this.callBase("image"),
                    this.url = url,
                    this.width = width || 0,
                    this.height = height || 0,
                    this.x = x || 0,
                    this.y = y || 0,
                    this.update()
                },
                update: function() {
                    return this.node.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this.url),
                    this.node.setAttribute("x", this.x),
                    this.node.setAttribute("y", this.y),
                    this.node.setAttribute("width", this.width),
                    this.node.setAttribute("height", this.height),
                    this
                },
                setUrl: function(url) {
                    return this.url = "" === url ? null : url,
                    this.update()
                },
                getUrl: function() {
                    return this.url
                },
                setWidth: function(width) {
                    return this.width = width,
                    this.update()
                },
                getWidth: function() {
                    return this.width
                },
                setHeight: function(height) {
                    return this.height = height,
                    this.update()
                },
                getHeight: function() {
                    return this.height
                },
                setX: function(x) {
                    return this.x = x,
                    this.update()
                },
                getX: function() {
                    return this.x
                },
                setY: function(y) {
                    return this.y = y,
                    this.update()
                },
                getY: function() {
                    return this.y
                }
            })
        }
    },
    _p[39] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("Line", {
                base: _p.r(46),
                constructor: function(x1, y1, x2, y2) {
                    this.callBase(),
                    this.point1 = {
                        x: x1 || 0,
                        y: y1 || 0
                    },
                    this.point2 = {
                        x: x2 || 0,
                        y: y2 || 0
                    },
                    this.update()
                },
                setPoint1: function(x, y) {
                    return this.point1.x = x,
                    this.point1.y = y,
                    this.update()
                },
                setPoint2: function(x, y) {
                    return this.point2.x = x,
                    this.point2.y = y,
                    this.update()
                },
                getPoint1: function() {
                    return {
                        x: this.point1.x,
                        y: this.point1.y
                    }
                },
                getPoint2: function() {
                    return {
                        x: this.point2.x,
                        y: this.point2.y
                    }
                },
                update: function() {
                    var drawer = this.getDrawer();
                    return drawer.clear(),
                    drawer.moveTo(this.point1.x, this.point1.y),
                    drawer.lineTo(this.point2.x, this.point2.y),
                    this
                }
            })
        }
    },
    _p[40] = {
        value: function(require, exports, module) {
            var Gradient = (_p.r(67),
            _p.r(35));
            return _p.r(11).createClass("LinearGradientBrush", {
                base: Gradient,
                constructor: function(paper) {
                    this.callBase("linearGradient", paper),
                    this.setStartPosition(0, 0),
                    this.setEndPosition(1, 0)
                },
                setStartPosition: function(px, py) {
                    return this.node.setAttribute("x1", px),
                    this.node.setAttribute("y1", py),
                    this
                },
                setEndPosition: function(px, py) {
                    return this.node.setAttribute("x2", px),
                    this.node.setAttribute("y2", py),
                    this
                },
                getStartPosition: function() {
                    return {
                        x: +this.node.getAttribute("x1"),
                        y: +this.node.getAttribute("y1")
                    }
                },
                getEndPosition: function() {
                    return {
                        x: +this.node.getAttribute("x2"),
                        y: +this.node.getAttribute("y2")
                    }
                }
            })
        }
    },
    _p[41] = {
        value: function(require, exports, module) {
            var Point = _p.r(50)
              , Marker = _p.r(11).createClass("Marker", {
                base: _p.r(58),
                mixins: [_p.r(61), _p.r(75)],
                constructor: function() {
                    this.callBase("marker"),
                    this.setOrient("auto")
                },
                setRef: function(x, y) {
                    return 1 === arguments.length && (y = x.y,
                    x = x.x),
                    this.node.setAttribute("refX", x),
                    this.node.setAttribute("refY", y),
                    this
                },
                getRef: function() {
                    return new Point(+this.node.getAttribute("refX"),+this.node.getAttribute("refY"))
                },
                setWidth: function(width) {
                    return this.node.setAttribute("markerWidth", this.width = width),
                    this
                },
                setOrient: function(orient) {
                    return this.node.setAttribute("orient", this.orient = orient),
                    this
                },
                getOrient: function() {
                    return this.orient
                },
                getWidth: function() {
                    return +this.width
                },
                setHeight: function(height) {
                    return this.node.setAttribute("markerHeight", this.height = height),
                    this
                },
                getHeight: function() {
                    return +this.height
                }
            })
              , Path = _p.r(46);
            return _p.r(11).extendClass(Path, {
                setMarker: function(marker, pos) {
                    return pos = pos || "end",
                    marker ? this.node.setAttribute("marker-" + pos, marker.toString()) : this.node.removeAttribute("marker-" + pos),
                    this
                }
            }),
            Marker
        }
    },
    _p[42] = {
        value: function(require, exports, module) {
            var Class = _p.r(11)
              , Shape = _p.r(60)
              , Mask = Class.createClass("Mask", {
                base: Shape,
                mixins: [_p.r(61)],
                constructor: function() {
                    this.callBase("mask")
                },
                mask: function(shape) {
                    return shape.getNode().setAttribute("mask", "url(#" + this.getId() + ")"),
                    this
                }
            });
            return Class.extendClass(Shape, {
                maskWith: function(mask) {
                    return mask.mask(this),
                    this
                }
            }),
            Mask
        }
    },
    _p[43] = {
        value: function(require, exports, module) {
            function mergeMatrixData(m2, m1) {
                return {
                    a: m1.a * m2.a + m1.c * m2.b,
                    b: m1.b * m2.a + m1.d * m2.b,
                    c: m1.a * m2.c + m1.c * m2.d,
                    d: m1.b * m2.c + m1.d * m2.d,
                    e: m1.a * m2.e + m1.c * m2.f + m1.e,
                    f: m1.b * m2.e + m1.d * m2.f + m1.f
                }
            }
            function d2r(deg) {
                return deg * Math.PI / 180
            }
            var utils = _p.r(12)
              , Box = _p.r(25)
              , mPattern = /matrix\s*\((.+)\)/i
              , Point = _p.r(50)
              , Matrix = _p.r(11).createClass("Matrix", {
                constructor: function() {
                    arguments.length ? this.setMatrix.apply(this, arguments) : this.setMatrix(1, 0, 0, 1, 0, 0)
                },
                translate: function(x, y) {
                    return this.m = mergeMatrixData(this.m, {
                        a: 1,
                        c: 0,
                        e: x,
                        b: 0,
                        d: 1,
                        f: y
                    }),
                    this
                },
                rotate: function(deg) {
                    var rad = d2r(deg)
                      , sin = Math.sin(rad)
                      , cos = Math.cos(rad);
                    return this.m = mergeMatrixData(this.m, {
                        a: cos,
                        c: -sin,
                        e: 0,
                        b: sin,
                        d: cos,
                        f: 0
                    }),
                    this
                },
                scale: function(sx, sy) {
                    return void 0 === sy && (sy = sx),
                    this.m = mergeMatrixData(this.m, {
                        a: sx,
                        c: 0,
                        e: 0,
                        b: 0,
                        d: sy,
                        f: 0
                    }),
                    this
                },
                skew: function(degX, degY) {
                    void 0 === degY && (degY = degX);
                    var tx = Math.tan(d2r(degX))
                      , ty = Math.tan(d2r(degY));
                    return this.m = mergeMatrixData(this.m, {
                        a: 1,
                        c: tx,
                        e: 0,
                        b: ty,
                        d: 1,
                        f: 0
                    }),
                    this
                },
                inverse: function() {
                    var k, aa, bb, cc, dd, ee, ff, m = this.m, a = m.a, b = m.b, c = m.c, d = m.d, e = m.e, f = m.f;
                    return k = a * d - b * c,
                    aa = d / k,
                    bb = -b / k,
                    cc = -c / k,
                    dd = a / k,
                    ee = (c * f - e * d) / k,
                    ff = (b * e - a * f) / k,
                    new Matrix(aa,bb,cc,dd,ee,ff)
                },
                setMatrix: function(a, b, c, d, e, f) {
                    return 1 === arguments.length ? this.m = utils.clone(arguments[0]) : this.m = {
                        a: a,
                        b: b,
                        c: c,
                        d: d,
                        e: e,
                        f: f
                    },
                    this
                },
                getMatrix: function() {
                    return utils.clone(this.m)
                },
                getTranslate: function() {
                    var m = this.m;
                    return {
                        x: m.e / m.a,
                        y: m.f / m.d
                    }
                },
                mergeMatrix: function(matrix) {
                    return new Matrix(mergeMatrixData(this.m, matrix.m))
                },
                merge: function(matrix) {
                    return this.mergeMatrix(matrix)
                },
                toString: function() {
                    return this.valueOf().join(" ")
                },
                valueOf: function() {
                    var m = this.m;
                    return [m.a, m.b, m.c, m.d, m.e, m.f]
                },
                equals: function(matrix) {
                    var m1 = this.m
                      , m2 = matrix.m;
                    return m1.a == m2.a && m1.b == m2.b && m1.c == m2.c && m1.d == m2.d && m1.e == m2.e && m1.f == m2.f
                },
                transformPoint: function() {
                    return Matrix.transformPoint.apply(null, [].slice.call(arguments).concat([this.m]))
                },
                transformBox: function(box) {
                    return Matrix.transformBox(box, this.m)
                },
                clone: function() {
                    return new Matrix(this.m)
                }
            });
            return Matrix.parse = function(str) {
                var match, f = parseFloat;
                if (str instanceof Array)
                    return new Matrix({
                        a: str[0],
                        b: str[1],
                        c: str[2],
                        d: str[3],
                        e: str[4],
                        f: str[5]
                    });
                if (match = mPattern.exec(str)) {
                    var values = match[1].split(",");
                    return 6 != values.length && (values = match[1].split(" ")),
                    new Matrix({
                        a: f(values[0]),
                        b: f(values[1]),
                        c: f(values[2]),
                        d: f(values[3]),
                        e: f(values[4]),
                        f: f(values[5])
                    })
                }
                return new Matrix
            }
            ,
            Matrix.transformPoint = function(x, y, m) {
                return 2 === arguments.length && (m = y,
                y = x.y,
                x = x.x),
                new Point(m.a * x + m.c * y + m.e,m.b * x + m.d * y + m.f)
            }
            ,
            Matrix.transformBox = function(box, matrix) {
                for (var bp, rp, xMin = Number.MAX_VALUE, xMax = -Number.MAX_VALUE, yMin = Number.MAX_VALUE, yMax = -Number.MAX_VALUE, bps = [[box.x, box.y], [box.x + box.width, box.y], [box.x, box.y + box.height], [box.x + box.width, box.y + box.height]], rps = []; bp = bps.pop(); )
                    rp = Matrix.transformPoint(bp[0], bp[1], matrix),
                    rps.push(rp),
                    xMin = Math.min(xMin, rp.x),
                    xMax = Math.max(xMax, rp.x),
                    yMin = Math.min(yMin, rp.y),
                    yMax = Math.max(yMax, rp.y);
                return box = new Box({
                    x: xMin,
                    y: yMin,
                    width: xMax - xMin,
                    height: yMax - yMin
                }),
                utils.extend(box, {
                    closurePoints: rps
                }),
                box
            }
            ,
            Matrix.getCTM = function(target, refer) {
                function getTransformToElement(target, source) {
                    var matrix;
                    try {
                        matrix = source.getScreenCTM().inverse()
                    } catch (e) {
                        throw new Error("Can not inverse source element' ctm.")
                    }
                    return matrix.multiply(target.getScreenCTM())
                }
                var ctm = {
                    a: 1,
                    b: 0,
                    c: 0,
                    d: 1,
                    e: 0,
                    f: 0
                }
                  , node = target.shapeNode || target.node;
                switch (refer = refer || "parent") {
                case "screen":
                    ctm = node.getScreenCTM();
                    break;
                case "doc":
                case "paper":
                    ctm = node.getCTM();
                    break;
                case "view":
                case "top":
                    target.getPaper() && (ctm = void 0 !== node.getTransformToElement ? node.getTransformToElement(target.getPaper().shapeNode) : getTransformToElement(node, target.getPaper().shapeNode));
                    break;
                case "parent":
                    target.node.parentNode && (ctm = void 0 !== node.getTransformToElement ? node.getTransformToElement(target.node.parentNode) : getTransformToElement(node, target.node.parentNode));
                    break;
                default:
                    refer.node && (ctm = void 0 !== node.getTransformToElement ? node.getTransformToElement(refer.shapeNode || refer.node) : getTransformToElement(node, refer.shapeNode || refer.node))
                }
                return ctm ? new Matrix(ctm.a,ctm.b,ctm.c,ctm.d,ctm.e,ctm.f) : new Matrix
            }
            ,
            Matrix
        }
    },
    _p[44] = {
        value: function(require, exports, module) {
            var StandardColor = _p.r(64)
              , Color = _p.r(28)
              , Utils = _p.r(12)
              , Palette = _p.r(11).createClass("Palette", {
                constructor: function() {
                    this.color = {}
                },
                get: function(name) {
                    var colorValue = this.color[name] || StandardColor.EXTEND_STANDARD[name] || StandardColor.COLOR_STANDARD[name] || "";
                    return colorValue ? new Color(colorValue) : null
                },
                getColorValue: function(name) {
                    return this.color[name] || StandardColor.EXTEND_STANDARD[name] || StandardColor.COLOR_STANDARD[name] || ""
                },
                add: function(name, value) {
                    return this.color[name] = "string" == typeof value ? new Color(value).toRGBA() : value.toRGBA(),
                    value
                },
                remove: function(name) {
                    return !!this.color.hasOwnProperty(name) && (delete this.color[name],
                    !0)
                }
            });
            return Utils.extend(Palette, {
                getColor: function(name) {
                    var colorValue = StandardColor.EXTEND_STANDARD[name] || StandardColor.COLOR_STANDARD[name];
                    return colorValue ? new Color(colorValue) : null
                },
                getColorValue: function(name) {
                    return StandardColor.EXTEND_STANDARD[name] || StandardColor.COLOR_STANDARD[name] || ""
                },
                addColor: function(name, value) {
                    return StandardColor.EXTEND_STANDARD[name] = "string" == typeof value ? new Color(value).toRGBA() : value.toRGBA(),
                    value
                },
                removeColor: function(name) {
                    return !!StandardColor.EXTEND_STANDARD.hasOwnProperty(name) && (delete StandardColor.EXTEND_STANDARD[name],
                    !0)
                }
            }),
            Palette
        }
    },
    _p[45] = {
        value: function(require, exports, module) {
            var Class = _p.r(11)
              , utils = _p.r(12)
              , svg = _p.r(67)
              , Container = _p.r(29)
              , ShapeContainer = _p.r(61)
              , ViewBox = _p.r(75)
              , EventHandler = _p.r(33)
              , Styled = _p.r(66)
              , Matrix = _p.r(43)
              , Paper = Class.createClass("Paper", {
                mixins: [ShapeContainer, EventHandler, Styled, ViewBox],
                constructor: function(container) {
                    this.callBase(),
                    this.node = this.createSVGNode(),
                    this.node.paper = this,
                    this.node.appendChild(this.resourceNode = svg.createNode("defs")),
                    this.node.appendChild(this.shapeNode = svg.createNode("g")),
                    this.resources = new Container,
                    this.setWidth("100%").setHeight("100%"),
                    container && this.renderTo(container),
                    this.callMixin()
                },
                renderTo: function(container) {
                    utils.isString(container) && (container = document.getElementById(container)),
                    this.container = container,
                    container.appendChild(this.node)
                },
                createSVGNode: function() {
                    var node = svg.createNode("svg");
                    return node.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
                    node.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"),
                    node.setAttribute("version", "1.1"),
                    node
                },
                getNode: function() {
                    return this.node
                },
                getContainer: function() {
                    return this.container
                },
                getWidth: function() {
                    return this.node.clientWidth
                },
                setWidth: function(width) {
                    return this.node.setAttribute("width", width),
                    this
                },
                getHeight: function() {
                    return this.node.clientHeight
                },
                setHeight: function(height) {
                    return this.node.setAttribute("height", height),
                    this
                },
                setViewPort: function(cx, cy, zoom) {
                    var viewport, box;
                    1 == arguments.length && (viewport = arguments[0],
                    cx = viewport.center.x,
                    cy = viewport.center.y,
                    zoom = viewport.zoom),
                    zoom = zoom || 1,
                    box = this.getViewBox();
                    var matrix = new Matrix
                      , dx = box.x + box.width / 2 - cx
                      , dy = box.y + box.height / 2 - cy;
                    return matrix.translate(-cx, -cy),
                    matrix.scale(zoom),
                    matrix.translate(cx, cy),
                    matrix.translate(dx, dy),
                    this.shapeNode.setAttribute("transform", "matrix(" + matrix + ")"),
                    this.viewport = {
                        center: {
                            x: cx,
                            y: cy
                        },
                        offset: {
                            x: dx,
                            y: dy
                        },
                        zoom: zoom
                    },
                    this
                },
                getViewPort: function() {
                    if (!this.viewport) {
                        var box = this.getViewBox();
                        return {
                            zoom: 1,
                            center: {
                                x: box.x + box.width / 2,
                                y: box.y + box.height / 2
                            },
                            offset: {
                                x: 0,
                                y: 0
                            }
                        }
                    }
                    return this.viewport
                },
                getViewPortMatrix: function() {
                    return Matrix.parse(this.shapeNode.getAttribute("transform"))
                },
                getViewPortTransform: function() {
                    var m = this.shapeNode.getCTM();
                    return new Matrix(m.a,m.b,m.c,m.d,m.e,m.f)
                },
                getTransform: function() {
                    return this.getViewPortTransform().reverse()
                },
                addResource: function(resource) {
                    return this.resources.appendItem(resource),
                    resource.node && this.resourceNode.appendChild(resource.node),
                    this
                },
                removeResource: function(resource) {
                    return resource.remove && resource.remove(),
                    resource.node && this.resourceNode.removeChild(resource.node),
                    this
                },
                getPaper: function() {
                    return this
                }
            })
              , Shape = _p.r(60);
            return Class.extendClass(Shape, {
                getPaper: function() {
                    for (var parent = this.container; parent && parent instanceof Paper == !1; )
                        parent = parent.container;
                    return parent
                },
                isAttached: function() {
                    return !!this.getPaper()
                },
                whenPaperReady: function(fn) {
                    function check() {
                        var paper = me.getPaper();
                        return paper && fn && fn.call(me, paper),
                        paper
                    }
                    var me = this;
                    return check() || this.on("add treeadd", function listen() {
                        check() && (me.off("add", listen),
                        me.off("treeadd", listen))
                    }),
                    this
                }
            }),
            Paper
        }
    },
    _p[46] = {
        value: function(require, exports, module) {
            var Utils = _p.r(12)
              , createClass = _p.r(11).createClass
              , Shape = _p.r(60)
              , svg = _p.r(67)
              , g = _p.r(34)
              , slice = Array.prototype.slice
              , PathDrawer = (Utils.flatten,
            createClass("PathDrawer", {
                constructor: function(path) {
                    this.segment = [],
                    this.path = path,
                    this.__clear = !1
                },
                getPath: function() {
                    return this.path
                },
                redraw: function() {
                    return this._transation = this._transation || [],
                    this.clear()
                },
                done: function() {
                    var transation = this._transation;
                    return this._transation = null,
                    this.push(transation),
                    this
                },
                clear: function() {
                    return this._transation ? this._transation = [] : this.path.setPathData("M 0 0"),
                    this._clear = !0,
                    this
                },
                push: function() {
                    var originData, segment = slice.call(arguments);
                    return this._transation ? (this._transation.push(segment),
                    this) : (this._clear ? (originData = "",
                    this._clear = !1) : originData = this.path.getPathData(),
                    originData = originData || "",
                    this.path.setPathData(originData + g.pathToString(segment)),
                    this)
                },
                moveTo: function(x, y) {
                    return this.push("M", slice.call(arguments))
                },
                moveBy: function(dx, dy) {
                    return this.push("m", slice.call(arguments))
                },
                lineTo: function(x, y) {
                    return this.push("L", slice.call(arguments))
                },
                lineBy: function(dx, dy) {
                    return this.push("l", slice.call(arguments))
                },
                arcTo: function(rx, ry, xr, laf, sf, x, y) {
                    return this.push("A", slice.call(arguments))
                },
                arcBy: function(rx, ry, xr, laf, sf, dx, dy) {
                    return this.push("a", arguments)
                },
                carcTo: function(r, laf, sf, x, y) {
                    return this.push("A", [r, r, 0].concat(slice.call(arguments, 1)))
                },
                carcBy: function(r, laf, sf, dx, dy) {
                    return this.push("a", [r, r, 0].concat(slice.call(arguments, 1)))
                },
                bezierTo: function(x1, y1, x2, y2, x, y) {
                    return this.push("C", slice.call(arguments))
                },
                bezierBy: function(dx1, dy1, dx2, dy2, dx, dy) {
                    return this.push("c", slice.call(arguments))
                },
                close: function() {
                    return this.push("z")
                }
            }));
            return createClass("Path", {
                base: Shape,
                constructor: function(data) {
                    this.callBase("path"),
                    data && this.setPathData(data),
                    this.node.setAttribute("fill", svg.defaults.fill),
                    this.node.setAttribute("stroke", svg.defaults.stroke)
                },
                setPathData: function(data) {
                    return data = data || "M0,0",
                    this.pathdata = g.pathToString(data),
                    this.node.setAttribute("d", this.pathdata),
                    this.trigger("shapeupdate", {
                        type: "pathdata"
                    }),
                    this
                },
                getPathData: function() {
                    return this.pathdata || ""
                },
                getDrawer: function() {
                    return new PathDrawer(this)
                },
                isClosed: function() {
                    var data = this.getPathData();
                    return !!~data.indexOf("z") || !!~data.indexOf("Z")
                }
            })
        }
    },
    _p[47] = {
        value: function(require, exports, module) {
            var Resource = _p.r(58)
              , ShapeContainer = _p.r(61);
            _p.r(67);
            return _p.r(11).createClass("PatternBrush", {
                base: Resource,
                mixins: [ShapeContainer],
                constructor: function(paper) {
                    this.callBase("pattern", paper),
                    this.node.setAttribute("patternUnits", "userSpaceOnUse")
                },
                setX: function(x) {
                    return this.x = x,
                    this.node.setAttribute("x", x),
                    this
                },
                setY: function(y) {
                    return this.y = y,
                    this.node.setAttribute("y", y),
                    this
                },
                setWidth: function(width) {
                    return this.width = width,
                    this.node.setAttribute("width", width),
                    this
                },
                setHeight: function(height) {
                    return this.height = height,
                    this.node.setAttribute("height", height),
                    this
                },
                getWidth: function() {
                    return this.width
                },
                getHeight: function() {
                    return this.height
                }
            })
        }
    },
    _p[48] = {
        value: function(require, exports, module) {
            var Color = _p.r(28);
            return _p.r(11).createClass("Pen", {
                constructor: function(brush, width) {
                    this.brush = brush,
                    this.width = width || 1,
                    this.linecap = null,
                    this.linejoin = null,
                    this.dashArray = null,
                    this.opacity = 1
                },
                getBrush: function() {
                    return this.brush
                },
                setBrush: function(brush) {
                    return this.brush = brush,
                    this
                },
                setColor: function(color) {
                    return this.setBrush(color)
                },
                getColor: function() {
                    return this.brush instanceof Color ? this.brush : null
                },
                getWidth: function() {
                    return this.width
                },
                setWidth: function(width) {
                    return this.width = width,
                    this
                },
                getOpacity: function() {
                    return this.opacity
                },
                setOpacity: function(opacity) {
                    this.opacity = opacity
                },
                getLineCap: function() {
                    return this.linecap
                },
                setLineCap: function(linecap) {
                    return this.linecap = linecap,
                    this
                },
                getLineJoin: function() {
                    return this.linejoin
                },
                setLineJoin: function(linejoin) {
                    return this.linejoin = linejoin,
                    this
                },
                getDashArray: function() {
                    return this.dashArray
                },
                setDashArray: function(dashArray) {
                    return this.dashArray = dashArray,
                    this
                },
                stroke: function(shape) {
                    var node = shape.node;
                    node.setAttribute("stroke", this.brush.toString()),
                    node.setAttribute("stroke-width", this.getWidth()),
                    this.getOpacity() < 1 && node.setAttribute("stroke-opacity", this.getOpacity()),
                    this.getLineCap() && node.setAttribute("stroke-linecap", this.getLineCap()),
                    this.getLineJoin() && node.setAttribute("stroke-linejoin", this.getLineJoin()),
                    this.getDashArray() && node.setAttribute("stroke-dasharray", this.getDashArray())
                }
            })
        }
    },
    _p[49] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass({
                base: _p.r(68),
                constructor: function(radius, angle, angleOffset) {
                    this.callBase([0, radius], angle, angleOffset)
                },
                getRadius: function() {
                    return this.getSectionArray()[1]
                },
                setRadius: function(radius) {
                    this.setSectionArray([0, radius])
                }
            })
        }
    },
    _p[50] = {
        value: function(require, exports, module) {
            var Point = _p.r(11).createClass("Point", {
                constructor: function(x, y) {
                    this.x = x || 0,
                    this.y = y || 0
                },
                offset: function(dx, dy) {
                    return 1 == arguments.length && (dy = dx.y,
                    dx = dx.x),
                    new Point(this.x + dx,this.y + dy)
                },
                valueOf: function() {
                    return [this.x, this.y]
                },
                toString: function() {
                    return this.valueOf().join(" ")
                },
                spof: function() {
                    return new Point(.5 + (0 | this.x),.5 + (0 | this.y))
                },
                round: function() {
                    return new Point(0 | this.x,0 | this.y)
                },
                isOrigin: function() {
                    return 0 === this.x && 0 === this.y
                }
            });
            return Point.fromPolar = function(radius, angle, unit) {
                return "rad" != unit && (angle = angle / 180 * Math.PI),
                new Point(radius * Math.cos(angle),radius * Math.sin(angle))
            }
            ,
            Point.parse = function(unknown) {
                return unknown ? unknown instanceof Point ? unknown : "string" == typeof unknown ? Point.parse(unknown.split(/\s*[\s,]\s*/)) : "0"in unknown && "1"in unknown ? new Point(unknown[0],unknown[1]) : void 0 : new Point
            }
            ,
            Point
        }
    },
    _p[51] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("PointContainer", {
                base: _p.r(29),
                constructor: function() {
                    this.callBase()
                },
                addPoint: function(point, pos) {
                    return this.addItem.apply(this, arguments)
                },
                prependPoint: function() {
                    return this.prependItem.apply(this, arguments)
                },
                appendPoint: function() {
                    return this.appendItem.apply(this, arguments)
                },
                removePoint: function(pos) {
                    return this.removeItem.apply(this, arguments)
                },
                addPoints: function() {
                    return this.addItems.apply(this, arguments)
                },
                setPoints: function() {
                    return this.setItems.apply(this, arguments)
                },
                getPoint: function() {
                    return this.getItem.apply(this, arguments)
                },
                getPoints: function() {
                    return this.getItems.apply(this, arguments)
                },
                getFirstPoint: function() {
                    return this.getFirstItem.apply(this, arguments)
                },
                getLastPoint: function() {
                    return this.getLastItem.apply(this, arguments)
                }
            })
        }
    },
    _p[52] = {
        value: function(require, exports, module) {
            _p.r(12);
            return _p.r(11).createClass("Poly", {
                base: _p.r(46),
                mixins: [_p.r(51)],
                constructor: function(points, closeable) {
                    this.callBase(),
                    this.closeable = !!closeable,
                    this.setPoints(points || []),
                    this.changeable = !0,
                    this.update()
                },
                onContainerChanged: function() {
                    this.changeable && this.update()
                },
                update: function() {
                    var drawer = this.getDrawer()
                      , points = this.getPoints();
                    if (drawer.clear(),
                    !points.length)
                        return this;
                    drawer.moveTo(points[0]);
                    for (var point, i = 1, len = points.length; i < len; i++)
                        point = points[i],
                        drawer.lineTo(point);
                    return this.closeable && points.length > 2 && drawer.close(),
                    this
                }
            })
        }
    },
    _p[53] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("Polygon", {
                base: _p.r(52),
                constructor: function(points) {
                    this.callBase(points, !0)
                }
            })
        }
    },
    _p[54] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("Polyline", {
                base: _p.r(52),
                constructor: function(points) {
                    this.callBase(points)
                }
            })
        }
    },
    _p[55] = {
        value: function(require, exports, module) {
            var Gradient = _p.r(35);
            return _p.r(11).createClass("RadialGradientBrush", {
                base: Gradient,
                constructor: function(paper) {
                    this.callBase("radialGradient", paper),
                    this.setCenter(.5, .5),
                    this.setFocal(.5, .5),
                    this.setRadius(.5)
                },
                setCenter: function(cx, cy) {
                    return this.node.setAttribute("cx", cx),
                    this.node.setAttribute("cy", cy),
                    this
                },
                getCenter: function() {
                    return {
                        x: +this.node.getAttribute("cx"),
                        y: +this.node.getAttribute("cy")
                    }
                },
                setFocal: function(fx, fy) {
                    return this.node.setAttribute("fx", fx),
                    this.node.setAttribute("fy", fy),
                    this
                },
                getFocal: function() {
                    return {
                        x: +this.node.getAttribute("fx"),
                        y: +this.node.getAttribute("fy")
                    }
                },
                setRadius: function(r) {
                    return this.node.setAttribute("r", r),
                    this
                },
                getRadius: function() {
                    return +this.node.getAttribute("r")
                }
            })
        }
    },
    _p[56] = {
        value: function(require, exports, module) {
            var RectUtils = {}
              , Utils = _p.r(12)
              , Point = _p.r(50)
              , Box = _p.r(25);
            return Utils.extend(RectUtils, {
                formatRadius: function(width, height, radius) {
                    var minValue = Math.floor(Math.min(width / 2, height / 2));
                    return Math.min(minValue, radius)
                }
            }),
            _p.r(11).createClass("Rect", {
                base: _p.r(46),
                constructor: function(width, height, x, y, radius) {
                    this.callBase(),
                    this.x = x || 0,
                    this.y = y || 0,
                    this.width = width || 0,
                    this.height = height || 0,
                    this.radius = RectUtils.formatRadius(this.width, this.height, radius || 0),
                    this.update()
                },
                update: function() {
                    var x = this.x
                      , y = this.y
                      , w = this.width
                      , h = this.height
                      , r = this.radius
                      , drawer = this.getDrawer().redraw();
                    return r ? (w -= 2 * r,
                    h -= 2 * r,
                    drawer.push("M", x + r, y),
                    drawer.push("h", w),
                    drawer.push("a", r, r, 0, 0, 1, r, r),
                    drawer.push("v", h),
                    drawer.push("a", r, r, 0, 0, 1, -r, r),
                    drawer.push("h", -w),
                    drawer.push("a", r, r, 0, 0, 1, -r, -r),
                    drawer.push("v", -h),
                    drawer.push("a", r, r, 0, 0, 1, r, -r),
                    drawer.push("z")) : (drawer.push("M", x, y),
                    drawer.push("h", w),
                    drawer.push("v", h),
                    drawer.push("h", -w),
                    drawer.push("z")),
                    drawer.done(),
                    this
                },
                setWidth: function(width) {
                    return this.width = width,
                    this.update()
                },
                setHeight: function(height) {
                    return this.height = height,
                    this.update()
                },
                setSize: function(width, height) {
                    return this.width = width,
                    this.height = height,
                    this.update()
                },
                setBox: function(box) {
                    return this.x = box.x,
                    this.y = box.y,
                    this.width = box.width,
                    this.height = box.height,
                    this.update()
                },
                getBox: function() {
                    return new Box(this.x,this.y,this.width,this.height)
                },
                getRadius: function() {
                    return this.radius
                },
                setRadius: function(radius) {
                    return this.radius = RectUtils.formatRadius(this.width, this.height, radius || 0),
                    this.update()
                },
                getPosition: function() {
                    return new Point(this.x,this.y)
                },
                setPosition: function(x, y) {
                    if (1 == arguments.length) {
                        var p = Point.parse(arguments[0]);
                        y = p.y,
                        x = p.x
                    }
                    return this.x = x,
                    this.y = y,
                    this.update()
                },
                getWidth: function() {
                    return this.width
                },
                getHeight: function() {
                    return this.height
                },
                getPositionX: function() {
                    return this.x
                },
                getPositionY: function() {
                    return this.y
                },
                setPositionX: function(x) {
                    return this.x = x,
                    this.update()
                },
                setPositionY: function(y) {
                    return this.y = y,
                    this.update()
                }
            })
        }
    },
    _p[57] = {
        value: function(require, exports, module) {
            var Point = _p.r(50);
            return _p.r(11).createClass("RegularPolygon", {
                base: _p.r(46),
                constructor: function(side, radius, x, y) {
                    this.callBase(),
                    this.radius = radius || 0,
                    this.side = Math.max(side || 3, 3),
                    arguments.length > 2 && 3 == arguments.length && (y = x.y,
                    x = x.x),
                    this.center = new Point(x,y),
                    this.draw()
                },
                getSide: function() {
                    return this.side
                },
                setSide: function(side) {
                    return this.side = side,
                    this.draw()
                },
                getRadius: function() {
                    return this.radius
                },
                setRadius: function(radius) {
                    return this.radius = radius,
                    this.draw()
                },
                draw: function() {
                    var i, radius = this.radius, side = this.side, step = 2 * Math.PI / side, drawer = this.getDrawer();
                    for (drawer.clear(),
                    drawer.moveTo(Point.fromPolar(radius, Math.PI / 2, "rad").offset(this.center)),
                    i = 0; i <= side; i++)
                        drawer.lineTo(Point.fromPolar(radius, step * i + Math.PI / 2, "rad").offset(this.center));
                    return drawer.close(),
                    this
                }
            })
        }
    },
    _p[58] = {
        value: function(require, exports, module) {
            var svg = _p.r(67);
            return _p.r(11).createClass("Resource", {
                constructor: function(nodeType, paper) {
                    this.callBase(),
                    this.node = svg.createNode(nodeType),
                    paper && paper.addResource(this)
                },
                toString: function() {
                    return "url(#" + this.node.id + ")"
                }
            })
        }
    },
    _p[59] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass({
                base: _p.r(68),
                constructor: function(innerRadius, outerRadius) {
                    this.callBase([innerRadius, outerRadius], 360, 0)
                },
                getInnerRadius: function() {
                    return this.getSectionArray()[0]
                },
                getOuterRadius: function() {
                    return this.getSectionArray()[1]
                },
                setInnerRadius: function(value) {
                    this.setSectionArray([value, this.getOuterRadius()])
                },
                setOuterRadius: function(value) {
                    this.setSectionArray([this.getInnerRadius(), value])
                }
            })
        }
    },
    _p[60] = {
        value: function(require, exports, module) {
            var svg = _p.r(67)
              , utils = _p.r(12)
              , EventHandler = _p.r(33)
              , Styled = _p.r(66)
              , Data = _p.r(31)
              , Matrix = _p.r(43)
              , slice = (_p.r(48),
            Array.prototype.slice)
              , Box = _p.r(25);
            return _p.r(11).createClass("Shape", {
                mixins: [EventHandler, Styled, Data],
                constructor: function(tagName) {
                    this.node = svg.createNode(tagName),
                    this.node.shape = this,
                    this.transform = {
                        translate: null,
                        rotate: null,
                        scale: null,
                        matrix: null
                    },
                    this.callMixin()
                },
                getId: function() {
                    return this.node.id
                },
                setId: function(id) {
                    return this.node.id = id,
                    this
                },
                getNode: function() {
                    return this.node
                },
                getBoundaryBox: function() {
                    var box;
                    try {
                        box = this.node.getBBox()
                    } catch (e) {
                        box = {
                            x: this.node.clientLeft,
                            y: this.node.clientTop,
                            width: this.node.clientWidth,
                            height: this.node.clientHeight
                        }
                    }
                    return new Box(box)
                },
                getRenderBox: function(refer) {
                    var box = this.getBoundaryBox();
                    return this.getTransform(refer).transformBox(box)
                },
                getWidth: function() {
                    return this.getRenderBox().width
                },
                getHeight: function() {
                    return this.getRenderBox().height
                },
                getSize: function() {
                    var box = this.getRenderBox();
                    return delete box.x,
                    delete box.y,
                    box
                },
                setOpacity: function(value) {
                    return this.node.setAttribute("opacity", value),
                    this
                },
                getOpacity: function() {
                    var opacity = this.node.getAttribute("opacity");
                    return opacity ? +opacity : 1
                },
                setVisible: function(value) {
                    return value ? this.node.removeAttribute("display") : this.node.setAttribute("display", "none"),
                    this
                },
                getVisible: function() {
                    this.node.getAttribute("display")
                },
                hasAncestor: function(node) {
                    for (var parent = this.container; parent; ) {
                        if (parent === node)
                            return !0;
                        parent = parent.container
                    }
                    return !1
                },
                getTransform: function(refer) {
                    return Matrix.getCTM(this, refer)
                },
                clearTransform: function() {
                    return this.node.removeAttribute("transform"),
                    this.transform = {
                        translate: null,
                        rotate: null,
                        scale: null,
                        matrix: null
                    },
                    this.trigger("shapeupdate", {
                        type: "transform"
                    }),
                    this
                },
                _applyTransform: function() {
                    var t = this.transform
                      , result = [];
                    return t.translate && result.push(["translate(", t.translate, ")"]),
                    t.rotate && result.push(["rotate(", t.rotate, ")"]),
                    t.scale && result.push(["scale(", t.scale, ")"]),
                    t.matrix && result.push(["matrix(", t.matrix, ")"]),
                    this.node.setAttribute("transform", utils.flatten(result).join(" ")),
                    this
                },
                setMatrix: function(m) {
                    return this.transform.matrix = m,
                    this._applyTransform()
                },
                setTranslate: function(t) {
                    return this.transform.translate = null !== t && slice.call(arguments) || null,
                    this._applyTransform()
                },
                setRotate: function(r) {
                    return this.transform.rotate = null !== r && slice.call(arguments) || null,
                    this._applyTransform()
                },
                setScale: function(s) {
                    return this.transform.scale = null !== s && slice.call(arguments) || null,
                    this._applyTransform()
                },
                translate: function(dx, dy) {
                    var m = this.transform.matrix || new Matrix;
                    return void 0 === dy && (dy = 0),
                    this.transform.matrix = m.translate(dx, dy),
                    this._applyTransform()
                },
                rotate: function(deg) {
                    var m = this.transform.matrix || new Matrix;
                    return this.transform.matrix = m.rotate(deg),
                    this._applyTransform()
                },
                scale: function(sx, sy) {
                    var m = this.transform.matrix || new Matrix;
                    return void 0 === sy && (sy = sx),
                    this.transform.matrix = m.scale(sx, sy),
                    this._applyTransform()
                },
                skew: function(sx, sy) {
                    var m = this.transform.matrix || new Matrix;
                    return void 0 === sy && (sy = sx),
                    this.transform.matrix = m.skew(sx, sy),
                    this._applyTransform()
                },
                stroke: function(pen, width) {
                    return pen && pen.stroke ? pen.stroke(this) : pen ? (this.node.setAttribute("stroke", pen.toString()),
                    width && this.node.setAttribute("stroke-width", width)) : null === pen && this.node.removeAttribute("stroe"),
                    this
                },
                fill: function(brush) {
                    return brush && this.node.setAttribute("fill", brush.toString()),
                    null === brush && this.node.removeAttribute("fill"),
                    this
                },
                setAttr: function(a, v) {
                    var me = this;
                    return utils.isObject(a) && utils.each(a, function(val, key) {
                        me.setAttr(key, val)
                    }),
                    void 0 === v || null === v || "" === v ? this.node.removeAttribute(a) : this.node.setAttribute(a, v),
                    this
                },
                getAttr: function(a) {
                    return this.node.getAttribute(a)
                }
            })
        }
    },
    _p[61] = {
        value: function(require, exports, module) {
            var Container = _p.r(29)
              , utils = _p.r(12)
              , ShapeContainer = _p.r(11).createClass("ShapeContainer", {
                base: Container,
                isShapeContainer: !0,
                handleAdd: function(shape, index) {
                    var parent = this.getShapeNode();
                    parent.insertBefore(shape.node, parent.childNodes[index] || null),
                    shape.trigger("add", {
                        container: this
                    }),
                    shape.notifyTreeModification && shape.notifyTreeModification("treeadd", this)
                },
                handleRemove: function(shape, index) {
                    this.getShapeNode().removeChild(shape.node),
                    shape.trigger("remove", {
                        container: this
                    }),
                    shape.notifyTreeModification && shape.notifyTreeModification("treeremove", this)
                },
                notifyTreeModification: function(type, container) {
                    this.eachItem(function(index, shape) {
                        shape.notifyTreeModification && shape.notifyTreeModification(type, container),
                        shape.trigger(type, {
                            container: container
                        })
                    })
                },
                getShape: function(index) {
                    return this.getItem(index)
                },
                addShape: function(shape, index) {
                    return this.addItem(shape, index)
                },
                put: function(shape) {
                    return this.addShape(shape),
                    shape
                },
                appendShape: function(shape) {
                    return this.addShape(shape)
                },
                prependShape: function(shape) {
                    return this.addShape(shape, 0)
                },
                replaceShape: function(replacer, origin) {
                    var index = this.indexOf(origin);
                    if (-1 !== index)
                        return this.removeShape(index),
                        this.addShape(replacer, index),
                        this
                },
                addShapeBefore: function(shape, refer) {
                    var index = this.indexOf(refer);
                    return this.addShape(shape, index)
                },
                addShapeAfter: function(shape, refer) {
                    var index = this.indexOf(refer);
                    return this.addShape(shape, -1 === index ? void 0 : index + 1)
                },
                addShapes: function(shapes) {
                    return this.addItems(shapes)
                },
                removeShape: function(index) {
                    return this.removeItem(index)
                },
                getShapes: function() {
                    return this.getItems()
                },
                getShapesByType: function(name) {
                    function getShapes(shape) {
                        name.toLowerCase() == shape.getType().toLowerCase() && shapes.push(shape),
                        shape.isShapeContainer && utils.each(shape.getShapes(), function(n) {
                            getShapes(n)
                        })
                    }
                    var shapes = [];
                    return getShapes(this),
                    shapes
                },
                getShapeById: function(id) {
                    return this.getShapeNode().getElementById(id).shape
                },
                arrangeShape: function(shape, index) {
                    return this.removeShape(shape).addShape(shape, index)
                },
                getShapeNode: function() {
                    return this.shapeNode || this.node
                }
            })
              , Shape = _p.r(60);
            return _p.r(11).extendClass(Shape, {
                bringTo: function(index) {
                    return this.container.arrangeShape(this, index),
                    this
                },
                bringFront: function() {
                    return this.bringTo(this.container.indexOf(this) + 1)
                },
                bringBack: function() {
                    return this.bringTo(this.container.indexOf(this) - 1)
                },
                bringTop: function() {
                    return this.container.removeShape(this).addShape(this),
                    this
                },
                bringRear: function() {
                    return this.bringTo(0)
                },
                bringRefer: function(referShape, offset) {
                    return referShape.container && (this.remove && this.remove(),
                    referShape.container.addShape(this, referShape.container.indexOf(referShape) + (offset || 0))),
                    this
                },
                bringAbove: function(referShape) {
                    return this.bringRefer(referShape)
                },
                bringBelow: function(referShape) {
                    return this.bringRefer(referShape, 1)
                },
                replaceBy: function(newShape) {
                    return this.container && (newShape.bringAbove(this),
                    this.remove()),
                    this
                }
            }),
            ShapeContainer
        }
    },
    _p[62] = {
        value: function(require, exprots, module) {
            var Matrix = _p.r(43)
              , Utils = _p.r(12)
              , Point = _p.r(50);
            return _p.r(11).createClass("ShapeEvent", {
                constructor: function(event) {
                    var target = null;
                    Utils.isObject(event.target) ? Utils.extend(this, event) : (this.type = event.type,
                    target = event.target,
                    target.correspondingUseElement && (target = target.correspondingUseElement),
                    this.originEvent = event,
                    this.targetShape = target.shape || target.paper || event.currentTarget && (event.currentTarget.shape || event.currentTarget.paper),
                    event._kityParam && Utils.extend(this, event._kityParam))
                },
                preventDefault: function() {
                    var evt = this.originEvent;
                    return !evt || (evt.preventDefault ? (evt.preventDefault(),
                    evt.cancelable) : (evt.returnValue = !1,
                    !0))
                },
                getPosition: function(refer, touchIndex) {
                    if (!this.originEvent)
                        return null;
                    var eventClient = this.originEvent.touches ? this.originEvent.touches[touchIndex || 0] : this.originEvent
                      , target = this.targetShape
                      , targetNode = target.shapeNode || target.node
                      , pScreen = new Point(eventClient && eventClient.clientX || 0,eventClient && eventClient.clientY || 0)
                      , pTarget = Matrix.transformPoint(pScreen, targetNode.getScreenCTM().inverse());
                    return Matrix.getCTM(target, refer || "view").transformPoint(pTarget)
                },
                stopPropagation: function() {
                    var evt = this.originEvent;
                    if (!evt)
                        return !0;
                    evt.stopPropagation ? evt.stopPropagation() : evt.cancelBubble = !1
                }
            })
        }
    },
    _p[63] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("ShapePoint", {
                base: _p.r(50),
                constructor: function(px, py) {
                    this.callBase(px, py)
                },
                setX: function(x) {
                    return this.setPoint(x, this.y)
                },
                setY: function(y) {
                    return this.setPoint(this.x, y)
                },
                setPoint: function(x, y) {
                    return this.x = x,
                    this.y = y,
                    this.update(),
                    this
                },
                getPoint: function() {
                    return this
                },
                update: function() {
                    return this.container && this.container.update && this.container.update(),
                    this
                }
            })
        }
    },
    _p[64] = {
        value: {
            COLOR_STANDARD: {
                aliceblue: "#f0f8ff",
                antiquewhite: "#faebd7",
                aqua: "#00ffff",
                aquamarine: "#7fffd4",
                azure: "#f0ffff",
                beige: "#f5f5dc",
                bisque: "#ffe4c4",
                black: "#000000",
                blanchedalmond: "#ffebcd",
                blue: "#0000ff",
                blueviolet: "#8a2be2",
                brown: "#a52a2a",
                burlywood: "#deb887",
                cadetblue: "#5f9ea0",
                chartreuse: "#7fff00",
                chocolate: "#d2691e",
                coral: "#ff7f50",
                cornflowerblue: "#6495ed",
                cornsilk: "#fff8dc",
                crimson: "#dc143c",
                cyan: "#00ffff",
                darkblue: "#00008b",
                darkcyan: "#008b8b",
                darkgoldenrod: "#b8860b",
                darkgray: "#a9a9a9",
                darkgreen: "#006400",
                darkgrey: "#a9a9a9",
                darkkhaki: "#bdb76b",
                darkmagenta: "#8b008b",
                darkolivegreen: "#556b2f",
                darkorange: "#ff8c00",
                darkorchid: "#9932cc",
                darkred: "#8b0000",
                darksalmon: "#e9967a",
                darkseagreen: "#8fbc8f",
                darkslateblue: "#483d8b",
                darkslategray: "#2f4f4f",
                darkslategrey: "#2f4f4f",
                darkturquoise: "#00ced1",
                darkviolet: "#9400d3",
                deeppink: "#ff1493",
                deepskyblue: "#00bfff",
                dimgray: "#696969",
                dimgrey: "#696969",
                dodgerblue: "#1e90ff",
                firebrick: "#b22222",
                floralwhite: "#fffaf0",
                forestgreen: "#228b22",
                fuchsia: "#ff00ff",
                gainsboro: "#dcdcdc",
                ghostwhite: "#f8f8ff",
                gold: "#ffd700",
                goldenrod: "#daa520",
                gray: "#808080",
                green: "#008000",
                greenyellow: "#adff2f",
                grey: "#808080",
                honeydew: "#f0fff0",
                hotpink: "#ff69b4",
                indianred: "#cd5c5c",
                indigo: "#4b0082",
                ivory: "#fffff0",
                khaki: "#f0e68c",
                lavender: "#e6e6fa",
                lavenderblush: "#fff0f5",
                lawngreen: "#7cfc00",
                lemonchiffon: "#fffacd",
                lightblue: "#add8e6",
                lightcoral: "#f08080",
                lightcyan: "#e0ffff",
                lightgoldenrodyellow: "#fafad2",
                lightgray: "#d3d3d3",
                lightgreen: "#90ee90",
                lightgrey: "#d3d3d3",
                lightpink: "#ffb6c1",
                lightsalmon: "#ffa07a",
                lightseagreen: "#20b2aa",
                lightskyblue: "#87cefa",
                lightslategray: "#778899",
                lightslategrey: "#778899",
                lightsteelblue: "#b0c4de",
                lightyellow: "#ffffe0",
                lime: "#00ff00",
                limegreen: "#32cd32",
                linen: "#faf0e6",
                magenta: "#ff00ff",
                maroon: "#800000",
                mediumaquamarine: "#66cdaa",
                mediumblue: "#0000cd",
                mediumorchid: "#ba55d3",
                mediumpurple: "#9370db",
                mediumseagreen: "#3cb371",
                mediumslateblue: "#7b68ee",
                mediumspringgreen: "#00fa9a",
                mediumturquoise: "#48d1cc",
                mediumvioletred: "#c71585",
                midnightblue: "#191970",
                mintcream: "#f5fffa",
                mistyrose: "#ffe4e1",
                moccasin: "#ffe4b5",
                navajowhite: "#ffdead",
                navy: "#000080",
                oldlace: "#fdf5e6",
                olive: "#808000",
                olivedrab: "#6b8e23",
                orange: "#ffa500",
                orangered: "#ff4500",
                orchid: "#da70d6",
                palegoldenrod: "#eee8aa",
                palegreen: "#98fb98",
                paleturquoise: "#afeeee",
                palevioletred: "#db7093",
                papayawhip: "#ffefd5",
                peachpuff: "#ffdab9",
                peru: "#cd853f",
                pink: "#ffc0cb",
                plum: "#dda0dd",
                powderblue: "#b0e0e6",
                purple: "#800080",
                red: "#ff0000",
                rosybrown: "#bc8f8f",
                royalblue: "#4169e1",
                saddlebrown: "#8b4513",
                salmon: "#fa8072",
                sandybrown: "#f4a460",
                seagreen: "#2e8b57",
                seashell: "#fff5ee",
                sienna: "#a0522d",
                silver: "#c0c0c0",
                skyblue: "#87ceeb",
                slateblue: "#6a5acd",
                slategray: "#708090",
                slategrey: "#708090",
                snow: "#fffafa",
                springgreen: "#00ff7f",
                steelblue: "#4682b4",
                tan: "#d2b48c",
                teal: "#008080",
                thistle: "#d8bfd8",
                tomato: "#ff6347",
                turquoise: "#40e0d0",
                violet: "#ee82ee",
                wheat: "#f5deb3",
                white: "#ffffff",
                whitesmoke: "#f5f5f5",
                yellow: "#ffff00"
            },
            EXTEND_STANDARD: {}
        }
    },
    _p[65] = {
        value: function(require, exports, module) {
            var defaultRatioForStar = {
                3: .2,
                5: .38196601125,
                6: .57735026919,
                8: .541196100146,
                10: .726542528005,
                12: .707106781187
            }
              , Point = _p.r(50);
            return _p.r(11).createClass("Star", {
                base: _p.r(46),
                constructor: function(vertex, radius, shrink, offset, angleOffset) {
                    this.callBase(),
                    this.vertex = vertex || 3,
                    this.radius = radius || 0,
                    this.shrink = shrink,
                    this.offset = offset || new Point(0,0),
                    this.angleOffset = angleOffset || 0,
                    this.draw()
                },
                getVertex: function() {
                    return this.vertex
                },
                setVertex: function(value) {
                    return this.vertex = value,
                    this.draw()
                },
                getRadius: function() {
                    return this.radius
                },
                setRadius: function(value) {
                    return this.radius = value,
                    this.draw()
                },
                getShrink: function() {
                    return this.shrink
                },
                setShrink: function(value) {
                    return this.shrink = value,
                    this.draw()
                },
                getOffset: function() {
                    return this.offset
                },
                setOffset: function(value) {
                    return this.offset = value,
                    this.draw()
                },
                getAngleOffset: function() {
                    return this.angleOffset
                },
                setAngleOffset: function(value) {
                    return this.angleOffset = value,
                    this.draw()
                },
                draw: function() {
                    var i, angle, innerRadius = this.radius, outerRadius = this.radius * (this.shrink || defaultRatioForStar[this.vertex] || .5), vertex = this.vertex, offset = this.offset, angleStep = 180 / vertex, angleOffset = this.angleOffset, drawer = this.getDrawer();
                    for (drawer.clear(),
                    drawer.moveTo(Point.fromPolar(outerRadius, 90)),
                    i = 1; i <= 2 * vertex; i++)
                        angle = 90 + angleStep * i,
                        i % 2 ? drawer.lineTo(Point.fromPolar(innerRadius, angle + angleOffset).offset(offset)) : drawer.lineTo(Point.fromPolar(outerRadius, angle));
                    drawer.close()
                }
            })
        }
    },
    _p[66] = {
        value: function(require, exports, module) {
            function getClassList(node) {
                return node.classList || (node.classList = new ClassList(node)),
                node.classList
            }
            var ClassList = _p.r(11).createClass("ClassList", {
                constructor: function(node) {
                    this._node = node,
                    this._list = node.className.toString().split(" ")
                },
                _update: function() {
                    this._node.className = this._list.join(" ")
                },
                add: function(name) {
                    this._list.push(name),
                    this._update()
                },
                remove: function(name) {
                    var index = this._list.indexOf(name);
                    ~index && this._list.splice(index, 1),
                    this._update()
                },
                contains: function(name) {
                    return !!~this._list.indexOf(name)
                }
            });
            return _p.r(11).createClass("Styled", {
                addClass: function(name) {
                    return getClassList(this.node).add(name),
                    this
                },
                removeClass: function(name) {
                    return getClassList(this.node).remove(name),
                    this
                },
                hasClass: function(name) {
                    return getClassList(this.node).contains(name)
                },
                setStyle: function(styles) {
                    if (2 == arguments.length)
                        return this.node.style[arguments[0]] = arguments[1],
                        this;
                    for (var name in styles)
                        styles.hasOwnProperty(name) && (this.node.style[name] = styles[name]);
                    return this
                }
            })
        }
    },
    _p[67] = {
        value: function(require, exports, module) {
            var doc = document
              , id = 0
              , svg = {
                createNode: function(name) {
                    var node = doc.createElementNS(svg.ns, name);
                    return node.id = "kity_" + name + "_" + id++,
                    node
                },
                defaults: {
                    stroke: "none",
                    fill: "none"
                },
                xlink: "http://www.w3.org/1999/xlink",
                ns: "http://www.w3.org/2000/svg"
            };
            return svg
        }
    },
    _p[68] = {
        value: function(require, exports, module) {
            var Point = _p.r(50);
            return _p.r(11).createClass("Sweep", {
                base: _p.r(46),
                constructor: function(sectionArray, angle, angleOffset) {
                    this.callBase(),
                    this.sectionArray = sectionArray || [],
                    this.angle = angle || 0,
                    this.angleOffset = angleOffset || 0,
                    this.draw()
                },
                getSectionArray: function() {
                    return this.sectionArray
                },
                setSectionArray: function(value) {
                    return this.sectionArray = value,
                    this.draw()
                },
                getAngle: function() {
                    return this.angle
                },
                setAngle: function(value) {
                    return this.angle = value,
                    this.draw()
                },
                getAngleOffset: function() {
                    return this.angleOffset
                },
                setAngleOffset: function(value) {
                    return this.angleOffset = value,
                    this.draw()
                },
                draw: function() {
                    var i, sectionArray = this.sectionArray;
                    for (i = 0; i < sectionArray.length; i += 2)
                        this.drawSection(sectionArray[i], sectionArray[i + 1]);
                    return this
                },
                drawSection: function(from, to) {
                    var angleLength = this.angle && (this.angle % 360 ? this.angle % 360 : 360)
                      , angleStart = this.angleOffset
                      , angleHalf = angleStart + angleLength / 2
                      , angleEnd = angleStart + angleLength
                      , sweepFlag = angleLength < 0 ? 0 : 1
                      , drawer = this.getDrawer();
                    if (drawer.redraw(),
                    0 === angleLength)
                        return void drawer.done();
                    drawer.moveTo(Point.fromPolar(from, angleStart)),
                    drawer.lineTo(Point.fromPolar(to, angleStart)),
                    to && (drawer.carcTo(to, 0, sweepFlag, Point.fromPolar(to, angleHalf)),
                    drawer.carcTo(to, 0, sweepFlag, Point.fromPolar(to, angleEnd))),
                    drawer.lineTo(Point.fromPolar(from, angleEnd)),
                    from && (drawer.carcTo(from, 0, sweepFlag, Point.fromPolar(from, angleHalf)),
                    drawer.carcTo(from, 0, sweepFlag, Point.fromPolar(from, angleStart))),
                    drawer.close(),
                    drawer.done()
                }
            })
        }
    },
    _p[69] = {
        value: function(require, exports, module) {
            function getTextBoundOffset(text) {
                var font = text._cachedFontHash;
                if (offsetHash[font])
                    return offsetHash[font];
                var textContent = text.getContent();
                text.setContent("Fex");
                var bbox = text.getBoundaryBox()
                  , y = text.getY();
                if (!bbox.height)
                    return {
                        top: 0,
                        bottom: 0,
                        middle: 0
                    };
                var topOffset = y - bbox.y + +text.node.getAttribute("dy")
                  , bottomOffset = topOffset - bbox.height;
                return text.setContent(textContent),
                offsetHash[font] = {
                    top: topOffset,
                    bottom: bottomOffset,
                    middle: (topOffset + bottomOffset) / 2
                }
            }
            var TextContent = _p.r(70)
              , ShapeContainer = _p.r(61)
              , svg = _p.r(67)
              , utils = _p.r(12)
              , offsetHash = {};
            return _p.r(11).createClass("Text", {
                base: TextContent,
                mixins: [ShapeContainer],
                constructor: function(content) {
                    this.callBase("text"),
                    void 0 !== content && this.setContent(content),
                    this._buildFontHash()
                },
                fixPosition: function() {
                    this.__fixedPosition || this.setVerticalAlign(this.getVerticalAlign())
                },
                _buildFontHash: function() {
                    var style = window.getComputedStyle(this.node);
                    this._cachedFontHash = [style.fontFamily, style.fontSize, style.fontStretch, style.fontStyle, style.fontVariant, style.fontWeight].join("-")
                },
                _fontChanged: function(font) {
                    var last = this._lastFont
                      , current = utils.extend({}, last, font);
                    if (!last)
                        return this._lastFont = font,
                        !0;
                    var changed = last.family != current.family || last.size != current.size || last.style != current.style || last.weight != current.weight;
                    return this._lastFont = current,
                    changed
                },
                setX: function(x) {
                    return this.node.setAttribute("x", x),
                    this
                },
                setPosition: function(x, y) {
                    return this.setX(x).setY(y)
                },
                setY: function(y) {
                    return this.node.setAttribute("y", y),
                    this
                },
                getX: function() {
                    return +this.node.getAttribute("x") || 0
                },
                getY: function() {
                    return +this.node.getAttribute("y") || 0
                },
                setFont: function(font) {
                    return this.callBase(font),
                    this._fontChanged(font) && (this._buildFontHash(),
                    this.setVerticalAlign(this.getVerticalAlign())),
                    this
                },
                setTextAnchor: function(anchor) {
                    return this.node.setAttribute("text-anchor", anchor),
                    this
                },
                getTextAnchor: function() {
                    return this.node.getAttribute("text-anchor") || "start"
                },
                setVerticalAlign: function(align) {
                    return this.whenPaperReady(function() {
                        var dy;
                        switch (align) {
                        case "top":
                            dy = getTextBoundOffset(this).top;
                            break;
                        case "bottom":
                            dy = getTextBoundOffset(this).bottom;
                            break;
                        case "middle":
                            dy = getTextBoundOffset(this).middle;
                            break;
                        default:
                            dy = 0
                        }
                        dy && (this.__fixedPosition = !0),
                        this.node.setAttribute("dy", dy)
                    }),
                    this.verticalAlign = align,
                    this
                },
                getVerticalAlign: function() {
                    return this.verticalAlign || "baseline"
                },
                setStartOffset: function(offset) {
                    this.shapeNode != this.node && this.shapeNode.setAttribute("startOffset", 100 * offset + "%")
                },
                addSpan: function(span) {
                    return this.addShape(span),
                    this
                },
                setPath: function(path) {
                    var textpath = this.shapeNode;
                    if (this.shapeNode == this.node) {
                        for (textpath = this.shapeNode = svg.createNode("textPath"); this.node.firstChild; )
                            this.shapeNode.appendChild(this.node.firstChild);
                        this.node.appendChild(textpath)
                    }
                    return textpath.setAttributeNS(svg.xlink, "xlink:href", "#" + path.node.id),
                    this.setTextAnchor(this.getTextAnchor()),
                    this
                }
            })
        }
    },
    _p[70] = {
        value: function(require, exports, module) {
            var Shape = _p.r(60);
            return _p.r(11).createClass("TextContent", {
                base: Shape,
                constructor: function(nodeType) {
                    this.callBase(nodeType),
                    this.shapeNode = this.shapeNode || this.node,
                    this.shapeNode.setAttribute("text-rendering", "geometricPrecision")
                },
                clearContent: function() {
                    for (; this.shapeNode.firstChild; )
                        this.shapeNode.removeChild(this.shapeNode.firstChild);
                    return this
                },
                setContent: function(content) {
                    return this.shapeNode.textContent = content,
                    this
                },
                getContent: function() {
                    return this.shapeNode.textContent
                },
                appendContent: function(content) {
                    return this.shapeNode.textContent += content,
                    this
                },
                setSize: function(value) {
                    return this.setFontSize(value)
                },
                setFontSize: function(value) {
                    return this.setFont({
                        size: value
                    })
                },
                setFontFamily: function(value) {
                    return this.setFont({
                        family: value
                    })
                },
                setFontBold: function(bold) {
                    return this.setFont({
                        weight: bold ? "bold" : "normal"
                    })
                },
                setFontItalic: function(italic) {
                    return this.setFont({
                        style: italic ? "italic" : "normal"
                    })
                },
                setFont: function(font) {
                    var node = this.node;
                    return ["family", "size", "weight", "style"].forEach(function(section) {
                        null === font[section] ? node.removeAttribute("font-" + section) : font[section] && node.setAttribute("font-" + section, font[section])
                    }),
                    this
                },
                getExtentOfChar: function(index) {
                    return this.node.getExtentOfChar(index)
                },
                getRotationOfChar: function(index) {
                    return this.node.getRotationOfChar(index)
                },
                getCharNumAtPosition: function(x, y) {
                    return this.node.getCharNumAtPosition(this.node.viewportElement.createSVGPoint(x, y))
                }
            })
        }
    },
    _p[71] = {
        value: function(require, exports, module) {
            var TextContent = _p.r(70)
              , Styled = _p.r(66);
            return _p.r(11).createClass("TextSpan", {
                base: TextContent,
                mixins: [Styled],
                constructor: function(content) {
                    this.callBase("tspan"),
                    this.setContent(content)
                }
            })
        }
    },
    _p[72] = {
        value: function(require, exports, module) {
            var Svg = _p.r(67)
              , Class = _p.r(11)
              , Use = Class.createClass("Use", {
                base: _p.r(60),
                constructor: function(shape) {
                    this.callBase("use"),
                    this.ref(shape)
                },
                ref: function(shape) {
                    if (!shape)
                        return this.node.removeAttributeNS(Svg.xlink, "xlink:href"),
                        this;
                    var shapeId = shape.getId();
                    return shapeId && this.node.setAttributeNS(Svg.xlink, "xlink:href", "#" + shapeId),
                    "none" === shape.node.getAttribute("fill") && shape.node.removeAttribute("fill"),
                    "none" === shape.node.getAttribute("stroke") && shape.node.removeAttribute("stroke"),
                    this
                }
            })
              , Shape = _p.r(60);
            return Class.extendClass(Shape, {
                use: function() {
                    return new Use(this)
                }
            }),
            Use
        }
    },
    _p[73] = {
        value: function(require, exports, module) {
            var Point = _p.r(50)
              , Matrix = _p.r(43)
              , Vector = _p.r(11).createClass("Vector", {
                base: Point,
                constructor: function(x, y) {
                    this.callBase(x, y)
                },
                square: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.square())
                },
                add: function(q) {
                    return new Vector(this.x + q.x,this.y + q.y)
                },
                minus: function(q) {
                    return new Vector(this.x - q.x,this.y - q.y)
                },
                dot: function(q) {
                    return this.x * q.x + this.y * q.y
                },
                project: function(q) {
                    return q.multipy(this.dot(q) / q.square())
                },
                normalize: function(length) {
                    return void 0 === length && (length = 1),
                    this.multipy(length / this.length())
                },
                multipy: function(scale) {
                    return new Vector(this.x * scale,this.y * scale)
                },
                rotate: function(angle, unit) {
                    "rad" == unit && (angle = angle / Math.PI * 180);
                    var p = (new Matrix).rotate(angle).transformPoint(this);
                    return new Vector(p.x,p.y)
                },
                vertical: function() {
                    return new Vector(this.y,-this.x)
                },
                reverse: function() {
                    return this.multipy(-1)
                },
                getAngle: function() {
                    var length = this.length();
                    if (0 === length)
                        return 0;
                    var rad = Math.acos(this.x / length);
                    return 180 * (this.y > 0 ? 1 : -1) * rad / Math.PI
                }
            });
            return Vector.fromPoints = function(p1, p2) {
                return new Vector(p2.x - p1.x,p2.y - p1.y)
            }
            ,
            Vector.fromPolar = function() {
                var p = Point.fromPolar.apply(Point, arguments);
                return new Vector(p.x,p.y)
            }
            ,
            _p.r(11).extendClass(Point, {
                asVector: function() {
                    return new Vector(this.x,this.y)
                }
            }),
            Vector
        }
    },
    _p[74] = {
        value: function(require, exports, module) {
            var ShapeContainer = _p.r(61)
              , ViewBox = _p.r(75);
            return _p.r(11).createClass("View", {
                mixins: [ShapeContainer, ViewBox],
                base: _p.r(74),
                constructor: function() {
                    this.callBase("view")
                }
            })
        }
    },
    _p[75] = {
        value: function(require, exports, module) {
            return _p.r(11).createClass("ViewBox", {
                getViewBox: function() {
                    var attr = this.node.getAttribute("viewBox");
                    return null === attr ? {
                        x: 0,
                        y: 0,
                        width: this.node.clientWidth || this.node.parentNode.clientWidth,
                        height: this.node.clientHeight || this.node.parentNode.clientHeight
                    } : (attr = attr.split(" "),
                    {
                        x: +attr[0],
                        y: +attr[1],
                        width: +attr[2],
                        height: +attr[3]
                    })
                },
                setViewBox: function(x, y, width, height) {
                    return this.node.setAttribute("viewBox", [x, y, width, height].join(" ")),
                    this
                }
            })
        }
    },
    _p[76] = {
        value: function(require, exports, module) {
            var kity = {}
              , utils = _p.r(12);
            return kity.version = "2.0.0",
            utils.extend(kity, {
                createClass: _p.r(11).createClass,
                extendClass: _p.r(11).extendClass,
                Utils: utils,
                Browser: _p.r(10),
                Box: _p.r(25),
                Bezier: _p.r(23),
                BezierPoint: _p.r(24),
                Circle: _p.r(26),
                Clip: _p.r(27),
                Color: _p.r(28),
                Container: _p.r(29),
                Curve: _p.r(30),
                Ellipse: _p.r(32),
                Group: _p.r(36),
                Gradient: _p.r(35),
                HyperLink: _p.r(37),
                Image: _p.r(38),
                Line: _p.r(39),
                LinearGradient: _p.r(40),
                Mask: _p.r(42),
                Matrix: _p.r(43),
                Marker: _p.r(41),
                Palette: _p.r(44),
                Paper: _p.r(45),
                Path: _p.r(46),
                Pattern: _p.r(47),
                Pen: _p.r(48),
                Point: _p.r(50),
                PointContainer: _p.r(51),
                Polygon: _p.r(53),
                Polyline: _p.r(54),
                Pie: _p.r(49),
                RadialGradient: _p.r(55),
                Resource: _p.r(58),
                Rect: _p.r(56),
                RegularPolygon: _p.r(57),
                Ring: _p.r(59),
                Shape: _p.r(60),
                ShapePoint: _p.r(63),
                ShapeContainer: _p.r(61),
                Sweep: _p.r(68),
                Star: _p.r(65),
                Text: _p.r(69),
                TextSpan: _p.r(71),
                Use: _p.r(72),
                Vector: _p.r(73),
                g: _p.r(34),
                Animator: _p.r(0),
                Easing: _p.r(1),
                OpacityAnimator: _p.r(4),
                RotateAnimator: _p.r(6),
                ScaleAnimator: _p.r(7),
                Timeline: _p.r(8),
                TranslateAnimator: _p.r(9),
                PathAnimator: _p.r(5),
                MotionAnimator: _p.r(3),
                requestFrame: _p.r(2).requestFrame,
                releaseFrame: _p.r(2).releaseFrame,
                Filter: _p.r(20),
                GaussianblurFilter: _p.r(21),
                ProjectionFilter: _p.r(22),
                ColorMatrixEffect: _p.r(13),
                CompositeEffect: _p.r(14),
                ConvolveMatrixEffect: _p.r(15),
                Effect: _p.r(16),
                GaussianblurEffect: _p.r(17),
                OffsetEffect: _p.r(18)
            }),
            window.kity = kity
        }
    };
    var moduleMapping = {
        kity: 76
    };
    use("kity")
}(),
function() {
    var _p = {
        r: function(index) {
            if (_p[index].inited)
                return _p[index].value;
            if ("function" != typeof _p[index].value)
                return _p[index].inited = !0,
                _p[index].value;
            var module = {
                exports: {}
            }
              , returnValue = _p[index].value(null, module.exports, module);
            if (_p[index].inited = !0,
            _p[index].value = returnValue,
            void 0 !== returnValue)
                return returnValue;
            for (var key in module.exports)
                if (module.exports.hasOwnProperty(key))
                    return _p[index].inited = !0,
                    _p[index].value = module.exports,
                    module.exports
        }
    };
    _p[0] = {
        value: function(require, exports, module) {
            module.exports = window.HotBox = _p.r(1)
        }
    },
    _p[1] = {
        value: function(require, exports, module) {
            function createElement(name) {
                return document.createElement(name)
            }
            function addElementClass(element, name) {
                element.classList.add(name)
            }
            function removeElementClass(element, name) {
                element.classList.remove(name)
            }
            function appendChild(parent, child) {
                parent.appendChild(child)
            }
            function format(template, args) {
                return "object" != typeof args && (args = [].slice.apply(arguments, 1)),
                String(template).replace(/\{(\w+)\}/g, function(match, name) {
                    return args[name] || match
                })
            }
            function HotBox($container) {
                function _control(Controller) {
                    return _controler ? void _controler.active() : (Controller = Controller || KeyControl,
                    _controler = new Controller(_this),
                    _controler.active(),
                    $hotBox.onmousedown = function(e) {
                        e.stopPropagation(),
                        e.preventDefault()
                    }
                    ,
                    _this)
                }
                function _dispatchKey(e) {
                    var type = e.type.toLowerCase();
                    if (e.keyHash = key.hash(e),
                    e.isKey = function(keyExpression) {
                        if (!keyExpression)
                            return !1;
                        for (var expressions = keyExpression.split(/\s*\|\s*/); expressions.length; )
                            if (e.keyHash == key.hash(expressions.shift()))
                                return !0;
                        return !1
                    }
                    ,
                    e[type] = !0,
                    e.keyup && _this.activeKey && e.isKey(_this.activeKey) && _currentState == IDLE && _mainState)
                        return void _activeState("main", {
                            x: $container.clientWidth / 2,
                            y: $container.clientHeight / 2
                        });
                    var handleState = _currentState == IDLE ? _mainState : _currentState;
                    if (handleState) {
                        var handleResult = handleState.handleKeyEvent(e);
                        return "function" == typeof _this.onkeyevent && (e.handleResult = handleResult,
                        _this.onkeyevent(e, handleResult)),
                        handleResult
                    }
                    return null
                }
                function _addState(name) {
                    if (!name)
                        return _currentState;
                    if (name == IDLE)
                        throw new Error("Can not define or use the `idle` state.");
                    return _states[name] = _states[name] || new HotBoxState(this,name),
                    "main" == name && (_mainState = _states[name]),
                    _states[name]
                }
                function _activeState(name, position) {
                    if (_this.position = position,
                    name == IDLE)
                        _currentState != IDLE && (_stateStack.shift().deactive(),
                        _stateStack = []),
                        _currentState = IDLE;
                    else if ("back" == name)
                        _currentState != IDLE && (_currentState.deactive(),
                        _stateStack.shift(),
                        _currentState = _stateStack[0],
                        _currentState ? _currentState.active() : _currentState = "idle");
                    else {
                        _currentState != IDLE && _currentState.deactive();
                        var newState = _states[name];
                        _stateStack.unshift(newState),
                        "function" == typeof _this.position && (position = _this.position(position)),
                        newState.active(position),
                        _currentState = newState
                    }
                }
                function setParentFSM(fsm) {
                    _this._parentFSM = fsm
                }
                function getParentFSM() {
                    return _this._parentFSM
                }
                if ("string" == typeof $container && ($container = document.querySelector($container)),
                !($container && $container instanceof HTMLElement))
                    throw new Error("No container or not invalid container for hot box");
                var $hotBox = createElement(div);
                addElementClass($hotBox, "hotbox"),
                appendChild($container, $hotBox),
                this.$element = $hotBox,
                this.$container = $container,
                this.isIME = !1,
                this.browser = {
                    sg: /se[\s\S]+metasr/.test(navigator.userAgent.toLowerCase())
                },
                this._parentFSM = {},
                this.position = {};
                var _controler, _states = {}, _mainState = null, _currentState = IDLE, _stateStack = [], _this = this;
                this.control = _control,
                this.state = _addState,
                this.active = _activeState,
                this.dispatch = _dispatchKey,
                this.setParentFSM = setParentFSM,
                this.getParentFSM = getParentFSM,
                this.activeKey = "space",
                this.actionKey = "space"
            }
            function HotBoxState(hotBox, stateName) {
                function layout() {
                    var radius = 15 * buttons.ring.length;
                    !function(radius) {
                        var ring = buttons.ring
                          , step = 2 * Math.PI / ring.length;
                        buttons.center && (buttons.center.indexedPosition = [0, 0]),
                        $ringShape.style.marginLeft = $ringShape.style.marginTop = -radius + "px",
                        $ringShape.style.width = $ringShape.style.height = radius + radius + "px";
                        for (var $button, angle, x, y, i = 0; i < ring.length; i++)
                            $button = ring[i].$button,
                            angle = step * i - Math.PI / 2,
                            x = radius * Math.cos(angle),
                            y = radius * Math.sin(angle),
                            ring[i].indexedPosition = [x, y],
                            $button.style.left = x + "px",
                            $button.style.top = y + "px"
                    }(radius),
                    function(radius) {
                        var xOffset = -$top.clientWidth / 2
                          , yOffset = 2 * -radius - $top.clientHeight / 2;
                        $top.style.marginLeft = xOffset + "px",
                        $top.style.marginTop = yOffset + "px",
                        buttons.top.forEach(function(topButton) {
                            var $button = topButton.$button;
                            topButton.indexedPosition = [xOffset + $button.offsetLeft + $button.clientWidth / 2, yOffset]
                        })
                    }(radius),
                    function(radius) {
                        var xOffset = -$bottom.clientWidth / 2
                          , yOffset = 2 * radius - $bottom.clientHeight / 2;
                        $bottom.style.marginLeft = xOffset + "px",
                        $bottom.style.marginTop = yOffset + "px",
                        buttons.bottom.forEach(function(bottomButton) {
                            var $button = bottomButton.$button;
                            bottomButton.indexedPosition = [xOffset + $button.offsetLeft + $button.clientWidth / 2, yOffset]
                        })
                    }(radius),
                    function() {
                        function findNeightbour(button) {
                            var candidatePosition, dx, dy, ds, possible, dir, neighbor = {}, coef = 0, minCoef = {}, homePosition = button.indexedPosition, abs = Math.abs;
                            positionedButtons.forEach(function(candidate) {
                                if (button != candidate)
                                    for (candidatePosition = candidate.indexedPosition,
                                    possible = [],
                                    dx = candidatePosition[0] - homePosition[0],
                                    dy = candidatePosition[1] - homePosition[1],
                                    ds = Math.sqrt(dx * dx + dy * dy),
                                    abs(dx) > 2 && (possible.push(dx > 0 ? "right" : "left"),
                                    possible.push(ds + abs(dy))),
                                    abs(dy) > 2 && (possible.push(dy > 0 ? "down" : "up"),
                                    possible.push(ds + abs(dx))); possible.length; )
                                        dir = possible.shift(),
                                        coef = possible.shift(),
                                        (!neighbor[dir] || coef < minCoef[dir]) && (neighbor[dir] = candidate,
                                        minCoef[dir] = coef)
                            }),
                            button.neighbor = neighbor
                        }
                        var positionedButtons = allButtons.filter(function(button) {
                            return button.indexedPosition
                        });
                        positionedButtons.forEach(findNeightbour)
                    }(),
                    needLayout = !1
                }
                function alwaysEnable() {
                    return !0
                }
                function createButton(option) {
                    var $button = createElement(div);
                    addElementClass($button, "button");
                    var render = option.render || defaultButtonRender;
                    switch ($button.innerHTML = render(format, option),
                    option.position) {
                    case "center":
                        appendChild($center, $button);
                        break;
                    case "ring":
                        appendChild($ring, $button);
                        break;
                    case "top":
                        appendChild($top, $button);
                        break;
                    case "bottom":
                        appendChild($bottom, $button)
                    }
                    return {
                        action: option.action,
                        enable: option.enable || alwaysEnable,
                        beforeShow: option.beforeShow,
                        key: option.key,
                        next: option.next,
                        label: option.label,
                        data: option.data || null,
                        $button: $button
                    }
                }
                function defaultButtonRender(format, option) {
                    return format('<span class="label">{label}</span><span class="key">{key}</span>', {
                        label: option.label,
                        key: option.key && option.key.split("|")[0]
                    })
                }
                function activeState(position) {
                    position = position || {
                        x: hotBox.$container.clientWidth / 2,
                        y: hotBox.$container.clientHeight / 2
                    },
                    position && ($state.style.left = position.x + "px",
                    $state.style.top = position.y + "px"),
                    allButtons.forEach(function(button) {
                        var $button = button.$button;
                        $button && $button.classList[button.enable() ? "add" : "remove"]("enabled"),
                        button.beforeShow && button.beforeShow()
                    }),
                    addElementClass($state, STATE_ACTIVE_CLASS),
                    needLayout && layout(),
                    selectedButton || select(buttons.center || buttons.ring[0] || buttons.top[0] || buttons.bottom[0]),
                    stateActived = !0
                }
                function deactiveState() {
                    removeElementClass($state, STATE_ACTIVE_CLASS),
                    select(null),
                    stateActived = !1
                }
                function press(button) {
                    pressedButton && pressedButton.$button && removeElementClass(pressedButton.$button, BUTTON_PRESSED_CLASS),
                    (pressedButton = button) && pressedButton.$button && addElementClass(pressedButton.$button, BUTTON_PRESSED_CLASS)
                }
                function select(button) {
                    selectedButton && selectedButton.$button && selectedButton.$button && removeElementClass(selectedButton.$button, BUTTON_SELECTED_CLASS),
                    (selectedButton = button) && selectedButton.$button && addElementClass(selectedButton.$button, BUTTON_SELECTED_CLASS)
                }
                function execute(button) {
                    button && (button.enable && !button.enable() || (button.action && button.action(button),
                    hotBox.active(button.next || IDLE, hotBox.position)),
                    press(null),
                    select(null))
                }
                var BUTTON_SELECTED_CLASS = "selected"
                  , BUTTON_PRESSED_CLASS = "pressed"
                  , STATE_ACTIVE_CLASS = "active"
                  , $state = createElement(div)
                  , $center = createElement(div)
                  , $ring = createElement(div)
                  , $ringShape = createElement("div")
                  , $top = createElement(div)
                  , $bottom = createElement(div);
                addElementClass($state, "state"),
                addElementClass($state, stateName),
                addElementClass($center, "center"),
                addElementClass($ring, "ring"),
                addElementClass($ringShape, "ring-shape"),
                addElementClass($top, "top"),
                addElementClass($bottom, "bottom"),
                appendChild(hotBox.$element, $state),
                appendChild($state, $ringShape),
                appendChild($state, $center),
                appendChild($state, $ring),
                appendChild($state, $top),
                appendChild($state, $bottom),
                this.name = stateName;
                var buttons = {
                    center: null,
                    ring: [],
                    top: [],
                    bottom: [],
                    behind: []
                }
                  , allButtons = []
                  , selectedButton = null
                  , pressedButton = null
                  , stateActived = !1
                  , needLayout = !0;
                this.button = function(option) {
                    var button = createButton(option);
                    "center" == option.position ? buttons.center = button : buttons[option.position] && buttons[option.position].push(button),
                    allButtons.push(button),
                    needLayout = !0
                }
                ,
                this.active = activeState,
                this.deactive = deactiveState,
                $state.onmouseup = function(e) {
                    if (!e.button)
                        for (var target = e.target; target && target != $state; )
                            target.classList.contains("button") && allButtons.forEach(function(button) {
                                button.$button == target && execute(button)
                            }),
                            target = target.parentNode
                }
                ,
                this.handleKeyEvent = function(e) {
                    var handleResult = null;
                    if (hotBox.browser.sg && e.isKey("esc"))
                        return pressedButton ? e.isKey(pressedButton.key) || press(null) : hotBox.active("back", hotBox.position),
                        "back";
                    if (e.keydown || hotBox.isIME && e.keyup) {
                        if (allButtons.forEach(function(button) {
                            if (button.enable() && e.isKey(button.key)) {
                                if (stateActived || hotBox.hintDeactiveMainState) {
                                    if (select(button),
                                    press(button),
                                    handleResult = "buttonpress",
                                    e.keyup)
                                        return execute(button),
                                        handleResult = "execute"
                                } else
                                    execute(button),
                                    handleResult = "execute";
                                e.preventDefault(),
                                e.stopPropagation(),
                                !stateActived && hotBox.hintDeactiveMainState && hotBox.active(stateName, hotBox.position)
                            }
                        }),
                        stateActived) {
                            if (e.isKey("esc"))
                                return pressedButton ? e.isKey(pressedButton.key) || press(null) : hotBox.active("back", hotBox.position),
                                "back";
                            ["up", "down", "left", "right"].forEach(function(dir) {
                                if (e.isKey(dir)) {
                                    if (!selectedButton)
                                        return void select(buttons.center || buttons.ring[0] || buttons.top[0] || buttons.bottom[0]);
                                    for (var neighbor = selectedButton.neighbor[dir]; neighbor && !neighbor.enable(); )
                                        neighbor = neighbor.neighbor[dir];
                                    neighbor && select(neighbor),
                                    handleResult = "navigate"
                                }
                            }),
                            e.isKey("space") && e.keyup ? (execute(selectedButton),
                            e.preventDefault(),
                            e.stopPropagation(),
                            handleResult = "execute") : e.isKey("space") && selectedButton ? (press(selectedButton),
                            handleResult = "buttonpress") : pressedButton && pressedButton != selectedButton && (press(null),
                            handleResult = "selectcancel")
                        }
                    } else
                        !e.keyup || !stateActived && hotBox.hintDeactiveMainState || pressedButton && (e.isKey("space") && selectedButton == pressedButton || e.isKey(pressedButton.key)) && (execute(pressedButton),
                        e.preventDefault(),
                        e.stopPropagation(),
                        handleResult = "execute");
                    return hotBox.isIME = 229 == e.keyCode && e.keydown,
                    handleResult
                }
            }
            var key = _p.r(2)
              , KeyControl = _p.r(3)
              , IDLE = HotBox.STATE_IDLE = "idle"
              , div = "div";
            module.exports = HotBox
        }
    },
    _p[2] = {
        value: function(require, exports, module) {
            function hash(unknown) {
                return "string" == typeof unknown ? hashKeyExpression(unknown) : hashKeyEvent(unknown)
            }
            function is(a, b) {
                return a && b && hash(a) == hash(b)
            }
            function hashKeyEvent(keyEvent) {
                var hashCode = 0;
                return (keyEvent.ctrlKey || keyEvent.metaKey) && (hashCode |= CTRL_MASK),
                keyEvent.altKey && (hashCode |= ALT_MASK),
                keyEvent.shiftKey && (hashCode |= SHIFT_MASK),
                -1 == [16, 17, 18, 91].indexOf(keyEvent.keyCode) && (hashCode |= keyEvent.keyCode),
                hashCode
            }
            function hashKeyExpression(keyExpression) {
                var hashCode = 0;
                return keyExpression.toLowerCase().split(/\s*\+\s*/).forEach(function(name) {
                    switch (name) {
                    case "ctrl":
                    case "cmd":
                        hashCode |= CTRL_MASK;
                        break;
                    case "alt":
                        hashCode |= ALT_MASK;
                        break;
                    case "shift":
                        hashCode |= SHIFT_MASK;
                        break;
                    default:
                        hashCode |= keymap[name]
                    }
                }),
                hashCode
            }
            var keymap = _p.r(4)
              , CTRL_MASK = 4096
              , ALT_MASK = 8192
              , SHIFT_MASK = 16384;
            exports.hash = hash,
            exports.is = is
        }
    },
    _p[3] = {
        value: function(require, exports, module) {
            function KeyControl(hotbox) {
                function _handle(keyEvent) {
                    _actived && hotbox.dispatch(keyEvent)
                }
                function _active() {
                    _receiver.select(),
                    _receiver.focus(),
                    _actived = !0,
                    $container.classList.add(FOCUS_CLASS)
                }
                function _deactive() {
                    _receiver.blur(),
                    _actived = !1,
                    $container.classList.remove(FOCUS_CLASS)
                }
                var _receiver, _actived = !0, _receiverIsSelfCreated = !1, $container = hotbox.$container;
                !function() {
                    _receiver = document.createElement("input"),
                    _receiver.classList.add(RECEIVER_CLASS),
                    $container.appendChild(_receiver),
                    _receiverIsSelfCreated = !0
                }(),
                function() {
                    _receiver.onkeyup = _handle,
                    _receiver.onkeypress = _handle,
                    _receiver.onkeydown = _handle,
                    _receiver.onfocus = _active,
                    _receiver.onblur = _deactive,
                    _receiverIsSelfCreated && (_receiver.oninput = function(e) {
                        _receiver.value = null
                    }
                    )
                }(),
                function() {
                    $container.onmousedown = function(e) {
                        _active(),
                        e.preventDefault()
                    }
                }(),
                _active(),
                this.handle = _handle,
                this.active = _active,
                this.deactive = _deactive
            }
            var FOCUS_CLASS = (_p.r(2),
            "hotbox-focus")
              , RECEIVER_CLASS = "hotbox-key-receiver";
            module.exports = KeyControl
        }
    },
    _p[4] = {
        value: function(require, exports, module) {
            var keymap = {
                Shift: 16,
                Control: 17,
                Alt: 18,
                CapsLock: 20,
                BackSpace: 8,
                Tab: 9,
                Enter: 13,
                Esc: 27,
                Space: 32,
                PageUp: 33,
                PageDown: 34,
                End: 35,
                Home: 36,
                Insert: 45,
                Left: 37,
                Up: 38,
                Right: 39,
                Down: 40,
                Direction: {
                    37: 1,
                    38: 1,
                    39: 1,
                    40: 1
                },
                Delete: 46,
                NumLock: 144,
                Cmd: 91,
                CmdFF: 224,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                "`": 192,
                "=": 187,
                "-": 189,
                "/": 191,
                ".": 190
            };
            for (var key in keymap)
                keymap.hasOwnProperty(key) && (keymap[key.toLowerCase()] = keymap[key]);
            var aCharCode = "a".charCodeAt(0);
            "abcdefghijklmnopqrstuvwxyz".split("").forEach(function(letter) {
                keymap[letter] = letter.charCodeAt(0) - aCharCode + 65
            });
            var n = 9;
            do {
                keymap[n.toString()] = n + 48
            } while (n--);
            module.exports = keymap
        }
    };
    var moduleMapping = {
        expose: 0
    };
    !function(name) {
        _p.r([moduleMapping[name]])
    }("expose")
}();
var json_diff = function() {
    function equal(a, b) {
        if (a === b)
            return !0;
        if ("object" != typeof a || "object" != typeof b)
            return !1;
        if (null === a || null === b)
            return !1;
        if (a instanceof Array != b instanceof Array)
            return !1;
        if (a instanceof Array) {
            if (a.length != b.length)
                return !1;
            for (var n = 0; n < a.length; n++)
                if (!equal(a[n], b[n]))
                    return !1
        } else {
            for (var key in a)
                if (!(key in b && equal(a[key], b[key])))
                    return !1;
            for (var key in b)
                if (!(key in a))
                    return !1
        }
        return !0
    }
    function type(v) {
        if ("object" == typeof v) {
            if (v instanceof Array)
                return "array";
            if (null === v)
                return "null"
        }
        return typeof v
    }
    return function(a, b) {
        function json_pointer(tail) {
            if (void 0 === tail)
                return "/";
            path.push(tail);
            for (var pointer = "", n = 0; n < path.length; n++)
                pointer = pointer + "/" + path[n].toString().replace(/~/g, "~0").replace(/\//g, "~1");
            return path.pop(),
            pointer
        }
        function result(op, tail, value) {
            var pointer = json_pointer(tail);
            "remove" === op ? operations.push({
                op: op,
                path: pointer
            }) : operations.push({
                op: op,
                path: pointer,
                value: void 0 === value ? null : value
            })
        }
        function diffseq(a, b) {
            var i, j, m, n, left, diag, latch, skip, row = [], c = [], edit = [];
            for (m = a.length,
            n = b.length; m && n && equal(a[m - 1], b[n - 1]); m--,
            n--)
                ;
            for (skip = 0; m && n && equal(a[skip], b[skip]); skip++,
            m--,
            n--)
                ;
            if (m && n) {
                for (j = 0; j < n; row[j++] = 0)
                    ;
                for (i = 0; i < m; i++)
                    for (c[i] = row = row.slice(),
                    diag = 0,
                    j = 0; j < n; j++,
                    diag = latch)
                        latch = row[j],
                        equal(a[i + skip], b[j + skip]) ? row[j] = diag + 1 : (left = row[j - 1] || 0) > row[j] && (row[j] = left);
                for (i--,
                j--; i > -1 && j > -1; )
                    switch (c[i][j]) {
                    default:
                        edit.unshift("="),
                        i--,
                        j--;
                        break;
                    case j && c[i][j - 1]:
                        edit.unshift("+"),
                        j--;
                        break;
                    case i && c[i - 1][j]:
                        edit.unshift("-"),
                        i--
                    }
            } else
                i = m - 1,
                j = n - 1;
            for (; j > -1; j--)
                edit.unshift("+");
            for (; i > -1; i--)
                edit.unshift("-");
            var edit_replace = [];
            for (n = 0; n < edit.length; n++)
                if ("-" === edit[n]) {
                    for (i = n + 1; i < edit.length && "-" === edit[i]; i++)
                        ;
                    for (j = i; j < edit.length && "+" === edit[j]; j++)
                        ;
                    if (i - n == j - i) {
                        for (; i++ < j; )
                            edit_replace.push("*");
                        n = j - 1
                    } else {
                        for (; n < j; n++)
                            edit_replace.push(edit[n]);
                        n--
                    }
                } else
                    edit_replace.push(edit[n]);
            for (edit = edit_replace,
            i = 0,
            j = 0,
            n = 0; n < edit.length; n++)
                switch (edit[n]) {
                case "*":
                    diff_recursive(a[i + skip], b[j + skip], j + skip);
                case "=":
                    i++,
                    j++;
                    break;
                case "-":
                    result("remove", j + skip),
                    i++;
                    break;
                case "+":
                    result("add", j + skip, b[j + skip]),
                    j++
                }
        }
        function diff_arrays(a, b, tail) {
            void 0 !== tail && path.push(tail),
            diffseq(a, b),
            void 0 !== tail && path.pop()
        }
        function diff_objects(a, b, tail) {
            void 0 !== tail && path.push(tail);
            for (var key in a)
                key in b ? diff_recursive(a[key], b[key], key) : result("remove", key);
            for (var key in b)
                key in a || result("add", key, b[key]);
            void 0 !== tail && path.pop()
        }
        function diff_recursive(a, b, tail) {
            if (a !== b) {
                var ta = type(a);
                if (ta !== type(b))
                    result("replace", tail, b);
                else
                    switch (ta) {
                    case "object":
                        diff_objects(a, b, tail);
                        break;
                    case "array":
                        diff_arrays(a, b, tail);
                        break;
                    default:
                        result("replace", tail, b)
                    }
            }
        }
        var path = []
          , operations = [];
        return diff_recursive(a, b, void 0),
        operations
    }
}();
"undefined" != typeof exports && (exports.diff = json_diff),
function() {
    var _p = {
        r: function(index) {
            if (_p[index].inited)
                return _p[index].value;
            if ("function" != typeof _p[index].value)
                return _p[index].inited = !0,
                _p[index].value;
            var module = {
                exports: {}
            }
              , returnValue = _p[index].value(null, module.exports, module);
            if (_p[index].inited = !0,
            _p[index].value = returnValue,
            void 0 !== returnValue)
                return returnValue;
            for (var key in module.exports)
                if (module.exports.hasOwnProperty(key))
                    return _p[index].inited = !0,
                    _p[index].value = module.exports,
                    module.exports
        }
    };
    _p[0] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , connect = _p.r(11)
              , connectMarker = (new kity.Marker).pipe(function() {
                var dot = new kity.Circle(6);
                this.addShape(dot),
                this.setRef(6, 0).setViewBox(-7, -7, 14, 14).setWidth(7).setHeight(7),
                this.dot = dot,
                this.node.setAttribute("markerUnits", "userSpaceOnUse")
            });
            connect.register("arc", function(node, parent, connection, width, color) {
                var start, end, vector, box = node.getLayoutBox(), pBox = parent.getLayoutBox(), abs = Math.abs, pathData = [], side = box.x > pBox.x ? "right" : "left";
                node.getMinder().getPaper().addResource(connectMarker),
                start = new kity.Point(pBox.cx,pBox.cy),
                end = "left" == side ? new kity.Point(box.right + 2,box.cy) : new kity.Point(box.left - 2,box.cy),
                vector = kity.Vector.fromPoints(start, end),
                pathData.push("M", start),
                pathData.push("A", abs(vector.x), abs(vector.y), 0, 0, vector.x * vector.y > 0 ? 0 : 1, end),
                connection.setMarker(connectMarker),
                connectMarker.dot.fill(color),
                connection.setPathData(pathData)
            })
        }
    },
    _p[1] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , connect = _p.r(11)
              , connectMarker = (new kity.Marker).pipe(function() {
                var dot = new kity.Circle(6);
                this.addShape(dot),
                this.setRef(6, 0).setViewBox(-7, -7, 14, 14).setWidth(7).setHeight(7),
                this.dot = dot,
                this.node.setAttribute("markerUnits", "userSpaceOnUse")
            });
            connect.register("arc_tp", function(node, parent, connection, width, color) {
                var end_box = node.getLayoutBox()
                  , start_box = parent.getLayoutBox()
                  , index = node.getIndex()
                  , nextNode = parent.getChildren()[index + 1];
                node.getIndex() > 0 && (start_box = parent.getChildren()[index - 1].getLayoutBox());
                var start, end, pathData = (Math.abs,
                []);
                end_box.x,
                start_box.x;
                node.getMinder().getPaper().addResource(connectMarker),
                start = new kity.Point(start_box.cx,start_box.cy),
                end = new kity.Point(end_box.cx,end_box.cy);
                var jl = Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2));
                if (jl = 0 == node.getIndex() ? .4 * jl : jl,
                kity.Vector.fromPoints(start, end),
                pathData.push("M", start),
                pathData.push("A", jl, jl, 0, 0, 1, end),
                connection.setMarker(connectMarker),
                connectMarker.dot.fill(color),
                connection.setPathData(pathData),
                nextNode && nextNode.getConnection()) {
                    var nextConnection = nextNode.getConnection()
                      , next_end_box = nextNode.getLayoutBox()
                      , next_end = new kity.Point(next_end_box.cx,next_end_box.cy)
                      , jl2 = Math.sqrt(Math.pow(end.x - next_end.x, 2) + Math.pow(end.y - next_end.y, 2));
                    pathData = [],
                    pathData.push("M", end),
                    pathData.push("A", jl2, jl2, 0, 0, 1, next_end),
                    nextConnection.setMarker(connectMarker),
                    connectMarker.dot.fill(color),
                    nextConnection.setPathData(pathData)
                }
            })
        }
    },
    _p[2] = {
        value: function(require, exports, module) {
            _p.r(17);
            _p.r(11).register("bezier", function(node, parent, connection) {
                var po = parent.getLayoutVertexOut()
                  , pi = node.getLayoutVertexIn()
                  , v = parent.getLayoutVectorOut().normalize()
                  , r = Math.round
                  , abs = Math.abs
                  , pathData = [];
                if (pathData.push("M", r(po.x), r(po.y)),
                abs(v.x) > abs(v.y)) {
                    var hx = (pi.x + po.x) / 2;
                    pathData.push("C", hx, po.y, hx, pi.y, pi.x, pi.y)
                } else {
                    var hy = (pi.y + po.y) / 2;
                    pathData.push("C", po.x, hy, pi.x, hy, pi.x, pi.y)
                }
                connection.setMarker(null),
                connection.setPathData(pathData)
            })
        }
    },
    _p[3] = {
        value: function(require, exports, module) {
            _p.r(17);
            _p.r(11).register("fish-bone-master", function(node, parent, connection) {
                var pout = parent.getLayoutVertexOut()
                  , pin = node.getLayoutVertexIn()
                  , abs = Math.abs
                  , dy = abs(pout.y - pin.y)
                  , dx = abs(pout.x - pin.x)
                  , pathData = [];
                pathData.push("M", pout.x, pout.y),
                pathData.push("h", dx - dy),
                pathData.push("L", pin.x, pin.y),
                connection.setMarker(null),
                connection.setPathData(pathData)
            })
        }
    },
    _p[4] = {
        value: function(require, exports, module) {
            _p.r(17);
            _p.r(11).register("l", function(node, parent, connection) {
                var po = parent.getLayoutVertexOut()
                  , pi = node.getLayoutVertexIn()
                  , vo = parent.getLayoutVectorOut()
                  , pathData = []
                  , r = Math.round
                  , abs = Math.abs;
                pathData.push("M", po.round()),
                abs(vo.x) > abs(vo.y) ? pathData.push("H", r(pi.x)) : pathData.push("V", pi.y),
                pathData.push("L", pi),
                connection.setPathData(pathData)
            })
        }
    },
    _p[5] = {
        value: function(require, exports, module) {
            _p.r(17);
            _p.r(11).register("poly", function(node, parent, connection, width) {
                var po = parent.getLayoutVertexOut()
                  , pi = node.getLayoutVertexIn()
                  , v = parent.getLayoutVectorOut().normalize()
                  , r = Math.round
                  , abs = Math.abs
                  , pathData = [];
                switch (pathData.push("M", r(po.x), r(po.y)),
                !0) {
                case abs(v.x) > abs(v.y) && v.x < 0:
                    pathData.push("h", -parent.getStyle("margin-left")),
                    pathData.push("v", pi.y - po.y),
                    pathData.push("H", pi.x);
                    break;
                case abs(v.x) > abs(v.y) && v.x >= 0:
                    pathData.push("h", parent.getStyle("margin-right")),
                    pathData.push("v", pi.y - po.y),
                    pathData.push("H", pi.x);
                    break;
                case abs(v.x) <= abs(v.y) && v.y < 0:
                    pathData.push("v", -parent.getStyle("margin-top")),
                    pathData.push("h", pi.x - po.x),
                    pathData.push("V", pi.y);
                    break;
                case abs(v.x) <= abs(v.y) && v.y >= 0:
                    pathData.push("v", parent.getStyle("margin-bottom")),
                    pathData.push("h", pi.x - po.x),
                    pathData.push("V", pi.y)
                }
                connection.setMarker(null),
                connection.setPathData(pathData)
            })
        }
    },
    _p[6] = {
        value: function(require, exports, module) {
            var kity = _p.r(17);
            _p.r(11).register("under", function(node, parent, connection, width, color) {
                var p1, p2, p3, mx, box = node.getLayoutBox(), pBox = parent.getLayoutBox(), pathData = (Math.abs,
                []), side = box.x > pBox.x ? "right" : "left", underY = (node.getStyle("connect-radius"),
                box.bottom + 3), startY = "sub" == parent.getType() ? pBox.bottom + 3 : pBox.cy;
                "right" == side ? (p1 = new kity.Point(pBox.right,startY),
                p2 = new kity.Point(box.left - 10,underY),
                p3 = new kity.Point(box.right,underY)) : (p1 = new kity.Point(pBox.left,startY),
                p2 = new kity.Point(box.right + 10,underY),
                p3 = new kity.Point(box.left,underY)),
                mx = (p1.x + p2.x) / 2,
                pathData.push("M", p1),
                pathData.push("C", mx, p1.y, mx, p2.y, p2),
                pathData.push("L", p3),
                connection.setMarker(null),
                connection.setPathData(pathData)
            })
        }
    },
    _p[7] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = _p.r(19);
            if (-1 != location.href.indexOf("boxv")) {
                var vrect;
                Object.defineProperty(kity.Box.prototype, "visualization", {
                    get: function() {
                        return vrect ? vrect.setBox(this) : null
                    }
                }),
                Minder.registerInitHook(function() {
                    this.on("paperrender", function() {
                        vrect = new kity.Rect,
                        vrect.fill("rgba(200, 200, 200, .5)"),
                        vrect.stroke("orange"),
                        this.getRenderContainer().addShape(vrect)
                    })
                })
            }
        }
    },
    _p[8] = {
        value: function(require, exports, module) {
            var Minder = _p.r(19)
              , animateDefaultOptions = {
                enableAnimation: !0,
                layoutAnimationDuration: 300,
                viewAnimationDuration: 100,
                zoomAnimationDuration: 300
            }
              , resoredAnimationOptions = {};
            Minder.registerInitHook(function() {
                this.setDefaultOptions(animateDefaultOptions),
                this.getOption("enableAnimation") || this.disableAnimation()
            }),
            Minder.prototype.enableAnimation = function() {
                for (var name in animateDefaultOptions)
                    animateDefaultOptions.hasOwnProperty(name) && this.setOption(resoredAnimationOptions[name])
            }
            ,
            Minder.prototype.disableAnimation = function() {
                for (var name in animateDefaultOptions)
                    animateDefaultOptions.hasOwnProperty(name) && (resoredAnimationOptions[name] = this.getOption(name),
                    this.setOption(name, 0))
            }
        }
    },
    _p[9] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = (_p.r(33),
            _p.r(19))
              , MinderEvent = (_p.r(21),
            _p.r(13))
              , Command = kity.createClass("Command", {
                constructor: function() {
                    this._isContentChange = !0,
                    this._isSelectionChange = !1
                },
                execute: function(minder, args) {
                    throw new Error("Not Implement: Command.execute()")
                },
                setContentChanged: function(val) {
                    this._isContentChange = !!val
                },
                isContentChanged: function() {
                    return this._isContentChange
                },
                setSelectionChanged: function(val) {
                    this._isSelectionChange = !!val
                },
                isSelectionChanged: function() {
                    return this._isContentChange
                },
                queryState: function(km) {
                    return 0
                },
                queryValue: function(km) {
                    return 0
                },
                isNeedUndo: function() {
                    return !0
                }
            });
            Command.STATE_NORMAL = 0,
            Command.STATE_ACTIVE = 1,
            Command.STATE_DISABLED = -1,
            kity.extendClass(Minder, {
                _getCommand: function(name) {
                    return this._commands[name.toLowerCase()]
                },
                _queryCommand: function(name, type, args) {
                    var cmd = this._getCommand(name);
                    if (cmd) {
                        var queryCmd = cmd["query" + type];
                        if (queryCmd)
                            return queryCmd.apply(cmd, [this].concat(args))
                    }
                    return 0
                },
                queryCommandState: function(name) {
                    return this._queryCommand(name, "State", [].slice.call(arguments, 1))
                },
                queryCommandValue: function(name) {
                    return this._queryCommand(name, "Value", [].slice.call(arguments, 1))
                },
                execCommand: function(name) {
                    if (!name)
                        return null;
                    name = name.toLowerCase();
                    var cmd, stoped, result, eventParams, cmdArgs = [].slice.call(arguments, 1), me = this;
                    return cmd = this._getCommand(name),
                    eventParams = {
                        command: cmd,
                        commandName: name.toLowerCase(),
                        commandArgs: cmdArgs
                    },
                    !(!cmd || !~this.queryCommandState(name)) && (this._hasEnterExecCommand ? (result = cmd.execute.apply(cmd, [me].concat(cmdArgs)),
                    this._hasEnterExecCommand || this._interactChange()) : (this._hasEnterExecCommand = !0,
                    stoped = this._fire(new MinderEvent("beforeExecCommand",eventParams,!0)),
                    stoped || (this._fire(new MinderEvent("preExecCommand",eventParams,!1)),
                    result = cmd.execute.apply(cmd, [me].concat(cmdArgs)),
                    this._fire(new MinderEvent("execCommand",eventParams,!1)),
                    cmd.isContentChanged() && this._firePharse(new MinderEvent("contentchange")),
                    this._interactChange()),
                    this._hasEnterExecCommand = !1),
                    void 0 === result ? null : result)
                }
            }),
            module.exports = Command
        }
    },
    _p[10] = {
        value: function(require, exports, module) {
            function compatibility(json) {
                switch (json.version || (json.root ? "1.4.0" : "1.1.3")) {
                case "1.1.3":
                    c_113_120(json);
                case "1.2.0":
                case "1.2.1":
                    c_120_130(json);
                case "1.3.0":
                case "1.3.1":
                case "1.3.2":
                case "1.3.3":
                case "1.3.4":
                case "1.3.5":
                    c_130_140(json)
                }
                return json
            }
            function traverse(node, fn) {
                fn(node),
                node.children && node.children.forEach(function(child) {
                    traverse(child, fn)
                })
            }
            function c_120_130(json) {
                traverse(json, function(node) {
                    var data = node.data;
                    delete data.layout_bottom_offset,
                    delete data.layout_default_offset,
                    delete data.layout_filetree_offset
                })
            }
            function c_113_120(json) {
                var ocs = json.data.currentstyle;
                delete json.data.currentstyle,
                "bottom" == ocs ? (json.template = "structure",
                json.theme = "snow") : "default" == ocs && (json.template = "default",
                json.theme = "classic"),
                traverse(json, function(node) {
                    var data = node.data;
                    "PriorityIcon"in data && (data.priority = data.PriorityIcon,
                    delete data.PriorityIcon),
                    "ProgressIcon"in data && (data.progress = 1 + (data.ProgressIcon - 1 << 1),
                    delete data.ProgressIcon),
                    delete data.point,
                    delete data.layout
                })
            }
            function c_130_140(json) {
                json.root = {
                    data: json.data,
                    children: json.children
                },
                delete json.data,
                delete json.children
            }
            _p.r(33);
            return compatibility
        }
    },
    _p[11] = {
        value: function(require, exports, module) {
            function register(name, provider) {
                _connectProviders[name] = provider
            }
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Module = _p.r(20)
              , Minder = _p.r(19)
              , MinderNode = _p.r(21)
              , _connectProviders = {};
            register("default", function(node, parent, connection) {
                connection.setPathData(["M", parent.getLayoutVertexOut(), "L", node.getLayoutVertexIn()])
            }),
            kity.extendClass(MinderNode, {
                getConnect: function() {
                    return this.data.connect || "default"
                },
                getConnectProvider: function() {
                    return _connectProviders[this.getConnect()] || _connectProviders.default
                },
                getConnection: function() {
                    return this._connection || null
                }
            }),
            kity.extendClass(Minder, {
                getConnectContainer: function() {
                    return this._connectContainer
                },
                createConnect: function(node) {
                    if (!node.isRoot()) {
                        var connection = new kity.Path;
                        node._connection = connection,
                        this._connectContainer.addShape(connection),
                        this.updateConnect(node)
                    }
                },
                removeConnect: function(node) {
                    var me = this;
                    node.traverse(function(node) {
                        me._connectContainer.removeShape(node._connection),
                        node._connection = null
                    })
                },
                updateConnect: function(node) {
                    var connection = node._connection
                      , parent = node.parent;
                    if (parent && connection) {
                        if (parent.isCollapsed())
                            return void connection.setVisible(!1);
                        connection.setVisible(!0);
                        var provider = node.getConnectProvider()
                          , strokeColor = node.getStyle("connect-color") || "white"
                          , strokeWidth = node.getStyle("connect-width") || 2;
                        connection.stroke(strokeColor, strokeWidth),
                        provider(node, parent, connection, strokeWidth, strokeColor),
                        strokeWidth % 2 == 0 ? connection.setTranslate(.5, .5) : connection.setTranslate(0, 0)
                    }
                }
            }),
            Module.register("Connect", {
                init: function() {
                    this._connectContainer = (new kity.Group).setId(utils.uuid("minder_connect_group")),
                    this.getRenderContainer().prependShape(this._connectContainer)
                },
                events: {
                    nodeattach: function(e) {
                        this.createConnect(e.node)
                    },
                    nodedetach: function(e) {
                        this.removeConnect(e.node)
                    },
                    "layoutapply layoutfinish noderender": function(e) {
                        this.updateConnect(e.node)
                    }
                }
            }),
            exports.register = register
        }
    },
    _p[12] = {
        value: function(require, exports, module) {
            function registerProtocol(name, protocol) {
                protocols[name] = protocol;
                for (var pname in protocols)
                    protocols.hasOwnProperty(pname) && (protocols[pname] = protocols[pname],
                    protocols[pname].name = pname)
            }
            function getRegisterProtocol(name) {
                return void 0 === name ? protocols : protocols[name] || null
            }
            var kity = _p.r(17)
              , Minder = (_p.r(33),
            _p.r(19))
              , MinderEvent = (_p.r(21),
            _p.r(13))
              , compatibility = _p.r(10)
              , Promise = _p.r(25)
              , protocols = {};
            exports.registerProtocol = registerProtocol,
            exports.getRegisterProtocol = getRegisterProtocol,
            kity.extendClass(Minder, {
                setup: function(target) {
                    if ("string" == typeof target && (target = document.querySelector(target)),
                    target) {
                        var protocol = target.getAttribute("minder-data-type");
                        if (protocol in protocols) {
                            var data = target.textContent;
                            target.textContent = null,
                            this.renderTo(target),
                            this.importData(protocol, data)
                        }
                        return this
                    }
                },
                exportJson: function() {
                    function exportNode(node) {
                        var exported = {};
                        exported.data = node.getData(),
                        delete exported.data.created;
                        var childNodes = node.getChildren();
                        exported.children = [];
                        for (var i = 0; i < childNodes.length; i++)
                            exported.children.push(exportNode(childNodes[i]));
                        return exported
                    }
                    var json = {
                        root: exportNode(this.getRoot())
                    };
                    return json.template = this.getTemplate(),
                    json.theme = this.getTheme(),
                    json.version = Minder.version,
                    json.extra = this.extra,
                    JSON.parse(JSON.stringify(json))
                },
                Text2Children: function(node, text) {
                    function importChildren(node, children) {
                        for (var i = 0, l = children.length; i < l; i++) {
                            var childNode = minder.createNode(null, node);
                            childNode.setData("text", children[i].data.text || ""),
                            importChildren(childNode, children[i].children)
                        }
                    }
                    if (node instanceof kityminder.Node) {
                        for (var jsonNode, children = [], jsonMap = {}, level = 0, LINE_SPLITTER = /\r|\n|\r\n/, TAB_REGEXP = /^(\t|\x20{4})/, lines = text.split(LINE_SPLITTER), line = "", i = 0, minder = this; void 0 !== (line = lines[i++]); )
                            if (line = line.replace(/&nbsp;/g, ""),
                            !function(line) {
                                return "" === line && !/\S/.test(line)
                            }(line))
                                if (level = function(text) {
                                    for (var level = 0; TAB_REGEXP.test(text); )
                                        text = text.replace(TAB_REGEXP, ""),
                                        level++;
                                    return level
                                }(line),
                                jsonNode = function(line) {
                                    return {
                                        data: {
                                            text: line.replace(/^(\t|\x20{4})+/, "").replace(/(\t|\x20{4})+$/, "")
                                        },
                                        children: []
                                    }
                                }(line),
                                0 === level)
                                    jsonMap = {},
                                    children.push(jsonNode),
                                    jsonMap[0] = children[children.length - 1];
                                else {
                                    if (!jsonMap[level - 1])
                                        throw new Error("Invalid local format");
                                    !function(parent, node) {
                                        parent.children.push(node)
                                    }(jsonMap[level - 1], jsonNode),
                                    jsonMap[level] = jsonNode
                                }
                        importChildren(node, children),
                        minder.refresh()
                    }
                },
                exportNode: function(node) {
                    var exported = {};
                    exported.data = node.getData();
                    var childNodes = node.getChildren();
                    exported.children = [];
                    for (var i = 0; i < childNodes.length; i++)
                        exported.children.push(this.exportNode(childNodes[i]));
                    return exported
                },
                importNode: function(node, json) {
                    var data = json.data;
                    node.data = {};
                    for (var field in data)
                        node.setData(field, data[field]);
                    for (var childrenTreeData = json.children || [], i = 0; i < childrenTreeData.length; i++) {
                        var childNode = this.createNode(null, node);
                        this.importNode(childNode, childrenTreeData[i])
                    }
                    return node
                },
                importJson: function(json) {
                    if (json) {
                        for (this._fire(new MinderEvent("preimport",null,!1)); this._root.getChildren().length; )
                            this.removeNode(this._root.getChildren()[0]);
                        return json = compatibility(json),
                        this.importNode(this._root, json.root),
                        this.setTemplate(json.template || "right"),
                        this.setTheme(json.theme || "fresh-green-compat"),
                        this.refresh(),
                        this.extra = json.extra,
                        this.fire("import"),
                        this._firePharse({
                            type: "contentchange"
                        }),
                        this._interactChange(),
                        this
                    }
                },
                exportData: function(protocolName, option) {
                    var json, protocol;
                    return json = this.exportJson(),
                    !protocolName || (protocol = protocols[protocolName]) && protocol.encode ? (this._fire(new MinderEvent("beforeexport",{
                        json: json,
                        protocolName: protocolName,
                        protocol: protocol
                    })),
                    Promise.resolve(protocol.encode(json, this, option))) : Promise.reject(new Error("Not supported protocol:" + protocolName))
                },
                importData: function(protocolName, data, option) {
                    var protocol, minder = this;
                    if (protocolName && (!(protocol = protocols[protocolName]) || !protocol.decode))
                        return Promise.reject(new Error("Not supported protocol:" + protocolName));
                    var params = {
                        local: data,
                        protocolName: protocolName,
                        protocol: protocol
                    };
                    return this._fire(new MinderEvent("beforeimport",params)),
                    Promise.resolve(protocol.decode(data, this, option)).then(function(json) {
                        return minder.importJson(json),
                        json
                    })
                },
                decodeData: function(protocolName, data, option) {
                    var protocol;
                    if (protocolName && (!(protocol = protocols[protocolName]) || !protocol.decode))
                        return Promise.reject(new Error("Not supported protocol:" + protocolName));
                    var params = {
                        local: data,
                        protocolName: protocolName,
                        protocol: protocol
                    };
                    return this._fire(new MinderEvent("beforeimport",params)),
                    Promise.resolve(protocol.decode(data, this, option))
                }
            })
        }
    },
    _p[13] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = (_p.r(33),
            _p.r(19))
              , MinderEvent = kity.createClass("MindEvent", {
                constructor: function(type, params, canstop) {
                    params = params || {},
                    params.getType && "ShapeEvent" == params.getType() ? (this.kityEvent = params,
                    this.originEvent = params.originEvent) : params.target && params.preventDefault ? this.originEvent = params : kity.Utils.extend(this, params),
                    this.type = type,
                    this._canstop = canstop || !1
                },
                getPosition: function(refer) {
                    if (this.kityEvent)
                        return refer && "minder" != refer ? this.kityEvent.getPosition.call(this.kityEvent, refer) : this.kityEvent.getPosition(this.minder.getRenderContainer())
                },
                getTargetNode: function() {
                    var findShape = this.kityEvent && this.kityEvent.targetShape;
                    if (!findShape)
                        return null;
                    for (; !findShape.minderNode && findShape.container; )
                        findShape = findShape.container;
                    var node = findShape.minderNode;
                    return node && findShape.getOpacity() < 1 ? null : node || null
                },
                stopPropagation: function() {
                    this._stoped = !0
                },
                stopPropagationImmediately: function() {
                    this._immediatelyStoped = !0,
                    this._stoped = !0
                },
                shouldStopPropagation: function() {
                    return this._canstop && this._stoped
                },
                shouldStopPropagationImmediately: function() {
                    return this._canstop && this._immediatelyStoped
                },
                preventDefault: function() {
                    this.originEvent.preventDefault()
                },
                isRightMB: function() {
                    var isRightMB = !1;
                    return !!this.originEvent && ("which"in this.originEvent ? isRightMB = 3 == this.originEvent.which : "button"in this.originEvent && (isRightMB = 2 == this.originEvent.button),
                    isRightMB)
                },
                getKeyCode: function() {
                    var evt = this.originEvent;
                    return evt.keyCode || evt.which
                }
            });
            Minder.registerInitHook(function(option) {
                this._initEvents()
            }),
            kity.extendClass(Minder, {
                _initEvents: function() {
                    this._eventCallbacks = {}
                },
                _resetEvents: function() {
                    this._initEvents(),
                    this._bindEvents()
                },
                _bindEvents: function() {
                    this._paper.on("click dblclick mousedown contextmenu mouseup mousemove mouseover mousewheel DOMMouseScroll touchstart touchmove touchend dragenter dragleave drop", this._firePharse.bind(this)),
                    window && window.addEventListener("resize", this._firePharse.bind(this))
                },
                dispatchKeyEvent: function(e) {
                    this._firePharse(e)
                },
                _firePharse: function(e) {
                    var beforeEvent, preEvent, executeEvent;
                    "DOMMouseScroll" == e.type && (e.type = "mousewheel",
                    e.wheelDelta = e.originEvent.wheelDelta = -10 * e.originEvent.detail,
                    e.wheelDeltaX = e.originEvent.mozMovementX,
                    e.wheelDeltaY = e.originEvent.mozMovementY),
                    beforeEvent = new MinderEvent("before" + e.type,e,!0),
                    this._fire(beforeEvent) || (preEvent = new MinderEvent("pre" + e.type,e,!0),
                    executeEvent = new MinderEvent(e.type,e,!0),
                    (this._fire(preEvent) || this._fire(executeEvent)) && this._fire(new MinderEvent("after" + e.type,e,!1)))
                },
                _interactChange: function(e) {
                    var me = this;
                    me._interactScheduled || (setTimeout(function() {
                        me._fire(new MinderEvent("interactchange")),
                        me._interactScheduled = !1
                    }, 100),
                    me._interactScheduled = !0)
                },
                _listen: function(type, callback) {
                    (this._eventCallbacks[type] || (this._eventCallbacks[type] = [])).push(callback)
                },
                _fire: function(e) {
                    e.minder = this;
                    var status = this.getStatus()
                      , callbacks = this._eventCallbacks[e.type.toLowerCase()] || [];
                    if (status && (callbacks = callbacks.concat(this._eventCallbacks[status + "." + e.type.toLowerCase()] || [])),
                    0 !== callbacks.length) {
                        for (var i = (this.getStatus(),
                        0); i < callbacks.length && (callbacks[i].call(this, e),
                        !e.shouldStopPropagationImmediately()); i++)
                            ;
                        return e.shouldStopPropagation()
                    }
                },
                on: function(name, callback) {
                    var km = this;
                    return name.split(/\s+/).forEach(function(n) {
                        km._listen(n.toLowerCase(), callback)
                    }),
                    this
                },
                off: function(name, callback) {
                    var i, j, callbacks, removeIndex, types = name.split(/\s+/);
                    for (i = 0; i < types.length; i++)
                        if (callbacks = this._eventCallbacks[types[i].toLowerCase()]) {
                            for (removeIndex = null,
                            j = 0; j < callbacks.length; j++)
                                callbacks[j] == callback && (removeIndex = j);
                            null !== removeIndex && callbacks.splice(removeIndex, 1)
                        }
                },
                fire: function(type, params) {
                    var e = new MinderEvent(type,params);
                    return this._fire(e),
                    this
                }
            }),
            module.exports = MinderEvent
        }
    },
    _p[14] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = _p.r(19);
            Minder.registerInitHook(function() {
                this.on("beforemousedown", function(e) {
                    this.focus(),
                    e.preventDefault()
                }),
                this.on("paperrender", function() {
                    this.focus()
                })
            }),
            kity.extendClass(Minder, {
                focus: function() {
                    if (!this.isFocused()) {
                        this._renderTarget.classList.add("focus"),
                        this.renderNodeBatch(this.getSelectedNodes())
                    }
                    return this.fire("focus"),
                    this
                },
                blur: function() {
                    if (this.isFocused()) {
                        this._renderTarget.classList.remove("focus"),
                        this.renderNodeBatch(this.getSelectedNodes())
                    }
                    return this.fire("blur"),
                    this
                },
                isFocused: function() {
                    var renderTarget = this._renderTarget;
                    return renderTarget && renderTarget.classList.contains("focus")
                }
            })
        }
    },
    _p[15] = {
        value: function(require, exports, module) {
            var keymap = {
                Backspace: 8,
                Tab: 9,
                Enter: 13,
                Shift: 16,
                Control: 17,
                Alt: 18,
                CapsLock: 20,
                Esc: 27,
                Spacebar: 32,
                PageUp: 33,
                PageDown: 34,
                End: 35,
                Home: 36,
                Insert: 45,
                Left: 37,
                Up: 38,
                Right: 39,
                Down: 40,
                direction: {
                    37: 1,
                    38: 1,
                    39: 1,
                    40: 1
                },
                Del: 46,
                NumLock: 144,
                Cmd: 91,
                CmdFF: 224,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                "`": 192,
                "=": 187,
                "-": 189,
                "/": 191,
                ".": 190,
                controlKeys: {
                    16: 1,
                    17: 1,
                    18: 1,
                    20: 1,
                    91: 1,
                    224: 1
                },
                notContentChange: {
                    13: 1,
                    9: 1,
                    33: 1,
                    34: 1,
                    35: 1,
                    36: 1,
                    16: 1,
                    17: 1,
                    18: 1,
                    20: 1,
                    91: 1,
                    37: 1,
                    38: 1,
                    39: 1,
                    40: 1,
                    113: 1,
                    114: 1,
                    115: 1,
                    144: 1,
                    27: 1
                },
                isSelectedNodeKey: {
                    37: 1,
                    38: 1,
                    39: 1,
                    40: 1,
                    13: 1,
                    9: 1
                }
            };
            for (var key in keymap)
                keymap.hasOwnProperty(key) && (keymap[key.toLowerCase()] = keymap[key]);
            var aCharCode = "a".charCodeAt(0);
            "abcdefghijklmnopqrstuvwxyz".split("").forEach(function(letter) {
                keymap[letter] = letter.charCodeAt(0) - aCharCode + 65
            });
            var n = 9;
            do {
                keymap[n.toString()] = n + 48
            } while (--n);
            module.exports = keymap
        }
    },
    _p[16] = {
        value: function(require, exports, module) {
            function listen(element, type, handler) {
                type.split(" ").forEach(function(name) {
                    element.addEventListener(name, handler, !1)
                })
            }
            var kity = _p.r(17)
              , Minder = (_p.r(33),
            _p.r(19));
            Minder.registerInitHook(function(option) {
                this.setDefaultOptions({
                    enableKeyReceiver: !0
                }),
                this.getOption("enableKeyReceiver") && this.on("paperrender", function() {
                    this._initKeyReceiver()
                })
            }),
            kity.extendClass(Minder, {
                _initKeyReceiver: function() {
                    if (!this._keyReceiver) {
                        var receiver = this._keyReceiver = document.createElement("input");
                        receiver.classList.add("km-receiver");
                        this._renderTarget.appendChild(receiver);
                        var minder = this;
                        listen(receiver, "keydown keyup keypress copy paste blur focus input", function(e) {
                            switch (e.type) {
                            case "blur":
                                minder.blur();
                                break;
                            case "focus":
                                minder.focus();
                                break;
                            case "input":
                                receiver.value = null
                            }
                            minder._firePharse(e),
                            e.preventDefault()
                        }),
                        this.on("focus", function() {
                            receiver.select(),
                            receiver.focus()
                        }),
                        this.on("blur", function() {
                            receiver.blur()
                        }),
                        this.isFocused() && (receiver.select(),
                        receiver.focus())
                    }
                }
            })
        }
    },
    _p[17] = {
        value: function(require, exports, module) {
            module.exports = window.kity
        }
    },
    _p[18] = {
        value: function(require, exports, module) {
            function register(name, layout) {
                _layouts[name] = layout,
                _defaultLayout = _defaultLayout || name
            }
            var _defaultLayout, kity = _p.r(17), utils = _p.r(33), Minder = _p.r(19), MinderNode = _p.r(21), _layouts = (_p.r(13),
            _p.r(9),
            {}), Layout = kity.createClass("Layout", {
                doLayout: function(parent, children) {
                    throw new Error("Not Implement: Layout.doLayout()")
                },
                align: function(nodes, border, offset) {
                    var me = this;
                    offset = offset || 0,
                    nodes.forEach(function(node) {
                        var tbox = me.getTreeBox([node])
                          , matrix = node.getLayoutTransform();
                        switch (border) {
                        case "left":
                            return matrix.translate(offset - tbox.left, 0);
                        case "right":
                            return matrix.translate(offset - tbox.right, 0);
                        case "top":
                            return matrix.translate(0, offset - tbox.top);
                        case "bottom":
                            return matrix.translate(0, offset - tbox.bottom)
                        }
                    })
                },
                stack: function(nodes, axis, distance) {
                    var me = this
                      , position = 0;
                    return distance = distance || function(node, next, axis) {
                        return node.getStyle({
                            x: "margin-right",
                            y: "margin-bottom"
                        }[axis]) + next.getStyle({
                            x: "margin-left",
                            y: "margin-top"
                        }[axis])
                    }
                    ,
                    nodes.forEach(function(node, index, nodes) {
                        var tbox = me.getTreeBox([node])
                          , size = {
                            x: tbox.width,
                            y: tbox.height
                        }[axis]
                          , offset = {
                            x: tbox.left,
                            y: tbox.top
                        }[axis]
                          , matrix = node.getLayoutTransform();
                        "x" == axis ? matrix.translate(position - offset, 0) : matrix.translate(0, position - offset),
                        position += size,
                        nodes[index + 1] && (position += distance(node, nodes[index + 1], axis))
                    }),
                    position
                },
                move: function(nodes, dx, dy) {
                    nodes.forEach(function(node) {
                        node.getLayoutTransform().translate(dx, dy)
                    })
                },
                getBranchBox: function(nodes) {
                    var i, node, matrix, contentBox, box = new kity.Box;
                    for (i = 0; i < nodes.length; i++)
                        node = nodes[i],
                        matrix = node.getLayoutTransform(),
                        contentBox = node.getContentBox(),
                        box = box.merge(matrix.transformBox(contentBox));
                    return box
                },
                getTreeBox: function(nodes) {
                    var i, node, matrix, treeBox, box = new kity.Box;
                    for (nodes instanceof Array || (nodes = [nodes]),
                    i = 0; i < nodes.length; i++)
                        node = nodes[i],
                        matrix = node.getLayoutTransform(),
                        treeBox = node.getContentBox(),
                        node.isExpanded() && node.children.length && (treeBox = treeBox.merge(this.getTreeBox(node.children))),
                        box = box.merge(matrix.transformBox(treeBox));
                    return box
                },
                getOrderHint: function(node) {
                    return []
                }
            });
            Layout.register = register,
            Minder.registerInitHook(function(options) {
                this.refresh()
            }),
            utils.extend(Minder, {
                getLayoutList: function() {
                    return _layouts
                },
                getLayoutInstance: function(name) {
                    var LayoutClass = _layouts[name];
                    if (!LayoutClass)
                        throw new Error("Missing Layout: " + name);
                    return new LayoutClass
                }
            }),
            kity.extendClass(MinderNode, {
                getLayout: function() {
                    var layout = this.getData("layout");
                    return layout = layout || (this.isRoot() ? _defaultLayout : this.parent.getLayout())
                },
                setLayout: function(name) {
                    return name && ("inherit" == name ? this.setData("layout") : this.setData("layout", name)),
                    this
                },
                layout: function(name) {
                    return this.setLayout(name).getMinder().layout(),
                    this
                },
                getLayoutInstance: function() {
                    return Minder.getLayoutInstance(this.getLayout())
                },
                getOrderHint: function(refer) {
                    return this.parent.getLayoutInstance().getOrderHint(this)
                },
                getLayoutTransform: function() {
                    return this._layoutTransform || new kity.Matrix
                },
                getGlobalLayoutTransformPreview: function() {
                    var pMatrix = this.parent ? this.parent.getLayoutTransform() : new kity.Matrix
                      , matrix = this.getLayoutTransform()
                      , offset = this.getLayoutOffset();
                    return offset && (matrix = matrix.clone().translate(offset.x, offset.y)),
                    pMatrix.merge(matrix)
                },
                getLayoutPointPreview: function() {
                    return this.getGlobalLayoutTransformPreview().transformPoint(new kity.Point)
                },
                getGlobalLayoutTransform: function() {
                    return this._globalLayoutTransform ? this._globalLayoutTransform : this.parent ? this.parent.getGlobalLayoutTransform() : new kity.Matrix
                },
                setLayoutTransform: function(matrix) {
                    return this._layoutTransform = matrix,
                    this
                },
                setGlobalLayoutTransform: function(matrix) {
                    return this.getRenderContainer().setMatrix(this._globalLayoutTransform = matrix),
                    this
                },
                setVertexIn: function(p) {
                    this._vertexIn = p
                },
                setVertexOut: function(p) {
                    this._vertexOut = p
                },
                getVertexIn: function() {
                    return this._vertexIn || new kity.Point
                },
                getVertexOut: function() {
                    return this._vertexOut || new kity.Point
                },
                getLayoutVertexIn: function() {
                    return this.getGlobalLayoutTransform().transformPoint(this.getVertexIn())
                },
                getLayoutVertexOut: function() {
                    return this.getGlobalLayoutTransform().transformPoint(this.getVertexOut())
                },
                setLayoutVectorIn: function(v) {
                    return this._layoutVectorIn = v,
                    this
                },
                setLayoutVectorOut: function(v) {
                    return this._layoutVectorOut = v,
                    this
                },
                getLayoutVectorIn: function() {
                    return this._layoutVectorIn || new kity.Vector
                },
                getLayoutVectorOut: function() {
                    return this._layoutVectorOut || new kity.Vector
                },
                getLayoutBox: function() {
                    return this.getGlobalLayoutTransform().transformBox(this.getContentBox())
                },
                getLayoutPoint: function() {
                    return this.getGlobalLayoutTransform().transformPoint(new kity.Point)
                },
                getLayoutOffset: function() {
                    if (!this.parent)
                        return new kity.Point;
                    var data = this.getData("layout_" + this.parent.getLayout() + "_offset");
                    return data ? new kity.Point(data.x,data.y) : new kity.Point
                },
                setLayoutOffset: function(p) {
                    return this.parent ? (this.setData("layout_" + this.parent.getLayout() + "_offset", p ? {
                        x: p.x,
                        y: p.y
                    } : void 0),
                    this) : this
                },
                hasLayoutOffset: function() {
                    return !!this.getData("layout_" + this.parent.getLayout() + "_offset")
                },
                resetLayoutOffset: function() {
                    return this.setLayoutOffset(null)
                },
                getLayoutRoot: function() {
                    return this.isLayoutRoot() ? this : this.parent.getLayoutRoot()
                },
                isLayoutRoot: function() {
                    return this.getData("layout") || this.isRoot()
                }
            }),
            kity.extendClass(Minder, {
                layout: function() {
                    function layoutNode(node, round) {
                        node.isExpanded(),
                        node.children.forEach(function(child) {
                            layoutNode(child, round)
                        }),
                        node.getLayoutInstance().doLayout(node, node.getChildren(), round)
                    }
                    var duration = this.getOption("layoutAnimationDuration");
                    this.getRoot().traverse(function(node) {
                        node.setLayoutTransform(null)
                    }),
                    layoutNode(this.getRoot(), 1),
                    layoutNode(this.getRoot(), 2);
                    var minder = this;
                    return this.applyLayoutResult(this.getRoot(), duration, function() {
                        setTimeout(function() {
                            minder.fire("layoutallfinish")
                        }, 0)
                    }),
                    this.fire("layout")
                },
                refresh: function() {
                    return this.getRoot().renderTree(),
                    this.layout().fire("contentchange")._interactChange(),
                    this
                },
                applyLayoutResult: function(root, duration, callback) {
                    function consume() {
                        --complex || callback && callback()
                    }
                    function applyMatrix(node, matrix) {
                        node.setGlobalLayoutTransform(matrix),
                        me.fire("layoutapply", {
                            node: node,
                            matrix: matrix
                        })
                    }
                    function apply(node, pMatrix) {
                        var matrix = node.getLayoutTransform().merge(pMatrix.clone())
                          , lastMatrix = node.getGlobalLayoutTransform() || new kity.Matrix
                          , offset = node.getLayoutOffset();
                        matrix.translate(offset.x, offset.y),
                        matrix.m.e = Math.round(matrix.m.e),
                        matrix.m.f = Math.round(matrix.m.f),
                        node._layoutTimeline && (node._layoutTimeline.stop(),
                        node._layoutTimeline = null),
                        duration ? node._layoutTimeline = new kity.Animator(lastMatrix,matrix,applyMatrix).start(node, duration, "ease").on("finish", function() {
                            setTimeout(function() {
                                applyMatrix(node, matrix),
                                me.fire("layoutfinish", {
                                    node: node,
                                    matrix: matrix
                                }),
                                consume()
                            }, 150)
                        }) : (applyMatrix(node, matrix),
                        me.fire("layoutfinish", {
                            node: node,
                            matrix: matrix
                        }),
                        consume());
                        for (var i = 0; i < node.children.length; i++)
                            apply(node.children[i], matrix)
                    }
                    root = root || this.getRoot();
                    var me = this
                      , complex = root.getComplex();
                    return complex > 200 && (duration = 0),
                    apply(root, root.parent ? root.parent.getGlobalLayoutTransform() : new kity.Matrix),
                    this
                }
            }),
            module.exports = Layout
        }
    },
    _p[19] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , _initHooks = []
              , Minder = kity.createClass("Minder", {
                constructor: function(options) {
                    this._options = utils.extend({}, options);
                    for (var initHook, initHooks = _initHooks.slice(); initHooks.length; )
                        "function" == typeof (initHook = initHooks.shift()) && initHook.call(this, this._options);
                    this.fire("finishInitHook")
                }
            });
            Minder.version = "0",
            Minder.registerInitHook = function(hook) {
                _initHooks.push(hook)
            }
            ,
            module.exports = Minder
        }
    },
    _p[20] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Minder = _p.r(19)
              , _modules = {};
            exports.register = function(name, module) {
                _modules[name] = module
            }
            ,
            Minder.registerInitHook(function() {
                this._initModules()
            }),
            kity.extendClass(Minder, {
                _initModules: function() {
                    var modulesPool = _modules
                      , modulesToLoad = this._options.modules || utils.keys(modulesPool);
                    this._commands = {},
                    this._query = {},
                    this._modules = {},
                    this._rendererClasses = {};
                    var i, name, type, moduleDeals, dealCommands, dealEvents, dealRenderers, me = this;
                    for (i = 0; i < modulesToLoad.length; i++)
                        if (name = modulesToLoad[i],
                        modulesPool[name] && (moduleDeals = "function" == typeof modulesPool[name] ? modulesPool[name].call(me) : modulesPool[name],
                        this._modules[name] = moduleDeals,
                        moduleDeals)) {
                            moduleDeals.defaultOptions && me.setDefaultOptions(moduleDeals.defaultOptions),
                            moduleDeals.init && moduleDeals.init.call(me, this._options),
                            dealCommands = moduleDeals.commands;
                            for (name in dealCommands)
                                this._commands[name.toLowerCase()] = new dealCommands[name];
                            if (dealEvents = moduleDeals.events)
                                for (type in dealEvents)
                                    me.on(type, dealEvents[type]);
                            if (dealRenderers = moduleDeals.renderers)
                                for (type in dealRenderers)
                                    this._rendererClasses[type] = this._rendererClasses[type] || [],
                                    utils.isArray(dealRenderers[type]) ? this._rendererClasses[type] = this._rendererClasses[type].concat(dealRenderers[type]) : this._rendererClasses[type].push(dealRenderers[type]);
                            moduleDeals.commandShortcutKeys && this.addCommandShortcutKeys(moduleDeals.commandShortcutKeys)
                        }
                },
                _garbage: function() {
                    for (this.clearSelect(); this._root.getChildren().length; )
                        this._root.removeChild(0)
                },
                destroy: function() {
                    var modules = this._modules;
                    this._resetEvents(),
                    this._garbage();
                    for (var key in modules)
                        modules[key].destroy && modules[key].destroy.call(this)
                },
                reset: function() {
                    var modules = this._modules;
                    this._garbage();
                    for (var key in modules)
                        modules[key].reset && modules[key].reset.call(this)
                }
            })
        }
    },
    _p[21] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Minder = _p.r(19)
              , MinderNode = kity.createClass("MinderNode", {
                constructor: function(textOrData) {
                    this.parent = null,
                    this.root = this,
                    this.children = [],
                    this.data = {
                        id: utils.guid(),
                        created: +new Date
                    },
                    this.initContainers(),
                    utils.isString(textOrData) ? this.setText(textOrData) : utils.isObject(textOrData) && utils.extend(this.data, textOrData)
                },
                initContainers: function() {
                    this.rc = (new kity.Group).setId(utils.uuid("minder_node")),
                    this.rc.minderNode = this
                },
                isRoot: function() {
                    return this.root === this
                },
                isLeaf: function() {
                    return 0 === this.children.length
                },
                getRoot: function() {
                    return this.root || this
                },
                getParent: function() {
                    return this.parent
                },
                getSiblings: function() {
                    var children = this.parent.children
                      , siblings = []
                      , self = this;
                    return children.forEach(function(child) {
                        child != self && siblings.push(child)
                    }),
                    siblings
                },
                getLevel: function() {
                    for (var level = 0, ancestor = this.parent; ancestor; )
                        level++,
                        ancestor = ancestor.parent;
                    return level
                },
                getComplex: function() {
                    var complex = 0;
                    return this.traverse(function() {
                        complex++
                    }),
                    complex
                },
                getType: function(type) {
                    return this.type = ["root", "main", "sub"][Math.min(this.getLevel(), 2)],
                    this.type
                },
                isAncestorOf: function(test) {
                    for (var ancestor = test.parent; ancestor; ) {
                        if (ancestor == this)
                            return !0;
                        ancestor = ancestor.parent
                    }
                    return !1
                },
                getData: function(key) {
                    return key ? this.data[key] : this.data
                },
                setData: function(key, value) {
                    if ("object" == typeof key) {
                        var data = key;
                        for (key in data)
                            data.hasOwnProperty(key) && (this.data[key] = data[key])
                    } else
                        this.data[key] = value;
                    return this
                },
                setText: function(text) {
                    return this.data.text = text
                },
                getText: function() {
                    return this.data.text || null
                },
                preTraverse: function(fn, excludeThis) {
                    var children = this.getChildren();
                    excludeThis || fn(this);
                    for (var i = 0; i < children.length; i++)
                        children[i].preTraverse(fn)
                },
                postTraverse: function(fn, excludeThis) {
                    for (var children = this.getChildren(), i = 0; i < children.length; i++)
                        children[i].postTraverse(fn);
                    excludeThis || fn(this)
                },
                traverse: function(fn, excludeThis) {
                    return this.postTraverse(fn, excludeThis)
                },
                getChildren: function() {
                    return this.children
                },
                getIndex: function() {
                    return this.parent ? this.parent.children.indexOf(this) : -1
                },
                insertChild: function(node, index) {
                    void 0 === index && (index = this.children.length),
                    node.parent && node.parent.removeChild(node),
                    node.parent = this,
                    node.root = this.root,
                    this.children.splice(index, 0, node)
                },
                appendChild: function(node) {
                    return this.insertChild(node)
                },
                prependChild: function(node) {
                    return this.insertChild(node, 0)
                },
                removeChild: function(elem) {
                    var removed, index = elem;
                    elem instanceof MinderNode && (index = this.children.indexOf(elem)),
                    index >= 0 && (removed = this.children.splice(index, 1)[0],
                    removed.parent = null,
                    removed.root = removed)
                },
                clearChildren: function() {
                    this.children = []
                },
                getChild: function(index) {
                    return this.children[index]
                },
                getRenderContainer: function() {
                    return this.rc
                },
                getCommonAncestor: function(node) {
                    return MinderNode.getCommonAncestor(this, node)
                },
                contains: function(node) {
                    return this == node || this.isAncestorOf(node)
                },
                clone: function() {
                    var cloned = new MinderNode;
                    return cloned.data = utils.clone(this.data),
                    this.children.forEach(function(child) {
                        cloned.appendChild(child.clone())
                    }),
                    cloned
                },
                compareTo: function(node) {
                    if (!utils.comparePlainObject(this.data, node.data))
                        return !1;
                    if (!utils.comparePlainObject(this.temp, node.temp))
                        return !1;
                    if (this.children.length != node.children.length)
                        return !1;
                    for (var i = 0; this.children[i]; ) {
                        if (!this.children[i].compareTo(node.children[i]))
                            return !1;
                        i++
                    }
                    return !0
                },
                getMinder: function() {
                    return this.getRoot().minder
                }
            });
            MinderNode.getCommonAncestor = function(nodeA, nodeB) {
                if (nodeA instanceof Array)
                    return MinderNode.getCommonAncestor.apply(this, nodeA);
                switch (arguments.length) {
                case 1:
                    return nodeA.parent || nodeA;
                case 2:
                    if (nodeA.isAncestorOf(nodeB))
                        return nodeA;
                    if (nodeB.isAncestorOf(nodeA))
                        return nodeB;
                    for (var ancestor = nodeA.parent; ancestor && !ancestor.isAncestorOf(nodeB); )
                        ancestor = ancestor.parent;
                    return ancestor;
                default:
                    return Array.prototype.reduce.call(arguments, function(prev, current) {
                        return MinderNode.getCommonAncestor(prev, current)
                    }, nodeA)
                }
            }
            ,
            kity.extendClass(Minder, {
                getRoot: function() {
                    return this._root
                },
                setRoot: function(root) {
                    this._root = root,
                    root.minder = this
                },
                getAllNode: function() {
                    var nodes = [];
                    return this.getRoot().traverse(function(node) {
                        nodes.push(node)
                    }),
                    nodes
                },
                getNodeById: function(id) {
                    return this.getNodesById([id])[0]
                },
                getNodesById: function(ids) {
                    var nodes = this.getAllNode()
                      , result = [];
                    return nodes.forEach(function(node) {
                        -1 != ids.indexOf(node.getData("id")) && result.push(node)
                    }),
                    result
                },
                createNode: function(textOrData, parent, index) {
                    var node = new MinderNode(textOrData);
                    return this.fire("nodecreate", {
                        node: node,
                        parent: parent,
                        index: index
                    }),
                    this.appendNode(node, parent, index),
                    node
                },
                appendNode: function(node, parent, index) {
                    return parent && parent.insertChild(node, index),
                    this.attachNode(node),
                    this
                },
                removeNode: function(node) {
                    node.parent && (node.parent.removeChild(node),
                    this.detachNode(node),
                    this.fire("noderemove", {
                        node: node
                    }))
                },
                attachNode: function(node) {
                    var rc = this.getRenderContainer();
                    node.traverse(function(current) {
                        current.attached = !0,
                        rc.addShape(current.getRenderContainer())
                    }),
                    rc.addShape(node.getRenderContainer()),
                    this.fire("nodeattach", {
                        node: node
                    })
                },
                detachNode: function(node) {
                    var rc = this.getRenderContainer();
                    node.traverse(function(current) {
                        current.attached = !1,
                        rc.removeShape(current.getRenderContainer())
                    }),
                    this.fire("nodedetach", {
                        node: node
                    })
                },
                getMinderTitle: function() {
                    return this.getRoot().getText()
                }
            }),
            module.exports = MinderNode
        }
    },
    _p[22] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Minder = _p.r(19);
            Minder.registerInitHook(function(options) {
                this._defaultOptions = {}
            }),
            kity.extendClass(Minder, {
                setDefaultOptions: function(options) {
                    return utils.extend(this._defaultOptions, options),
                    this
                },
                getOption: function(key) {
                    return key ? key in this._options ? this._options[key] : this._defaultOptions[key] : utils.extend({}, this._defaultOptions, this._options)
                },
                setOption: function(key, value) {
                    this._options[key] = value
                }
            })
        }
    },
    _p[23] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Minder = _p.r(19);
            Minder.registerInitHook(function() {
                this._initPaper()
            }),
            kity.extendClass(Minder, {
                _initPaper: function() {
                    this._paper = new kity.Paper,
                    this._paper._minder = this,
                    this._paper.getNode().ondragstart = function(e) {
                        e.preventDefault()
                    }
                    ,
                    this._paper.shapeNode.setAttribute("transform", "translate(0.5, 0.5)"),
                    this._addRenderContainer(),
                    this.setRoot(this.createNode()),
                    this._options.renderTo && this.renderTo(this._options.renderTo)
                },
                _addRenderContainer: function() {
                    this._rc = (new kity.Group).setId(utils.uuid("minder")),
                    this._paper.addShape(this._rc)
                },
                renderTo: function(target) {
                    if ("string" == typeof target && (target = document.querySelector(target)),
                    target) {
                        if ("script" == target.tagName.toLowerCase()) {
                            var newTarget = document.createElement("div");
                            newTarget.id = target.id,
                            newTarget.class = target.class,
                            target.parentNode.insertBefore(newTarget, target),
                            target.parentNode.removeChild(target),
                            target = newTarget
                        }
                        target.classList.add("km-view"),
                        this._paper.renderTo(this._renderTarget = target),
                        this._bindEvents(),
                        this.fire("paperrender")
                    }
                    return this
                },
                getRenderContainer: function() {
                    return this._rc
                },
                getPaper: function() {
                    return this._paper
                },
                getRenderTarget: function() {
                    return this._renderTarget
                }
            })
        }
    },
    _p[24] = {
        value: function(require, exports, module) {
            function insertNode(minder, info, parent, index) {
                return parent = minder.createNode(info.data, parent, index),
                info.children.forEach(function(childInfo, index) {
                    insertNode(minder, childInfo, parent, index)
                }),
                parent
            }
            function applyPatch(minder, patch) {
                var path = patch.path.split("/");
                path.shift();
                var node, changed = path.shift();
                if ("root" == changed) {
                    var dataIndex = path.indexOf("data");
                    if (dataIndex > -1) {
                        changed = "data";
                        var dataPath = path.splice(dataIndex + 1);
                        patch.dataPath = dataPath
                    } else
                        changed = "node";
                    node = minder.getRoot();
                    for (var segment, index; segment = path.shift(); )
                        "children" != segment && (void 0 !== index && (node = node.getChild(index)),
                        index = +segment);
                    patch.index = index,
                    patch.node = node
                }
                switch (patch.express = [changed, patch.op].join(".")) {
                case "theme.replace":
                    minder.useTheme(patch.value);
                    break;
                case "template.replace":
                    minder.useTemplate(patch.value);
                    break;
                case "node.add":
                    insertNode(minder, patch.value, patch.node, patch.index).renderTree(),
                    minder.layout();
                    break;
                case "node.remove":
                    minder.removeNode(patch.node.getChild(patch.index)),
                    minder.layout();
                    break;
                case "data.add":
                case "data.replace":
                case "data.remove":
                    var field, data = patch.node.data;
                    for (path = patch.dataPath.slice(); data && path.length > 1; )
                        field = path.shift(),
                        field in data ? data = data[field] : "remove" != patch.op && (data = data[field] = {});
                    data && (field = path.shift(),
                    data[field] = patch.value),
                    "expandState" == field ? node.renderTree() : node.render(),
                    minder.layout()
                }
                minder.fire("patch", {
                    patch: patch
                })
            }
            var kity = _p.r(17)
              , Minder = _p.r(19);
            kity.extendClass(Minder, {
                applyPatches: function(patches) {
                    for (var i = 0; i < patches.length; i++)
                        applyPatch(this, patches[i]);
                    return this.fire("contentchange"),
                    this
                }
            })
        }
    },
    _p[25] = {
        value: function(require, exports, module) {
            var Promise = function(executor) {
                if (!(this instanceof Promise))
                    return new Promise(executor);
                this.id = "Thenable/1.0.7",
                this.state = 0,
                this.fulfillValue = void 0,
                this.rejectReason = void 0,
                this.onFulfilled = [],
                this.onRejected = [],
                "function" == typeof executor && executor.call(this, this.fulfill.bind(this), this.reject.bind(this))
            };
            Promise.prototype = {
                fulfill: function(value) {
                    return deliver(this, 1, "fulfillValue", value)
                },
                reject: function(value) {
                    return deliver(this, 2, "rejectReason", value)
                },
                then: function(onFulfilled, onRejected) {
                    var curr = this
                      , next = new Promise;
                    return curr.onFulfilled.push(resolver(onFulfilled, next, "fulfill")),
                    curr.onRejected.push(resolver(onRejected, next, "reject")),
                    execute(curr),
                    next
                }
            },
            Promise.all = function(arr) {
                return new Promise(function(resolve, reject) {
                    var len = arr.length
                      , i = 0
                      , res = 0
                      , results = [];
                    for (0 === len && resolve(results); i < len; )
                        arr[i].then(function(result) {
                            results.push(result),
                            ++res === len && resolve(results)
                        }, function(val) {
                            reject(val)
                        }),
                        i++
                }
                )
            }
            ;
            var deliver = function(curr, state, name, value) {
                return 0 === curr.state && (curr.state = state,
                curr[name] = value,
                execute(curr)),
                curr
            }
              , execute = function(curr) {
                1 === curr.state ? execute_handlers(curr, "onFulfilled", curr.fulfillValue) : 2 === curr.state && execute_handlers(curr, "onRejected", curr.rejectReason)
            }
              , execute_handlers = function(curr, name, value) {
                if (0 !== curr[name].length) {
                    var handlers = curr[name];
                    curr[name] = [];
                    var func = function() {
                        for (var i = 0; i < handlers.length; i++)
                            handlers[i](value)
                    };
                    "object" == typeof process && "function" == typeof process.nextTick ? process.nextTick(func) : "function" == typeof setImmediate ? setImmediate(func) : setTimeout(func, 0)
                }
            }
              , resolver = function(cb, next, method) {
                return function(value) {
                    if ("function" != typeof cb)
                        next[method].call(next, value);
                    else {
                        var result;
                        try {
                            result = value instanceof Promise ? value.then(cb) : cb(value)
                        } catch (e) {
                            return void next.reject(e)
                        }
                        resolve(next, result)
                    }
                }
            }
              , resolve = function(promise, x) {
                if (promise === x)
                    return void promise.reject(new TypeError("cannot resolve promise with itself"));
                var then;
                if ("object" == typeof x && null !== x || "function" == typeof x)
                    try {
                        then = x.then
                    } catch (e) {
                        return void promise.reject(e)
                    }
                if ("function" != typeof then)
                    promise.fulfill(x);
                else {
                    var resolved = !1;
                    try {
                        then.call(x, function(y) {
                            resolved || (resolved = !0,
                            y === x ? promise.reject(new TypeError("circular thenable chain")) : resolve(promise, y))
                        }, function(r) {
                            resolved || (resolved = !0,
                            promise.reject(r))
                        })
                    } catch (e) {
                        resolved || promise.reject(e)
                    }
                }
            };
            Promise.resolve = function(value) {
                return new Promise(function(resolve) {
                    resolve(value)
                }
                )
            }
            ,
            Promise.reject = function(reason) {
                return new Promise(function(resolve, reject) {
                    reject(reason)
                }
                )
            }
            ,
            module.exports = Promise
        }
    },
    _p[26] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = _p.r(19);
            _p.r(13);
            Minder.registerInitHook(function(options) {
                options.readOnly && this.setDisabled()
            }),
            kity.extendClass(Minder, {
                disable: function() {
                    var me = this;
                    me.bkqueryCommandState = me.queryCommandState,
                    me.bkqueryCommandValue = me.queryCommandValue,
                    me.queryCommandState = function(type) {
                        var cmd = this._getCommand(type);
                        return cmd && cmd.enableReadOnly ? me.bkqueryCommandState.apply(me, arguments) : -1
                    }
                    ,
                    me.queryCommandValue = function(type) {
                        var cmd = this._getCommand(type);
                        return cmd && cmd.enableReadOnly ? me.bkqueryCommandValue.apply(me, arguments) : null
                    }
                    ,
                    this.setStatus("readonly"),
                    me._interactChange()
                },
                enable: function() {
                    var me = this;
                    me.bkqueryCommandState && (me.queryCommandState = me.bkqueryCommandState,
                    delete me.bkqueryCommandState),
                    me.bkqueryCommandValue && (me.queryCommandValue = me.bkqueryCommandValue,
                    delete me.bkqueryCommandValue),
                    this.setStatus("normal"),
                    me._interactChange()
                }
            })
        }
    },
    _p[27] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = _p.r(19)
              , MinderNode = _p.r(21)
              , Renderer = kity.createClass("Renderer", {
                constructor: function(node) {
                    this.node = node
                },
                create: function(node) {
                    throw new Error("Not implement: Renderer.create()")
                },
                shouldRender: function(node) {
                    return !0
                },
                watchChange: function(data) {
                    void 0 === this.watchingData || this.watchingData,
                    this.watchingData = data
                },
                shouldDraw: function(node) {
                    return !0
                },
                update: function(shape, node, box) {
                    return this.shouldDraw() && this.draw(shape, node),
                    this.place(shape, node, box)
                },
                draw: function(shape, node) {
                    throw new Error("Not implement: Renderer.draw()")
                },
                place: function(shape, node, box) {
                    throw new Error("Not implement: Renderer.place()")
                },
                getRenderShape: function() {
                    return this._renderShape || null
                },
                setRenderShape: function(shape) {
                    this._renderShape = shape
                }
            });
            kity.extendClass(Minder, function() {
                function createRendererForNode(node, registered) {
                    var renderers = [];
                    ["center", "left", "right", "top", "bottom", "outline", "outside"].forEach(function(section) {
                        var before = "before" + section
                          , after = "after" + section;
                        registered[before] && (renderers = renderers.concat(registered[before])),
                        registered[section] && (renderers = renderers.concat(registered[section])),
                        registered[after] && (renderers = renderers.concat(registered[after]))
                    }),
                    node._renderers = renderers.map(function(Renderer) {
                        return new Renderer(node)
                    })
                }
                return {
                    renderNodeBatch: function(nodes) {
                        var i, j, renderer, node, rendererClasses = this._rendererClasses, lastBoxes = [], rendererCount = 0;
                        if (nodes.length) {
                            for (j = 0; j < nodes.length; j++)
                                node = nodes[j],
                                node._renderers || createRendererForNode(node, rendererClasses),
                                node._contentBox = new kity.Box,
                                this.fire("beforerender", {
                                    node: node
                                });
                            for (rendererCount = nodes[0]._renderers.length,
                            i = 0; i < rendererCount; i++) {
                                for (j = 0; j < nodes.length; j++)
                                    "function" == typeof lastBoxes[j] && (lastBoxes[j] = lastBoxes[j]()),
                                    lastBoxes[j]instanceof kity.Box || (lastBoxes[j] = new kity.Box(lastBoxes[j]));
                                for (j = 0; j < nodes.length; j++)
                                    node = nodes[j],
                                    renderer = node._renderers[i],
                                    lastBoxes[j] && (node._contentBox = node._contentBox.merge(lastBoxes[j]),
                                    renderer.contentBox = lastBoxes[j]),
                                    renderer.shouldRender(node) ? (renderer.getRenderShape() || (renderer.setRenderShape(renderer.create(node)),
                                    renderer.bringToBack ? node.getRenderContainer().prependShape(renderer.getRenderShape()) : node.getRenderContainer().appendShape(renderer.getRenderShape())),
                                    renderer.getRenderShape().setVisible(!0),
                                    lastBoxes[j] = renderer.update(renderer.getRenderShape(), node, node._contentBox)) : renderer.getRenderShape() && (renderer.getRenderShape().setVisible(!1),
                                    lastBoxes[j] = null)
                            }
                            for (j = 0; j < nodes.length; j++)
                                this.fire("noderender", {
                                    node: nodes[j]
                                })
                        }
                    },
                    renderNode: function(node) {
                        var latestBox, rendererClasses = this._rendererClasses;
                        node._renderers || createRendererForNode(node, rendererClasses),
                        this.fire("beforerender", {
                            node: node
                        }),
                        node._contentBox = new kity.Box,
                        node._renderers.forEach(function(renderer) {
                            renderer.shouldRender(node) ? (renderer.getRenderShape() || (renderer.setRenderShape(renderer.create(node)),
                            renderer.bringToBack ? node.getRenderContainer().prependShape(renderer.getRenderShape()) : node.getRenderContainer().appendShape(renderer.getRenderShape())),
                            renderer.getRenderShape().setVisible(!0),
                            latestBox = renderer.update(renderer.getRenderShape(), node, node._contentBox),
                            "function" == typeof latestBox && (latestBox = latestBox()),
                            latestBox && (node._contentBox = node._contentBox.merge(latestBox),
                            renderer.contentBox = latestBox)) : renderer.getRenderShape() && renderer.getRenderShape().setVisible(!1)
                        }),
                        this.fire("noderender", {
                            node: node
                        })
                    }
                }
            }()),
            kity.extendClass(MinderNode, {
                render: function() {
                    if (this.attached)
                        return this.getMinder().renderNode(this),
                        this
                },
                renderTree: function() {
                    if (this.attached) {
                        var list = [];
                        return this.traverse(function(node) {
                            list.push(node)
                        }),
                        this.getMinder().renderNodeBatch(list),
                        this
                    }
                },
                getRenderer: function(type) {
                    var rs = this._renderers;
                    if (!rs)
                        return null;
                    for (var i = 0; i < rs.length; i++)
                        if (rs[i].getType() == type)
                            return rs[i];
                    return null
                },
                getContentBox: function() {
                    return this.parent && this.parent.isCollapsed() ? new kity.Box : this._contentBox || new kity.Box
                },
                getRenderBox: function(rendererType, refer) {
                    var renderer = rendererType && this.getRenderer(rendererType)
                      , contentBox = renderer ? renderer.contentBox : this.getContentBox();
                    return kity.Matrix.getCTM(this.getRenderContainer(), refer || "paper").transformBox(contentBox)
                }
            }),
            module.exports = Renderer
        }
    },
    _p[28] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Minder = _p.r(19)
              , MinderNode = _p.r(21);
            Minder.registerInitHook(function() {
                this._initSelection()
            }),
            kity.extendClass(Minder, {
                _initSelection: function() {
                    this._selectedNodes = []
                },
                renderChangedSelection: function(last) {
                    var current = this.getSelectedNodes()
                      , changed = [];
                    for (current.forEach(function(node) {
                        -1 == last.indexOf(node) && changed.push(node)
                    }),
                    last.forEach(function(node) {
                        -1 == current.indexOf(node) && changed.push(node)
                    }),
                    changed.length && (this._interactChange(),
                    this.fire("selectionchange")); changed.length; )
                        changed.shift().render()
                },
                getSelectedNodes: function() {
                    return this._selectedNodes
                },
                getSelectedNode: function() {
                    return this.getSelectedNodes()[0] || null
                },
                removeAllSelectedNodes: function() {
                    var last = this._selectedNodes.splice(0);
                    return this._selectedNodes = [],
                    this.renderChangedSelection(last),
                    this.fire("selectionclear")
                },
                removeSelectedNodes: function(nodes) {
                    var me = this
                      , last = this._selectedNodes.slice(0);
                    return nodes = utils.isArray(nodes) ? nodes : [nodes],
                    nodes.forEach(function(node) {
                        var index;
                        -1 !== (index = me._selectedNodes.indexOf(node)) && me._selectedNodes.splice(index, 1)
                    }),
                    this.renderChangedSelection(last),
                    this
                },
                select: function(nodes, isSingleSelect) {
                    var lastSelect = this.getSelectedNodes().slice(0);
                    isSingleSelect && (this._selectedNodes = []);
                    var me = this;
                    return nodes = utils.isArray(nodes) ? nodes : [nodes],
                    nodes.forEach(function(node) {
                        -1 === me._selectedNodes.indexOf(node) && me._selectedNodes.unshift(node)
                    }),
                    this.renderChangedSelection(lastSelect),
                    this
                },
                selectById: function(ids, isSingleSelect) {
                    ids = utils.isArray(ids) ? ids : [ids];
                    var nodes = this.getNodesById(ids);
                    return this.select(nodes, isSingleSelect)
                },
                toggleSelect: function(node) {
                    return utils.isArray(node) ? node.forEach(this.toggleSelect.bind(this)) : node.isSelected() ? this.removeSelectedNodes(node) : this.select(node),
                    this
                },
                isSingleSelect: function() {
                    return 1 == this._selectedNodes.length
                },
                getSelectedAncestors: function(includeRoot) {
                    var judge, nodes = this.getSelectedNodes().slice(0), ancestors = [], rootIndex = nodes.indexOf(this.getRoot());
                    for (~rootIndex && !includeRoot && nodes.splice(rootIndex, 1),
                    nodes.sort(function(node1, node2) {
                        return node1.getLevel() - node2.getLevel()
                    }); judge = nodes.pop(); )
                        (function(nodes, judge) {
                            for (var i = nodes.length - 1; i >= 0; --i)
                                if (nodes[i].isAncestorOf(judge))
                                    return !0;
                            return !1
                        }
                        )(nodes, judge) || ancestors.push(judge);
                    return ancestors
                }
            }),
            kity.extendClass(MinderNode, {
                isSelected: function() {
                    var minder = this.getMinder();
                    return minder && -1 != minder.getSelectedNodes().indexOf(this)
                }
            })
        }
    },
    _p[29] = {
        value: function(require, exports, module) {
            function getMetaKeyCode(unknown) {
                var metaKeyCode = 0;
                return "string" == typeof unknown ? unknown.toLowerCase().split(/\+\s*/).forEach(function(name) {
                    switch (name) {
                    case "ctrl":
                    case "cmd":
                        metaKeyCode |= 4096;
                        break;
                    case "alt":
                        metaKeyCode |= 8192;
                        break;
                    case "shift":
                        metaKeyCode |= 16384;
                        break;
                    default:
                        metaKeyCode |= keymap[name]
                    }
                }) : ((unknown.ctrlKey || unknown.metaKey) && (metaKeyCode |= 4096),
                unknown.altKey && (metaKeyCode |= 8192),
                unknown.shiftKey && (metaKeyCode |= 16384),
                metaKeyCode |= unknown.keyCode),
                metaKeyCode
            }
            var kity = _p.r(17)
              , utils = _p.r(33)
              , keymap = _p.r(15)
              , Minder = _p.r(19)
              , MinderEvent = _p.r(13);
            kity.extendClass(MinderEvent, {
                isShortcutKey: function(keyCombine) {
                    var keyEvent = this.originEvent;
                    return !!keyEvent && getMetaKeyCode(keyCombine) == getMetaKeyCode(keyEvent)
                }
            }),
            Minder.registerInitHook(function() {
                this._initShortcutKey()
            }),
            kity.extendClass(Minder, {
                _initShortcutKey: function() {
                    this._bindShortcutKeys()
                },
                _bindShortcutKeys: function() {
                    var map = this._shortcutKeys = {};
                    this.on("keydown", function(e) {
                        for (var keys in map)
                            if (map.hasOwnProperty(keys) && e.isShortcutKey(keys)) {
                                var fn = map[keys];
                                if (fn.__statusCondition && fn.__statusCondition != this.getStatus())
                                    return;
                                fn(),
                                e.preventDefault()
                            }
                    })
                },
                addShortcut: function(keys, fn) {
                    var binds = this._shortcutKeys;
                    keys.split(/\|\s*/).forEach(function(combine) {
                        var status, parts = combine.split("::");
                        parts.length > 1 && (combine = parts[1],
                        status = parts[0],
                        fn.__statusCondition = status),
                        binds[combine] = fn
                    })
                },
                addCommandShortcutKeys: function(cmd, keys) {
                    var binds = this._commandShortcutKeys || (this._commandShortcutKeys = {})
                      , obj = {};
                    keys ? obj[cmd] = keys : obj = cmd;
                    var minder = this;
                    utils.each(obj, function(keys, command) {
                        binds[command] = keys,
                        minder.addShortcut(keys, function() {
                            -1 !== minder.queryCommandState(command) && minder.execCommand(command)
                        })
                    })
                },
                getCommandShortcutKey: function(cmd) {
                    var binds = this._commandShortcutKeys;
                    return binds && binds[cmd] || null
                },
                supportClipboardEvent: function(window) {
                    return !!window.ClipboardEvent
                }(window)
            })
        }
    },
    _p[30] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = _p.r(19)
              , sf = ~window.location.href.indexOf("status")
              , tf = ~window.location.href.indexOf("trace");
            Minder.registerInitHook(function() {
                this._initStatus()
            }),
            kity.extendClass(Minder, {
                _initStatus: function() {
                    this._status = "normal",
                    this._rollbackStatus = "normal"
                },
                setStatus: function(status, force) {
                    return "readonly" != this._status || force ? (status != this._status && (this._rollbackStatus = this._status,
                    this._status = status,
                    this.fire("statuschange", {
                        lastStatus: this._rollbackStatus,
                        currentStatus: this._status
                    }),
                    sf && (console.log(window.event.type, this._rollbackStatus, "->", this._status),
                    tf && console.trace())),
                    this) : this
                },
                rollbackStatus: function() {
                    this.setStatus(this._rollbackStatus)
                },
                getRollbackStatus: function() {
                    return this._rollbackStatus
                },
                getStatus: function() {
                    return this._status
                }
            })
        }
    },
    _p[31] = {
        value: function(require, exports, module) {
            function register(name, supports) {
                _templates[name] = supports
            }
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Minder = _p.r(19)
              , Command = _p.r(9)
              , MinderNode = _p.r(21)
              , Module = _p.r(20)
              , _templates = {};
            exports.register = register,
            utils.extend(Minder, {
                getTemplateList: function() {
                    return _templates
                }
            }),
            kity.extendClass(Minder, function() {
                var originGetTheme = Minder.prototype.getTheme;
                return {
                    useTemplate: function(name, duration) {
                        this.setTemplate(name),
                        this.refresh(duration || 800)
                    },
                    getTemplate: function() {
                        return this._template || "default"
                    },
                    setTemplate: function(name) {
                        this._template = name || null
                    },
                    getTemplateSupport: function(method) {
                        var supports = _templates[this.getTemplate()];
                        return supports && supports[method]
                    },
                    getTheme: function(node) {
                        return (this.getTemplateSupport("getTheme") || originGetTheme).call(this, node)
                    }
                }
            }()),
            kity.extendClass(MinderNode, function() {
                var originGetLayout = MinderNode.prototype.getLayout
                  , originGetConnect = MinderNode.prototype.getConnect;
                return {
                    getLayout: function() {
                        return (this.getMinder().getTemplateSupport("getLayout") || originGetLayout).call(this, this)
                    },
                    getConnect: function() {
                        return (this.getMinder().getTemplateSupport("getConnect") || originGetConnect).call(this, this)
                    }
                }
            }()),
            Module.register("TemplateModule", {
                commands: {
                    template: kity.createClass("TemplateCommand", {
                        base: Command,
                        execute: function(minder, name) {
                            minder.useTemplate(name),
                            minder.execCommand("camera")
                        },
                        queryValue: function(minder) {
                            return minder.getTemplate() || "default"
                        }
                    })
                }
            })
        }
    },
    _p[32] = {
        value: function(require, exports, module) {
            function register(name, theme) {
                _themes[name] = theme
            }
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Minder = _p.r(19)
              , MinderNode = _p.r(21)
              , Module = _p.r(20)
              , Command = _p.r(9)
              , cssLikeValueMatcher = {
                left: function(value) {
                    return 3 in value && value[3] || 1 in value && value[1] || value[0]
                },
                right: function(value) {
                    return 1 in value && value[1] || value[0]
                },
                top: function(value) {
                    return value[0]
                },
                bottom: function(value) {
                    return 2 in value && value[2] || value[0]
                }
            }
              , _themes = {};
            exports.register = register,
            utils.extend(Minder, {
                getThemeList: function() {
                    return _themes
                }
            }),
            kity.extendClass(Minder, {
                useTheme: function(name) {
                    return this.setTheme(name),
                    this.refresh(800),
                    !0
                },
                setTheme: function(name) {
                    if (name && !_themes[name])
                        throw new Error("Theme " + name + " not exists!");
                    var lastTheme = this._theme;
                    this._theme = name || null;
                    var container = this.getRenderTarget();
                    return container && (container.classList.remove("km-theme-" + lastTheme),
                    name && container.classList.add("km-theme-" + name),
                    container.style.background = this.getStyle("background")),
                    this.fire("themechange", {
                        theme: name
                    }),
                    this
                },
                getTheme: function(node) {
                    return this._theme || this.getOption("defaultTheme") || "fresh-blue"
                },
                getThemeItems: function(node) {
                    this.getTheme(node);
                    return _themes[this.getTheme(node)]
                },
                getStyle: function(item, node) {
                    var segment, dir, value, matcher, items = this.getThemeItems(node);
                    if (item in items)
                        return items[item];
                    if (segment = item.split("-"),
                    segment.length < 2)
                        return null;
                    if (dir = segment.pop(),
                    (item = segment.join("-"))in items) {
                        if (value = items[item],
                        utils.isArray(value) && (matcher = cssLikeValueMatcher[dir]))
                            return matcher(value);
                        if (!isNaN(value))
                            return value
                    }
                    return null
                },
                getNodeStyle: function(node, name) {
                    var value = this.getStyle(node.getType() + "-" + name, node);
                    return null !== value ? value : this.getStyle(name, node)
                }
            }),
            kity.extendClass(MinderNode, {
                getStyle: function(name) {
                    return this.getMinder().getNodeStyle(this, name)
                }
            }),
            Module.register("Theme", {
                defaultOptions: {
                    defaultTheme: "fresh-blue"
                },
                commands: {
                    theme: kity.createClass("ThemeCommand", {
                        base: Command,
                        execute: function(km, name) {
                            return km.useTheme(name)
                        },
                        queryValue: function(km) {
                            return km.getTheme() || "default"
                        }
                    })
                }
            }),
            Minder.registerInitHook(function() {
                this.setTheme()
            })
        }
    },
    _p[33] = {
        value: function(require, exports) {
            var kity = _p.r(17)
              , uuidMap = {};
            exports.extend = kity.Utils.extend.bind(kity.Utils),
            exports.each = kity.Utils.each.bind(kity.Utils),
            exports.uuid = function(group) {
                return uuidMap[group] = uuidMap[group] ? uuidMap[group] + 1 : 1,
                group + uuidMap[group]
            }
            ,
            exports.guid = function() {
                return (1e6 * +new Date + Math.floor(1e6 * Math.random())).toString(36)
            }
            ,
            exports.trim = function(str) {
                return str.replace(/(^[ \t\n\r]+)|([ \t\n\r]+$)/g, "")
            }
            ,
            exports.keys = function(plain) {
                var keys = [];
                for (var key in plain)
                    plain.hasOwnProperty(key) && keys.push(key);
                return keys
            }
            ,
            exports.clone = function(source) {
                return JSON.parse(JSON.stringify(source))
            }
            ,
            exports.comparePlainObject = function(a, b) {
                return JSON.stringify(a) == JSON.stringify(b)
            }
            ,
            exports.encodeHtml = function(str, reg) {
                return str ? str.replace(reg || /[&<">'](?:(amp|lt|quot|gt|#39|nbsp);)?/g, function(a, b) {
                    return b ? a : {
                        "<": "&lt;",
                        "&": "&amp;",
                        '"': "&quot;",
                        ">": "&gt;",
                        "'": "&#39;"
                    }[a]
                }) : ""
            }
            ,
            exports.clearWhiteSpace = function(str) {
                return str.replace(/[\u200b\t\r\n]/g, "")
            }
            ,
            exports.each(["String", "Function", "Array", "Number", "RegExp", "Object"], function(v) {
                var toString = Object.prototype.toString;
                exports["is" + v] = function(obj) {
                    return toString.apply(obj) == "[object " + v + "]"
                }
            })
        }
    },
    _p[34] = {
        value: function(require, exports, module) {
            module.exports = window.kityminder = _p.r(35)
        }
    },
    _p[35] = {
        value: function(require, exports, module) {
            var kityminder = {
                version: _p.r(19).version
            };
            _p.r(33),
            kityminder.Minder = _p.r(19),
            kityminder.Command = _p.r(9),
            kityminder.Node = _p.r(21),
            _p.r(22),
            _p.r(8),
            kityminder.Event = _p.r(13),
            kityminder.data = _p.r(12),
            _p.r(10),
            kityminder.KeyMap = _p.r(15),
            _p.r(29),
            _p.r(30),
            _p.r(23),
            _p.r(28),
            _p.r(14),
            _p.r(16),
            kityminder.Module = _p.r(20),
            _p.r(26),
            kityminder.Render = _p.r(27),
            kityminder.Connect = _p.r(11),
            kityminder.Layout = _p.r(18),
            kityminder.Theme = _p.r(32),
            kityminder.Template = _p.r(31),
            kityminder.Promise = _p.r(25),
            _p.r(7),
            _p.r(24),
            _p.r(42),
            _p.r(43),
            _p.r(44),
            _p.r(45),
            _p.r(46),
            _p.r(47),
            _p.r(48),
            _p.r(49),
            _p.r(50),
            _p.r(51),
            _p.r(52),
            _p.r(53),
            _p.r(54),
            _p.r(55),
            _p.r(56),
            _p.r(57),
            _p.r(58),
            _p.r(59),
            _p.r(60),
            _p.r(61),
            _p.r(62),
            _p.r(63),
            _p.r(67),
            _p.r(64),
            _p.r(66),
            _p.r(65),
            _p.r(40),
            _p.r(36),
            _p.r(37),
            _p.r(38),
            _p.r(39),
            _p.r(41),
            _p.r(74),
            _p.r(77),
            _p.r(76),
            _p.r(75),
            _p.r(77),
            _p.r(79),
            _p.r(78),
            _p.r(0),
            _p.r(1),
            _p.r(2),
            _p.r(3),
            _p.r(4),
            _p.r(5),
            _p.r(6),
            _p.r(68),
            _p.r(72),
            _p.r(69),
            _p.r(71),
            _p.r(70),
            _p.r(73),
            module.exports = kityminder
        }
    },
    _p[36] = {
        value: function(require, exports, module) {
            function registerLayoutForDirection(name) {
                function getOrderHint(node) {
                    var hint = []
                      , box = node.getLayoutBox();
                    return "x" == axis ? (hint.push({
                        type: "up",
                        node: node,
                        area: new kity.Box({
                            x: box.x,
                            y: box.top - node.getStyle("margin-top") - 5,
                            width: box.width,
                            height: node.getStyle("margin-top")
                        }),
                        path: ["M", box.x, box.top - 5, "L", box.right, box.top - 5]
                    }),
                    hint.push({
                        type: "down",
                        node: node,
                        area: new kity.Box({
                            x: box.x,
                            y: box.bottom + 5,
                            width: box.width,
                            height: node.getStyle("margin-bottom")
                        }),
                        path: ["M", box.x, box.bottom + 5, "L", box.right, box.bottom + 5]
                    })) : (hint.push({
                        type: "up",
                        node: node,
                        area: new kity.Box({
                            x: box.left - node.getStyle("margin-left") - 5,
                            y: box.top,
                            width: node.getStyle("margin-left"),
                            height: box.height
                        }),
                        path: ["M", box.left - 5, box.top, "L", box.left - 5, box.bottom]
                    }),
                    hint.push({
                        type: "down",
                        node: node,
                        area: new kity.Box({
                            x: box.right + 5,
                            y: box.top,
                            width: node.getStyle("margin-right"),
                            height: box.height
                        }),
                        path: ["M", box.right + 5, box.top, "L", box.right + 5, box.bottom]
                    })),
                    hint
                }
                var axis = "left" == name || "right" == name ? "x" : "y"
                  , dir = "left" == name || "top" == name ? -1 : 1
                  , oppsite = {
                    left: "right",
                    right: "left",
                    top: "bottom",
                    bottom: "top",
                    x: "y",
                    y: "x"
                };
                Layout.register(name, kity.createClass({
                    base: Layout,
                    doLayout: function(parent, children) {
                        var pbox = parent.getContentBox();
                        if ("x" == axis ? (parent.setVertexOut(new kity.Point(pbox[name],pbox.cy)),
                        parent.setLayoutVectorOut(new kity.Vector(dir,0))) : (parent.setVertexOut(new kity.Point(pbox.cx,pbox[name])),
                        parent.setLayoutVectorOut(new kity.Vector(0,dir))),
                        !children.length)
                            return !1;
                        children.forEach(function(child) {
                            var cbox = child.getContentBox();
                            child.setLayoutTransform(new kity.Matrix),
                            "x" == axis ? (child.setVertexIn(new kity.Point(cbox[oppsite[name]],cbox.cy)),
                            child.setLayoutVectorIn(new kity.Vector(dir,0))) : (child.setVertexIn(new kity.Point(cbox.cx,cbox[oppsite[name]])),
                            child.setLayoutVectorIn(new kity.Vector(0,dir)))
                        }),
                        this.align(children, oppsite[name]),
                        this.stack(children, oppsite[axis]);
                        var bbox = this.getBranchBox(children)
                          , xAdjust = 0
                          , yAdjust = 0;
                        "x" == axis ? (xAdjust = pbox[name],
                        xAdjust += dir * parent.getStyle("margin-" + name),
                        xAdjust += dir * children[0].getStyle("margin-" + oppsite[name]),
                        yAdjust = pbox.bottom,
                        yAdjust -= pbox.height / 2,
                        yAdjust -= bbox.height / 2,
                        yAdjust -= bbox.y) : (xAdjust = pbox.right,
                        xAdjust -= pbox.width / 2,
                        xAdjust -= bbox.width / 2,
                        xAdjust -= bbox.x,
                        yAdjust = pbox[name],
                        yAdjust += dir * parent.getStyle("margin-" + name),
                        yAdjust += dir * children[0].getStyle("margin-" + oppsite[name])),
                        this.move(children, xAdjust, yAdjust)
                    },
                    getOrderHint: getOrderHint
                }))
            }
            var kity = _p.r(17)
              , Layout = _p.r(18);
            ["left", "right", "top", "bottom"].forEach(registerLayoutForDirection)
        }
    },
    _p[37] = {
        value: function(require, exports, module) {
            function registerLayoutForDir(dir) {
                var name = "filetree-" + (dir > 0 ? "down" : "up");
                Layout.register(name, kity.createClass({
                    base: Layout,
                    doLayout: function(parent, children, round) {
                        var pBox = parent.getContentBox();
                        if (parent.setVertexOut(new kity.Point(pBox.left + 20,dir > 0 ? pBox.bottom : pBox.top)),
                        parent.setLayoutVectorOut(new kity.Vector(0,dir)),
                        children.length) {
                            children.forEach(function(child) {
                                var cbox = child.getContentBox();
                                child.setLayoutTransform(new kity.Matrix),
                                child.setVertexIn(new kity.Point(cbox.left,cbox.cy)),
                                child.setLayoutVectorIn(new kity.Vector(1,0))
                            }),
                            this.align(children, "left"),
                            this.stack(children, "y");
                            var xAdjust = 0;
                            xAdjust += pBox.left,
                            xAdjust += 20,
                            xAdjust += children[0].getStyle("margin-left");
                            var yAdjust = 0;
                            dir > 0 ? (yAdjust += pBox.bottom,
                            yAdjust += parent.getStyle("margin-bottom"),
                            yAdjust += children[0].getStyle("margin-top")) : (yAdjust -= this.getTreeBox(children).bottom,
                            yAdjust += pBox.top,
                            yAdjust -= parent.getStyle("margin-top"),
                            yAdjust -= children[0].getStyle("margin-bottom")),
                            this.move(children, xAdjust, yAdjust)
                        }
                    },
                    getOrderHint: function(node) {
                        var hint = []
                          , box = node.getLayoutBox()
                          , offset = node.getLevel() > 1 ? 3 : 5;
                        return hint.push({
                            type: "up",
                            node: node,
                            area: new kity.Box({
                                x: box.x,
                                y: box.top - node.getStyle("margin-top") - offset,
                                width: box.width,
                                height: node.getStyle("margin-top")
                            }),
                            path: ["M", box.x, box.top - offset, "L", box.right, box.top - offset]
                        }),
                        hint.push({
                            type: "down",
                            node: node,
                            area: new kity.Box({
                                x: box.x,
                                y: box.bottom + offset,
                                width: box.width,
                                height: node.getStyle("margin-bottom")
                            }),
                            path: ["M", box.x, box.bottom + offset, "L", box.right, box.bottom + offset]
                        }),
                        hint
                    }
                }))
            }
            var kity = _p.r(17)
              , Layout = _p.r(18);
            [-1, 1].forEach(registerLayoutForDir)
        }
    },
    _p[38] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Layout = _p.r(18);
            Layout.register("fish-bone-master", kity.createClass("FishBoneMasterLayout", {
                base: Layout,
                doLayout: function(parent, children, round) {
                    var upPart = []
                      , downPart = []
                      , child = children[0]
                      , pBox = parent.getContentBox();
                    if (parent.setVertexOut(new kity.Point(pBox.right,pBox.cy)),
                    parent.setLayoutVectorOut(new kity.Vector(1,0)),
                    child) {
                        var pMarginRight = (child.getContentBox(),
                        parent.getStyle("margin-right"))
                          , cMarginLeft = child.getStyle("margin-left")
                          , cMarginTop = child.getStyle("margin-top")
                          , cMarginBottom = child.getStyle("margin-bottom");
                        children.forEach(function(child, index) {
                            child.setLayoutTransform(new kity.Matrix);
                            var cBox = child.getContentBox();
                            index % 2 ? (downPart.push(child),
                            child.setVertexIn(new kity.Point(cBox.left,cBox.top)),
                            child.setLayoutVectorIn(new kity.Vector(1,1))) : (upPart.push(child),
                            child.setVertexIn(new kity.Point(cBox.left,cBox.bottom)),
                            child.setLayoutVectorIn(new kity.Vector(1,-1)))
                        }),
                        this.stack(upPart, "x"),
                        this.stack(downPart, "x"),
                        this.align(upPart, "bottom"),
                        this.align(downPart, "top");
                        var xAdjust = pBox.right + pMarginRight + cMarginLeft
                          , yAdjustUp = pBox.cy - cMarginBottom - parent.getStyle("margin-top")
                          , yAdjustDown = pBox.cy + cMarginTop + parent.getStyle("margin-bottom");
                        this.move(upPart, xAdjust, yAdjustUp),
                        this.move(downPart, xAdjust + cMarginLeft, yAdjustDown)
                    }
                }
            }))
        }
    },
    _p[39] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Layout = _p.r(18);
            Layout.register("fish-bone-slave", kity.createClass("FishBoneSlaveLayout", {
                base: Layout,
                doLayout: function(parent, children, round) {
                    var layout = this
                      , abs = Math.abs
                      , pBox = parent.getContentBox()
                      , vi = parent.getLayoutVectorIn();
                    parent.setLayoutVectorOut(vi);
                    var goldX = pBox.left + .382 * pBox.width
                      , pout = new kity.Point(goldX,vi.y > 0 ? pBox.bottom : pBox.top);
                    parent.setVertexOut(pout);
                    var child = children[0];
                    if (child) {
                        var cBox = child.getContentBox();
                        children.forEach(function(child, index) {
                            child.setLayoutTransform(new kity.Matrix),
                            child.setLayoutVectorIn(new kity.Vector(1,0)),
                            child.setVertexIn(new kity.Point(cBox.left,cBox.cy))
                        }),
                        this.stack(children, "y"),
                        this.align(children, "left");
                        var xAdjust = 0
                          , yAdjust = 0;
                        xAdjust += pout.x,
                        parent.getLayoutVectorOut().y < 0 ? (yAdjust -= this.getTreeBox(children).bottom,
                        yAdjust += parent.getContentBox().top,
                        yAdjust -= parent.getStyle("margin-top"),
                        yAdjust -= child.getStyle("margin-bottom")) : (yAdjust += parent.getContentBox().bottom,
                        yAdjust += parent.getStyle("margin-bottom"),
                        yAdjust += child.getStyle("margin-top")),
                        this.move(children, xAdjust, yAdjust),
                        2 == round && children.forEach(function(child) {
                            var m = child.getLayoutTransform()
                              , cbox = child.getContentBox()
                              , pin = m.transformPoint(new kity.Point(cbox.left,0));
                            layout.move([child], abs(pin.y - pout.y), 0)
                        })
                    }
                }
            }))
        }
    },
    _p[40] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Layout = _p.r(18)
              , Minder = _p.r(19);
            Layout.register("mind", kity.createClass({
                base: Layout,
                doLayout: function(node, children) {
                    var half = Math.ceil(node.children.length / 2)
                      , right = []
                      , left = [];
                    children.forEach(function(child) {
                        child.getIndex() < half ? right.push(child) : left.push(child)
                    });
                    var leftLayout = Minder.getLayoutInstance("left")
                      , rightLayout = Minder.getLayoutInstance("right");
                    leftLayout.doLayout(node, left),
                    rightLayout.doLayout(node, right);
                    var box = node.getContentBox();
                    node.setVertexOut(new kity.Point(box.cx,box.cy)),
                    node.setLayoutVectorOut(new kity.Vector(0,0))
                },
                getOrderHint: function(node) {
                    var hint = []
                      , box = node.getLayoutBox();
                    return hint.push({
                        type: "up",
                        node: node,
                        area: new kity.Box({
                            x: box.x,
                            y: box.top - node.getStyle("margin-top") - 5,
                            width: box.width,
                            height: node.getStyle("margin-top")
                        }),
                        path: ["M", box.x, box.top - 5, "L", box.right, box.top - 5]
                    }),
                    hint.push({
                        type: "down",
                        node: node,
                        area: new kity.Box({
                            x: box.x,
                            y: box.bottom + 5,
                            width: box.width,
                            height: node.getStyle("margin-bottom")
                        }),
                        path: ["M", box.x, box.bottom + 5, "L", box.right, box.bottom + 5]
                    }),
                    hint
                }
            }))
        }
    },
    _p[41] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Layout = _p.r(18);
            _p.r(19);
            Layout.register("tianpan", kity.createClass({
                base: Layout,
                doLayout: function(parent, children) {
                    if (0 != children.length) {
                        var x, y, box, layout = this, pbox = parent.getContentBox(), _theta = 5, _r = Math.max(pbox.width, 50);
                        children.forEach(function(child, index) {
                            child.setLayoutTransform(new kity.Matrix),
                            box = layout.getTreeBox(child),
                            _r = Math.max(Math.max(box.width, box.height), _r)
                        }),
                        _r = _r / 1.5 / Math.PI,
                        children.forEach(function(child, index) {
                            x = _r * (Math.cos(_theta) + Math.sin(_theta) * _theta),
                            y = _r * (Math.sin(_theta) - Math.cos(_theta) * _theta),
                            _theta += .9 - .02 * index,
                            child.setLayoutVectorIn(new kity.Vector(1,0)),
                            child.setVertexIn(new kity.Point(pbox.cx,pbox.cy)),
                            child.setLayoutTransform(new kity.Matrix),
                            layout.move([child], x, y)
                        })
                    }
                },
                getOrderHint: function(node) {
                    var hint = []
                      , box = node.getLayoutBox();
                    return hint.push({
                        type: "up",
                        node: node,
                        area: {
                            x: box.x,
                            y: box.top - node.getStyle("margin-top") - 5,
                            width: box.width,
                            height: node.getStyle("margin-top")
                        },
                        path: ["M", box.x, box.top - 5, "L", box.right, box.top - 5]
                    }),
                    hint.push({
                        type: "down",
                        node: node,
                        area: {
                            x: box.x,
                            y: box.bottom + 5,
                            width: box.width,
                            height: node.getStyle("margin-bottom")
                        },
                        path: ["M", box.x, box.bottom + 5, "L", box.right, box.bottom + 5]
                    }),
                    hint
                }
            }))
        }
    },
    _p[42] = {
        value: function(require, exports, module) {
            function asc(nodeA, nodeB) {
                return nodeA.getIndex() - nodeB.getIndex()
            }
            function desc(nodeA, nodeB) {
                return -asc(nodeA, nodeB)
            }
            var kity = _p.r(17)
              , MinderNode = _p.r(21)
              , Command = _p.r(9)
              , Module = _p.r(20);
            kity.extendClass(MinderNode, {
                arrange: function(index) {
                    var parent = this.parent;
                    if (parent) {
                        var sibling = parent.children;
                        if (!(index < 0 || index >= sibling.length))
                            return sibling.splice(this.getIndex(), 1),
                            sibling.splice(index, 0, this),
                            this
                    }
                }
            });
            var ArrangeUpCommand = kity.createClass("ArrangeUpCommand", {
                base: Command,
                execute: function(km) {
                    var nodes = km.getSelectedNodes();
                    nodes.sort(asc);
                    var lastIndexes = nodes.map(function(node) {
                        return node.getIndex()
                    });
                    nodes.forEach(function(node, index) {
                        node.arrange(lastIndexes[index] - 1)
                    }),
                    km.layout(300)
                },
                queryState: function(km) {
                    return km.getSelectedNode() ? 0 : -1
                }
            })
              , ArrangeDownCommand = kity.createClass("ArrangeUpCommand", {
                base: Command,
                execute: function(km) {
                    var nodes = km.getSelectedNodes();
                    nodes.sort(desc);
                    var lastIndexes = nodes.map(function(node) {
                        return node.getIndex()
                    });
                    nodes.forEach(function(node, index) {
                        node.arrange(lastIndexes[index] + 1)
                    }),
                    km.layout(300)
                },
                queryState: function(km) {
                    return km.getSelectedNode() ? 0 : -1
                }
            })
              , ArrangeCommand = kity.createClass("ArrangeCommand", {
                base: Command,
                execute: function(km, index) {
                    var nodes = km.getSelectedNodes().slice();
                    if (nodes.length) {
                        if (MinderNode.getCommonAncestor(nodes) == nodes[0].parent) {
                            var indexed = nodes.map(function(node) {
                                return {
                                    index: node.getIndex(),
                                    node: node
                                }
                            })
                              , asc = Math.min.apply(Math, indexed.map(function(one) {
                                return one.index
                            })) >= index;
                            indexed.sort(function(a, b) {
                                return asc ? b.index - a.index : a.index - b.index
                            }),
                            indexed.forEach(function(one) {
                                one.node.arrange(index)
                            }),
                            km.layout(300)
                        }
                    }
                },
                queryState: function(km) {
                    return km.getSelectedNode() ? 0 : -1
                }
            });
            Module.register("ArrangeModule", {
                commands: {
                    arrangeup: ArrangeUpCommand,
                    arrangedown: ArrangeDownCommand,
                    arrange: ArrangeCommand
                },
                contextmenu: [{
                    command: "arrangeup"
                }, {
                    command: "arrangedown"
                }, {
                    divider: !0
                }],
                commandShortcutKeys: {
                    arrangeup: "normal::alt+Up",
                    arrangedown: "normal::alt+Down"
                }
            })
        }
    },
    _p[43] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Command = (_p.r(33),
            _p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20)
              , TextRenderer = _p.r(60);
            Module.register("basestylemodule", function() {
                function getNodeDataOrStyle(node, name) {
                    return node.getData(name) || node.getStyle(name)
                }
                var km = this;
                return TextRenderer.registerStyleHook(function(node, textGroup) {
                    var fontWeight = getNodeDataOrStyle(node, "font-weight")
                      , fontStyle = getNodeDataOrStyle(node, "font-style");
                    [fontWeight, fontStyle].join("/");
                    textGroup.eachItem(function(index, item) {
                        item.setFont({
                            weight: fontWeight,
                            style: fontStyle
                        })
                    })
                }),
                {
                    commands: {
                        bold: kity.createClass("boldCommand", {
                            base: Command,
                            execute: function(km) {
                                var nodes = km.getSelectedNodes();
                                1 == this.queryState("bold") ? nodes.forEach(function(n) {
                                    n.setData("font-weight").render()
                                }) : nodes.forEach(function(n) {
                                    n.setData("font-weight", "bold").render()
                                }),
                                km.layout()
                            },
                            queryState: function() {
                                var nodes = km.getSelectedNodes()
                                  , result = 0;
                                return 0 === nodes.length ? -1 : (nodes.forEach(function(n) {
                                    if (n && n.getData("font-weight"))
                                        return result = 1,
                                        !1
                                }),
                                result)
                            }
                        }),
                        italic: kity.createClass("italicCommand", {
                            base: Command,
                            execute: function(km) {
                                var nodes = km.getSelectedNodes();
                                1 == this.queryState("italic") ? nodes.forEach(function(n) {
                                    n.setData("font-style").render()
                                }) : nodes.forEach(function(n) {
                                    n.setData("font-style", "italic").render()
                                }),
                                km.layout()
                            },
                            queryState: function() {
                                var nodes = km.getSelectedNodes()
                                  , result = 0;
                                return 0 === nodes.length ? -1 : (nodes.forEach(function(n) {
                                    if (n && n.getData("font-style"))
                                        return result = 1,
                                        !1
                                }),
                                result)
                            }
                        })
                    },
                    commandShortcutKeys: {
                        bold: "ctrl+b",
                        italic: "ctrl+i"
                    }
                }
            })
        }
    },
    _p[44] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , MinderNode = (_p.r(33),
            _p.r(21))
              , Command = _p.r(9);
            _p.r(20).register("ClipboardModule", function() {
                function appendChildNode(parent, child) {
                    _selectedNodes.push(child),
                    km.appendNode(child, parent),
                    child.render(),
                    child.setLayoutOffset(null);
                    var children = child.children.map(function(node) {
                        return node.clone()
                    });
                    child.clearChildren();
                    for (var ci, i = 0; ci = children[i]; i++)
                        appendChildNode(child, ci)
                }
                function sendToClipboard(nodes) {
                    nodes.length && (nodes.sort(function(a, b) {
                        return a.getIndex() - b.getIndex()
                    }),
                    _clipboardNodes = nodes.map(function(node) {
                        return node.clone()
                    }))
                }
                var km = this
                  , _clipboardNodes = []
                  , _selectedNodes = []
                  , CopyCommand = kity.createClass("CopyCommand", {
                    base: Command,
                    execute: function(km) {
                        sendToClipboard(km.getSelectedAncestors(!0)),
                        this.setContentChanged(!1)
                    }
                })
                  , CutCommand = kity.createClass("CutCommand", {
                    base: Command,
                    execute: function(km) {
                        var ancestors = km.getSelectedAncestors();
                        0 !== ancestors.length && (sendToClipboard(ancestors),
                        km.select(MinderNode.getCommonAncestor(ancestors), !0),
                        ancestors.slice().forEach(function(node) {
                            km.removeNode(node)
                        }),
                        km.layout(300))
                    }
                })
                  , PasteCommand = kity.createClass("PasteCommand", {
                    base: Command,
                    execute: function(km) {
                        if (_clipboardNodes.length) {
                            var nodes = km.getSelectedNodes();
                            if (!nodes.length)
                                return;
                            for (var ni, i = 0; ni = _clipboardNodes[i]; i++)
                                for (var node, j = 0; node = nodes[j]; j++)
                                    appendChildNode(node, ni.clone());
                            km.select(_selectedNodes, !0),
                            _selectedNodes = [],
                            km.layout(300)
                        }
                    },
                    queryState: function(km) {
                        return km.getSelectedNode() ? 0 : -1
                    }
                });
                if (km.supportClipboardEvent && !kity.Browser.gecko) {
                    var Copy = function(e) {
                        this.fire("beforeCopy", e)
                    }
                      , Cut = function(e) {
                        this.fire("beforeCut", e)
                    }
                      , Paste = function(e) {
                        this.fire("beforePaste", e)
                    };
                    return {
                        commands: {
                            copy: CopyCommand,
                            cut: CutCommand,
                            paste: PasteCommand
                        },
                        clipBoardEvents: {
                            copy: Copy.bind(km),
                            cut: Cut.bind(km),
                            paste: Paste.bind(km)
                        },
                        sendToClipboard: sendToClipboard
                    }
                }
                return {
                    commands: {
                        copy: CopyCommand,
                        cut: CutCommand,
                        paste: PasteCommand
                    },
                    commandShortcutKeys: {
                        copy: "normal::ctrl+c|",
                        cut: "normal::ctrl+x",
                        paste: "normal::ctrl+v"
                    },
                    sendToClipboard: sendToClipboard
                }
            })
        }
    },
    _p[45] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , MinderNode = (_p.r(33),
            _p.r(21))
              , Command = _p.r(9)
              , Module = _p.r(20)
              , MoveToParentCommand = kity.createClass("MoveToParentCommand", {
                base: Command,
                execute: function(minder, nodes, parent) {
                    for (var node, i = 0; i < nodes.length; i++)
                        node = nodes[i],
                        node.parent && (node.parent.removeChild(node),
                        parent.appendChild(node),
                        node.render());
                    parent.expand(),
                    minder.select(nodes, !0)
                }
            })
              , DropHinter = kity.createClass("DropHinter", {
                base: kity.Group,
                constructor: function() {
                    this.callBase(),
                    this.rect = new kity.Rect,
                    this.addShape(this.rect)
                },
                render: function(target) {
                    this.setVisible(!!target),
                    target && (this.rect.setBox(target.getLayoutBox()).setRadius(target.getStyle("radius") || 0).stroke(target.getStyle("drop-hint-color") || "yellow", target.getStyle("drop-hint-width") || 2),
                    this.bringTop())
                }
            })
              , OrderHinter = kity.createClass("OrderHinter", {
                base: kity.Group,
                constructor: function() {
                    this.callBase(),
                    this.area = new kity.Rect,
                    this.path = new kity.Path,
                    this.addShapes([this.area, this.path])
                },
                render: function(hint) {
                    this.setVisible(!!hint),
                    hint && (this.area.setBox(hint.area),
                    this.area.fill(hint.node.getStyle("order-hint-area-color") || "rgba(0, 255, 0, .5)"),
                    this.path.setPathData(hint.path),
                    this.path.stroke(hint.node.getStyle("order-hint-path-color") || "#0f0", hint.node.getStyle("order-hint-path-width") || 1))
                }
            })
              , TreeDragger = kity.createClass("TreeDragger", {
                constructor: function(minder) {
                    this._minder = minder,
                    this._dropHinter = new DropHinter,
                    this._orderHinter = new OrderHinter,
                    minder.getRenderContainer().addShapes([this._dropHinter, this._orderHinter])
                },
                dragStart: function(position) {
                    this._startPosition = position
                },
                dragMove: function(position) {
                    if (this._startPosition) {
                        var movement = kity.Vector.fromPoints(this._dragPosition || this._startPosition, position)
                          , minder = this._minder;
                        if (this._dragPosition = position,
                        !this._dragMode) {
                            if (kity.Vector.fromPoints(this._dragPosition, this._startPosition).length() < 10)
                                return;
                            if (!this._enterDragMode())
                                return
                        }
                        for (var i = 0; i < this._dragSources.length; i++)
                            this._dragSources[i].setLayoutOffset(this._dragSources[i].getLayoutOffset().offset(movement)),
                            minder.applyLayoutResult(this._dragSources[i]);
                        this._dropTest() ? this._renderOrderHint(this._orderSucceedHint = null) : this._orderTest()
                    }
                },
                dragEnd: function() {
                    if (this._startPosition = null,
                    this._dragPosition = null,
                    this._dragMode) {
                        if (this._fadeDragSources(1),
                        this._dropSucceedTarget)
                            this._dragSources.forEach(function(source) {
                                source.setLayoutOffset(null)
                            }),
                            this._minder.layout(-1),
                            this._minder.execCommand("movetoparent", this._dragSources, this._dropSucceedTarget);
                        else if (this._orderSucceedHint) {
                            var hint = this._orderSucceedHint
                              , index = hint.node.getIndex()
                              , sourceIndexes = this._dragSources.map(function(source) {
                                return source.setLayoutOffset(null),
                                source.getIndex()
                            })
                              , maxIndex = Math.max.apply(Math, sourceIndexes)
                              , minIndex = Math.min.apply(Math, sourceIndexes);
                            index < minIndex && "down" == hint.type && index++,
                            index > maxIndex && "up" == hint.type && index--,
                            hint.node.setLayoutOffset(null),
                            this._minder.execCommand("arrange", index),
                            this._renderOrderHint(null)
                        } else
                            this._minder.fire("savescene");
                        this._minder.layout(300),
                        this._leaveDragMode(),
                        this._minder.fire("contentchange")
                    }
                },
                _enterDragMode: function() {
                    return this._calcDragSources(),
                    this._dragSources.length ? (this._fadeDragSources(.5),
                    this._calcDropTargets(),
                    this._calcOrderHints(),
                    this._dragMode = !0,
                    this._minder.setStatus("dragtree"),
                    !0) : (this._startPosition = null,
                    !1)
                },
                _calcDragSources: function() {
                    this._dragSources = this._minder.getSelectedAncestors()
                },
                _fadeDragSources: function(opacity) {
                    var minder = this._minder;
                    this._dragSources.forEach(function(source) {
                        source.getRenderContainer().setOpacity(opacity, 200),
                        source.traverse(function(node) {
                            opacity < 1 ? minder.detachNode(node) : minder.attachNode(node)
                        }, !0)
                    })
                },
                _calcDropTargets: function() {
                    function findAvailableParents(nodes, root) {
                        var i, availables = [];
                        return availables.push(root),
                        root.getChildren().forEach(function(test) {
                            for (i = 0; i < nodes.length; i++)
                                if (nodes[i] == test)
                                    return;
                            availables = availables.concat(findAvailableParents(nodes, test))
                        }),
                        availables
                    }
                    this._dropTargets = findAvailableParents(this._dragSources, this._minder.getRoot()),
                    this._dropTargetBoxes = this._dropTargets.map(function(source) {
                        return source.getLayoutBox()
                    })
                },
                _calcOrderHints: function() {
                    var sources = this._dragSources
                      , ancestor = MinderNode.getCommonAncestor(sources);
                    if (ancestor == sources[0] && (ancestor = sources[0].parent),
                    0 === sources.length || ancestor != sources[0].parent)
                        return void (this._orderHints = []);
                    var siblings = ancestor.children;
                    this._orderHints = siblings.reduce(function(hint, sibling) {
                        return -1 == sources.indexOf(sibling) && (hint = hint.concat(sibling.getOrderHint())),
                        hint
                    }, [])
                },
                _leaveDragMode: function() {
                    this._dragMode = !1,
                    this._dropSucceedTarget = null,
                    this._orderSucceedHint = null,
                    this._renderDropHint(null),
                    this._renderOrderHint(null),
                    this._minder.rollbackStatus()
                },
                _drawForDragMode: function() {
                    this._text.setContent(this._dragSources.length + " items"),
                    this._text.setPosition(this._startPosition.x, this._startPosition.y + 5),
                    this._minder.getRenderContainer().addShape(this)
                },
                _boxTest: function(targets, targetBoxMapper, judge) {
                    var i, j, target, sourceBox, targetBox, sourceBoxes = this._dragSources.map(function(source) {
                        return source.getLayoutBox()
                    });
                    for (judge = judge || function(intersectBox, sourceBox, targetBox) {
                        return intersectBox && !intersectBox.isEmpty()
                    }
                    ,
                    i = 0; i < targets.length; i++)
                        for (target = targets[i],
                        targetBox = targetBoxMapper.call(this, target, i),
                        j = 0; j < sourceBoxes.length; j++) {
                            sourceBox = sourceBoxes[j];
                            var intersectBox = sourceBox.intersect(targetBox);
                            if (judge(intersectBox, sourceBox, targetBox))
                                return target
                        }
                    return null
                },
                _dropTest: function() {
                    return this._dropSucceedTarget = this._boxTest(this._dropTargets, function(target, i) {
                        return this._dropTargetBoxes[i]
                    }, function(intersectBox, sourceBox, targetBox) {
                        function area(box) {
                            return box.width * box.height
                        }
                        return !!intersectBox && (!!area(intersectBox) && (area(intersectBox) > .5 * Math.min(area(sourceBox), area(targetBox)) || (intersectBox.width + 1 >= Math.min(sourceBox.width, targetBox.width) || intersectBox.height + 1 >= Math.min(sourceBox.height, targetBox.height))))
                    }),
                    this._renderDropHint(this._dropSucceedTarget),
                    !!this._dropSucceedTarget
                },
                _orderTest: function() {
                    return this._orderSucceedHint = this._boxTest(this._orderHints, function(hint) {
                        return hint.area
                    }),
                    this._renderOrderHint(this._orderSucceedHint),
                    !!this._orderSucceedHint
                },
                _renderDropHint: function(target) {
                    this._dropHinter.render(target)
                },
                _renderOrderHint: function(hint) {
                    this._orderHinter.render(hint)
                },
                preventDragMove: function() {
                    this._startPosition = null
                }
            });
            Module.register("DragTree", function() {
                var dragger;
                return {
                    init: function() {
                        dragger = new TreeDragger(this),
                        window.addEventListener("mouseup", function() {
                            dragger.dragEnd()
                        })
                    },
                    events: {
                        "normal.mousedown inputready.mousedown": function(e) {
                            e.originEvent.button || e.getTargetNode() && e.getTargetNode() != this.getRoot() && dragger.dragStart(e.getPosition())
                        },
                        "normal.mousemove dragtree.mousemove": function(e) {
                            dragger.dragMove(e.getPosition())
                        },
                        "normal.mouseup dragtree.beforemouseup": function(e) {
                            dragger.dragEnd(),
                            e.preventDefault()
                        },
                        statuschange: function(e) {
                            "textedit" == e.lastStatus && "normal" == e.currentStatus && dragger.preventDragMove()
                        }
                    },
                    commands: {
                        movetoparent: MoveToParentCommand
                    }
                }
            })
        }
    },
    _p[46] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , keymap = _p.r(15)
              , MinderNode = _p.r(21)
              , Command = _p.r(9)
              , Module = _p.r(20)
              , Renderer = _p.r(27);
            Module.register("Expand", function() {
                var minder = this;
                kity.extendClass(MinderNode, {
                    expand: function() {
                        return this.setData("expandState", "expand"),
                        this
                    },
                    collapse: function() {
                        return this.setData("expandState", "collapse"),
                        this
                    },
                    isExpanded: function() {
                        return "collapse" !== this.getData("expandState") && (this.isRoot() || this.parent.isExpanded())
                    },
                    isCollapsed: function() {
                        return !this.isExpanded()
                    }
                });
                var ExpandCommand = kity.createClass("ExpandCommand", {
                    base: Command,
                    execute: function(km, justParents) {
                        var node = km.getSelectedNode();
                        if (node) {
                            for (justParents && (node = node.parent); node.parent; )
                                node.expand(),
                                node = node.parent;
                            node.renderTree(),
                            km.layout(100)
                        }
                    },
                    queryState: function(km) {
                        var node = km.getSelectedNode();
                        return !node || node.isRoot() || node.isExpanded() ? -1 : 0
                    }
                })
                  , ExpandToLevelCommand = kity.createClass("ExpandToLevelCommand", {
                    base: Command,
                    execute: function(km, level) {
                        km.getRoot().traverse(function(node) {
                            node.getLevel() < level && node.expand(),
                            node.getLevel() != level || node.isLeaf() || node.collapse()
                        }),
                        km.refresh(100)
                    },
                    enableReadOnly: !0
                })
                  , CollapseCommand = kity.createClass("CollapseCommand", {
                    base: Command,
                    execute: function(km) {
                        var node = km.getSelectedNode();
                        node && (node.collapse(),
                        node.renderTree(),
                        km.layout())
                    },
                    queryState: function(km) {
                        var node = km.getSelectedNode();
                        return node && !node.isRoot() && node.isExpanded() ? 0 : -1
                    }
                })
                  , Expander = kity.createClass("Expander", {
                    base: kity.Group,
                    constructor: function(node) {
                        this.callBase(),
                        this.radius = 6,
                        this.outline = new kity.Circle(this.radius).stroke("gray").fill("white"),
                        this.sign = (new kity.Path).stroke("gray"),
                        this.addShapes([this.outline, this.sign]),
                        this.initEvent(node),
                        this.setId(utils.uuid("node_expander")),
                        this.setStyle("cursor", "pointer")
                    },
                    initEvent: function(node) {
                        this.on("mousedown", function(e) {
                            minder.select([node], !0),
                            node.isExpanded() ? node.collapse() : node.expand(),
                            node.renderTree().getMinder().layout(100),
                            node.getMinder().fire("contentchange"),
                            e.stopPropagation(),
                            e.preventDefault()
                        }),
                        this.on("dblclick click mouseup", function(e) {
                            e.stopPropagation(),
                            e.preventDefault()
                        })
                    },
                    setState: function(state) {
                        if ("hide" == state)
                            return void this.setVisible(!1);
                        this.setVisible(!0);
                        var pathData = ["M", 1.5 - this.radius, 0, "L", this.radius - 1.5, 0];
                        "collapse" == state && pathData.push(["M", 0, 1.5 - this.radius, "L", 0, this.radius - 1.5]),
                        this.sign.setPathData(pathData)
                    }
                })
                  , ExpanderRenderer = kity.createClass("ExpanderRenderer", {
                    base: Renderer,
                    create: function(node) {
                        if (!node.isRoot())
                            return this.expander = new Expander(node),
                            node.getRenderContainer().prependShape(this.expander),
                            node.expanderRenderer = this,
                            this.node = node,
                            this.expander
                    },
                    shouldRender: function(node) {
                        return !node.isRoot()
                    },
                    update: function(expander, node, box) {
                        if (node.parent) {
                            var visible = node.parent.isExpanded();
                            expander.setState(visible && node.children.length ? node.getData("expandState") : "hide");
                            var vector = node.getLayoutVectorIn().normalize(expander.radius + node.getStyle("stroke-width"))
                              , position = node.getVertexIn().offset(vector.reverse());
                            this.expander.setTranslate(position)
                        }
                    }
                });
                return {
                    commands: {
                        expand: ExpandCommand,
                        expandtolevel: ExpandToLevelCommand,
                        collapse: CollapseCommand
                    },
                    events: {
                        layoutapply: function(e) {
                            var r = e.node.getRenderer("ExpanderRenderer");
                            r.getRenderShape() && r.update(r.getRenderShape(), e.node)
                        },
                        beforerender: function(e) {
                            var node = e.node
                              , visible = !node.parent || node.parent.isExpanded();
                            node.getRenderContainer().setVisible(visible),
                            visible || e.stopPropagation()
                        },
                        "normal.keydown": function(e) {
                            if ("textedit" != this.getStatus()) {
                                if (e.originEvent.keyCode == keymap["/"]) {
                                    var node = this.getSelectedNode();
                                    if (!node || node == this.getRoot())
                                        return;
                                    var expanded = node.isExpanded();
                                    this.getSelectedNodes().forEach(function(node) {
                                        expanded ? node.collapse() : node.expand(),
                                        node.renderTree()
                                    }),
                                    this.layout(100),
                                    this.fire("contentchange"),
                                    e.preventDefault(),
                                    e.stopPropagationImmediately()
                                }
                                e.isShortcutKey("Alt+`") && this.execCommand("expandtolevel", 9999);
                                for (var i = 1; i < 6; i++)
                                    e.isShortcutKey("Alt+" + i) && this.execCommand("expandtolevel", i)
                            }
                        }
                    },
                    renderers: {
                        outside: ExpanderRenderer
                    },
                    contextmenu: [{
                        command: "expandtoleaf",
                        query: function() {
                            return !minder.getSelectedNode()
                        },
                        fn: function(minder) {
                            minder.execCommand("expandtolevel", 9999)
                        }
                    }, {
                        command: "expandtolevel1",
                        query: function() {
                            return !minder.getSelectedNode()
                        },
                        fn: function(minder) {
                            minder.execCommand("expandtolevel", 1)
                        }
                    }, {
                        command: "expandtolevel2",
                        query: function() {
                            return !minder.getSelectedNode()
                        },
                        fn: function(minder) {
                            minder.execCommand("expandtolevel", 2)
                        }
                    }, {
                        command: "expandtolevel3",
                        query: function() {
                            return !minder.getSelectedNode()
                        },
                        fn: function(minder) {
                            minder.execCommand("expandtolevel", 3)
                        }
                    }, {
                        divider: !0
                    }]
                }
            })
        }
    },
    _p[47] = {
        value: function(require, exports, module) {
            function getNodeDataOrStyle(node, name) {
                return node.getData(name) || node.getStyle(name)
            }
            var kity = _p.r(17)
              , Command = (_p.r(33),
            _p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20);
            _p.r(60).registerStyleHook(function(node, textGroup) {
                var dataColor = node.getData("color")
                  , selectedColor = node.getStyle("selected-color")
                  , styleColor = node.getStyle("color")
                  , foreColor = dataColor || (node.isSelected() && selectedColor ? selectedColor : styleColor)
                  , fontFamily = getNodeDataOrStyle(node, "font-family")
                  , fontSize = getNodeDataOrStyle(node, "font-size");
                textGroup.fill(foreColor),
                textGroup.eachItem(function(index, item) {
                    item.setFont({
                        family: fontFamily,
                        size: fontSize
                    })
                })
            }),
            Module.register("fontmodule", {
                commands: {
                    forecolor: kity.createClass("fontcolorCommand", {
                        base: Command,
                        execute: function(km, color) {
                            km.getSelectedNodes().forEach(function(n) {
                                n.setData("color", color),
                                n.render()
                            })
                        },
                        queryState: function(km) {
                            return 0 === km.getSelectedNodes().length ? -1 : 0
                        },
                        queryValue: function(km) {
                            return 1 == km.getSelectedNodes().length ? km.getSelectedNodes()[0].getData("color") : "mixed"
                        }
                    }),
                    background: kity.createClass("backgroudCommand", {
                        base: Command,
                        execute: function(km, color) {
                            km.getSelectedNodes().forEach(function(n) {
                                n.setData("background", color),
                                n.render()
                            })
                        },
                        queryState: function(km) {
                            return 0 === km.getSelectedNodes().length ? -1 : 0
                        },
                        queryValue: function(km) {
                            return 1 == km.getSelectedNodes().length ? km.getSelectedNodes()[0].getData("background") : "mixed"
                        }
                    }),
                    fontfamily: kity.createClass("fontfamilyCommand", {
                        base: Command,
                        execute: function(km, family) {
                            km.getSelectedNodes().forEach(function(n) {
                                n.setData("font-family", family),
                                n.render(),
                                km.layout()
                            })
                        },
                        queryState: function(km) {
                            return 0 === km.getSelectedNodes().length ? -1 : 0
                        },
                        queryValue: function(km) {
                            var node = km.getSelectedNode();
                            return node ? node.getData("font-family") : null
                        }
                    }),
                    fontsize: kity.createClass("fontsizeCommand", {
                        base: Command,
                        execute: function(km, size) {
                            km.getSelectedNodes().forEach(function(n) {
                                n.setData("font-size", size),
                                n.render(),
                                km.layout(300)
                            })
                        },
                        queryState: function(km) {
                            return 0 === km.getSelectedNodes().length ? -1 : 0
                        },
                        queryValue: function(km) {
                            var node = km.getSelectedNode();
                            return node ? node.getData("font-size") : null
                        }
                    })
                }
            })
        }
    },
    _p[48] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Command = (_p.r(33),
            _p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20)
              , Renderer = _p.r(27);
            Module.register("hyperlink", {
                commands: {
                    hyperlink: kity.createClass("hyperlink", {
                        base: Command,
                        execute: function(km, url, title) {
                            km.getSelectedNodes().forEach(function(n) {
                                n.setData("hyperlink", url),
                                n.setData("hyperlinkTitle", url && title),
                                n.render()
                            }),
                            km.layout()
                        },
                        queryState: function(km) {
                            var nodes = km.getSelectedNodes()
                              , result = 0;
                            return 0 === nodes.length ? -1 : (nodes.forEach(function(n) {
                                if (n && n.getData("hyperlink"))
                                    return result = 0,
                                    !1
                            }),
                            result)
                        },
                        queryValue: function(km) {
                            var node = km.getSelectedNode();
                            return {
                                url: node.getData("hyperlink"),
                                title: node.getData("hyperlinkTitle")
                            }
                        }
                    })
                },
                renderers: {
                    right: kity.createClass("hyperlinkrender", {
                        base: Renderer,
                        create: function() {
                            var link = new kity.HyperLink
                              , linkshape = new kity.Path
                              , outline = new kity.Rect(24,22,-2,-6,4).fill("rgba(255, 255, 255, 0)");
                            return linkshape.setPathData("M16.614,10.224h-1.278c-1.668,0-3.07-1.07-3.599-2.556h4.877c0.707,0,1.278-0.571,1.278-1.278V3.834 c0-0.707-0.571-1.278-1.278-1.278h-4.877C12.266,1.071,13.668,0,15.336,0h1.278c2.116,0,3.834,1.716,3.834,3.834V6.39 C20.448,8.508,18.73,10.224,16.614,10.224z M5.112,5.112c0-0.707,0.573-1.278,1.278-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278 S14.765,6.39,14.058,6.39H6.39C5.685,6.39,5.112,5.819,5.112,5.112z M2.556,3.834V6.39c0,0.707,0.573,1.278,1.278,1.278h4.877 c-0.528,1.486-1.932,2.556-3.599,2.556H3.834C1.716,10.224,0,8.508,0,6.39V3.834C0,1.716,1.716,0,3.834,0h1.278 c1.667,0,3.071,1.071,3.599,2.556H3.834C3.129,2.556,2.556,3.127,2.556,3.834z").fill("#666"),
                            link.addShape(outline),
                            link.addShape(linkshape),
                            link.setTarget("_blank"),
                            link.setStyle("cursor", "pointer"),
                            link.on("mouseover", function() {
                                outline.fill("rgba(255, 255, 200, .8)")
                            }).on("mouseout", function() {
                                outline.fill("rgba(255, 255, 255, 0)")
                            }),
                            link
                        },
                        shouldRender: function(node) {
                            return node.getData("hyperlink")
                        },
                        update: function(link, node, box) {
                            var href = node.getData("hyperlink");
                            link.setHref(href);
                            var title = node.getData("hyperlinkTitle");
                            title = title ? [title, "(", href, ")"].join("") : href,
                            link.node.setAttributeNS("http://www.w3.org/1999/xlink", "title", title);
                            var spaceRight = node.getStyle("space-right");
                            return link.setTranslate(box.right + spaceRight + 2, -5),
                            new kity.Box({
                                x: box.right + spaceRight,
                                y: -11,
                                width: 24,
                                height: 22
                            })
                        }
                    })
                }
            })
        }
    },
    _p[49] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Command = (_p.r(33),
            _p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20)
              , Renderer = _p.r(27);
            Module.register("image", function() {
                function loadImageSize(url, callback) {
                    var img = document.createElement("img");
                    img.onload = function() {
                        callback(img.width, img.height)
                    }
                    ,
                    img.onerror = function() {
                        callback(null)
                    }
                    ,
                    img.src = url
                }
                function fitImageSize(width, height, maxWidth, maxHeight) {
                    var ratio = width / height
                      , fitRatio = maxWidth / maxHeight;
                    return width > maxWidth && ratio > fitRatio ? (width = maxWidth,
                    height = width / ratio) : height > maxHeight && (height = maxHeight,
                    width = height * ratio),
                    {
                        width: 0 | width,
                        height: 0 | height
                    }
                }
                return {
                    defaultOptions: {
                        maxImageWidth: 200,
                        maxImageHeight: 200
                    },
                    commands: {
                        image: kity.createClass("ImageCommand", {
                            base: Command,
                            execute: function(km, url, title) {
                                var nodes = km.getSelectedNodes();
                                loadImageSize(url, function(width, height) {
                                    nodes.forEach(function(n) {
                                        var size = fitImageSize(width, height, km.getOption("maxImageWidth"), km.getOption("maxImageHeight"));
                                        n.setData("image", url),
                                        n.setData("imageTitle", url && title),
                                        n.setData("imageSize", url && size),
                                        n.render()
                                    }),
                                    km.fire("saveScene"),
                                    km.layout(300)
                                })
                            },
                            queryState: function(km) {
                                var nodes = km.getSelectedNodes()
                                  , result = 0;
                                return 0 === nodes.length ? -1 : (nodes.forEach(function(n) {
                                    if (n && n.getData("image"))
                                        return result = 0,
                                        !1
                                }),
                                result)
                            },
                            queryValue: function(km) {
                                var node = km.getSelectedNode();
                                return {
                                    url: node.getData("image"),
                                    title: node.getData("imageTitle")
                                }
                            }
                        })
                    },
                    renderers: {
                        top: kity.createClass("ImageRenderer", {
                            base: Renderer,
                            create: function(node) {
                                return new kity.Image(node.getData("image"))
                            },
                            shouldRender: function(node) {
                                return node.getData("image")
                            },
                            update: function(image, node, box) {
                                var url = node.getData("image")
                                  , title = node.getData("imageTitle")
                                  , size = node.getData("imageSize")
                                  , spaceTop = node.getStyle("space-top");
                                if (size) {
                                    title && image.node.setAttributeNS("http://www.w3.org/1999/xlink", "title", title);
                                    var x = box.cx - size.width / 2
                                      , y = box.y - size.height - spaceTop;
                                    return image.setUrl(url).setX(0 | x).setY(0 | y).setWidth(0 | size.width).setHeight(0 | size.height),
                                    new kity.Box(0 | x,0 | y,0 | size.width,0 | size.height)
                                }
                            }
                        })
                    }
                }
            })
        }
    },
    _p[50] = {
        value: function(require, exports, module) {
            var Module = (_p.r(17),
            _p.r(33),
            _p.r(15),
            _p.r(19),
            _p.r(21),
            _p.r(9),
            _p.r(20));
            _p.r(27);
            Module.register("KeyboardModule", function() {
                function buildPositionNetwork(root) {
                    var p, pointIndexes = [];
                    root.traverse(function(node) {
                        p = node.getLayoutBox(),
                        p.width && p.height && pointIndexes.push({
                            left: p.x,
                            top: p.y,
                            right: p.x + p.width,
                            bottom: p.y + p.height,
                            width: p.width,
                            height: p.height,
                            node: node
                        })
                    });
                    for (var i = 0; i < pointIndexes.length; i++)
                        findClosestPointsFor(pointIndexes, i)
                }
                function getCoefedDistance(box1, box2) {
                    var xMin, xMax, yMin, yMax, xDist, yDist, dist;
                    xMin = min(box1.left, box2.left),
                    xMax = max(box1.right, box2.right),
                    yMin = min(box1.top, box2.top),
                    yMax = max(box1.bottom, box2.bottom),
                    xDist = xMax - xMin - box1.width - box2.width,
                    yDist = yMax - yMin - box1.height - box2.height,
                    dist = xDist < 0 ? yDist : yDist < 0 ? xDist : sqrt(xDist * xDist + yDist * yDist);
                    var node1 = box1.node
                      , node2 = box2.node;
                    return node1.parent == node2.parent && (dist /= 10),
                    node2.parent == node1 && (dist /= 5),
                    dist
                }
                function findClosestPointsFor(pointIndexes, iFind) {
                    for (var current, dist, find = pointIndexes[iFind], most = {}, i = 0; i < pointIndexes.length; i++)
                        i != iFind && (current = pointIndexes[i],
                        dist = getCoefedDistance(current, find),
                        current.right < find.left && (!most.left || dist < most.left.dist) && (most.left = {
                            dist: dist,
                            node: current.node
                        }),
                        current.left > find.right && (!most.right || dist < most.right.dist) && (most.right = {
                            dist: dist,
                            node: current.node
                        }),
                        current.bottom < find.top && (!most.top || dist < most.top.dist) && (most.top = {
                            dist: dist,
                            node: current.node
                        }),
                        current.top > find.bottom && (!most.down || dist < most.down.dist) && (most.down = {
                            dist: dist,
                            node: current.node
                        }));
                    find.node._nearestNodes = {
                        right: most.right && most.right.node || null,
                        top: most.top && most.top.node || null,
                        left: most.left && most.left.node || null,
                        down: most.down && most.down.node || null
                    }
                }
                function navigateTo(km, direction) {
                    var referNode = km.getSelectedNode();
                    if (!referNode)
                        return km.select(km.getRoot()),
                        void buildPositionNetwork(km.getRoot());
                    referNode._nearestNodes || buildPositionNetwork(km.getRoot());
                    var nextNode = referNode._nearestNodes[direction];
                    nextNode && km.select(nextNode, !0)
                }
                var min = Math.min
                  , max = Math.max
                  , sqrt = (Math.abs,
                Math.sqrt);
                Math.exp;
                return {
                    events: {
                        layoutallfinish: function() {
                            buildPositionNetwork(this.getRoot())
                        },
                        "normal.keydown readonly.keydown": function(e) {
                            var minder = this;
                            ["left", "right", "up", "down"].forEach(function(key) {
                                e.isShortcutKey(key) && (navigateTo(minder, "up" == key ? "top" : key),
                                e.preventDefault())
                            })
                        }
                    }
                }
            })
        }
    },
    _p[51] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Command = _p.r(9)
              , Module = _p.r(20)
              , LayoutCommand = kity.createClass("LayoutCommand", {
                base: Command,
                execute: function(minder, name) {
                    minder.getSelectedNodes().forEach(function(node) {
                        node.layout(name)
                    })
                },
                queryValue: function(minder) {
                    var node = minder.getSelectedNode();
                    if (node)
                        return node.getData("layout")
                },
                queryState: function(minder) {
                    return minder.getSelectedNode() ? 0 : -1
                }
            })
              , ResetLayoutCommand = kity.createClass("ResetLayoutCommand", {
                base: Command,
                execute: function(minder) {
                    var nodes = minder.getSelectedNodes();
                    nodes.length || (nodes = [minder.getRoot()]),
                    nodes.forEach(function(node) {
                        node.traverse(function(child) {
                            child.resetLayoutOffset(),
                            child.isRoot() || child.setData("layout", null)
                        })
                    }),
                    minder.layout(300)
                },
                enableReadOnly: !0
            });
            Module.register("LayoutModule", {
                commands: {
                    layout: LayoutCommand,
                    resetlayout: ResetLayoutCommand
                },
                contextmenu: [{
                    command: "resetlayout"
                }, {
                    divider: !0
                }],
                commandShortcutKeys: {
                    resetlayout: "Ctrl+Shift+L"
                }
            })
        }
    },
    _p[52] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , MinderNode = (_p.r(33),
            _p.r(19),
            _p.r(21))
              , Command = _p.r(9)
              , Module = _p.r(20)
              , AppendChildCommand = (_p.r(27),
            kity.createClass("AppendChildCommand", {
                base: Command,
                execute: function(km, text) {
                    var parent = km.getSelectedNode();
                    if (!parent)
                        return null;
                    var node = km.createNode(text, parent);
                    km.select(node, !0),
                    parent.isExpanded() ? node.render() : (parent.expand(),
                    parent.renderTree()),
                    km.layout(600)
                },
                queryState: function(km) {
                    return km.getSelectedNode() ? 0 : -1
                }
            }))
              , AppendSiblingCommand = kity.createClass("AppendSiblingCommand", {
                base: Command,
                execute: function(km, text) {
                    var sibling = km.getSelectedNode()
                      , parent = sibling.parent;
                    if (!parent)
                        return km.execCommand("AppendChildNode", text);
                    var node = km.createNode(text, parent, sibling.getIndex() + 1);
                    node.setGlobalLayoutTransform(sibling.getGlobalLayoutTransform()),
                    km.select(node, !0),
                    node.render(),
                    km.layout(600)
                },
                queryState: function(km) {
                    return km.getSelectedNode() ? 0 : -1
                }
            })
              , RemoveNodeCommand = kity.createClass("RemoverNodeCommand", {
                base: Command,
                execute: function(km) {
                    var nodes = km.getSelectedNodes()
                      , ancestor = MinderNode.getCommonAncestor.apply(null, nodes)
                      , index = nodes[0].getIndex();
                    if (nodes.forEach(function(node) {
                        node.isRoot() || km.removeNode(node)
                    }),
                    1 == nodes.length) {
                        var selectBack = ancestor.children[index - 1] || ancestor.children[index];
                        km.select(selectBack || ancestor || km.getRoot(), !0)
                    } else
                        km.select(ancestor || km.getRoot(), !0);
                    km.layout(600)
                },
                queryState: function(km) {
                    var selectedNode = km.getSelectedNode();
                    return selectedNode && !selectedNode.isRoot() ? 0 : -1
                }
            })
              , AppendParentCommand = kity.createClass("AppendParentCommand", {
                base: Command,
                execute: function(km, text) {
                    var nodes = km.getSelectedNodes();
                    nodes.sort(function(a, b) {
                        return a.getIndex() - b.getIndex()
                    });
                    var parent = nodes[0].parent
                      , newParent = km.createNode(text, parent, nodes[0].getIndex());
                    nodes.forEach(function(node) {
                        newParent.appendChild(node)
                    }),
                    newParent.setGlobalLayoutTransform(nodes[nodes.length >> 1].getGlobalLayoutTransform()),
                    km.select(newParent, !0),
                    km.layout(600)
                },
                queryState: function(km) {
                    var nodes = km.getSelectedNodes();
                    if (!nodes.length)
                        return -1;
                    var parent = nodes[0].parent;
                    if (!parent)
                        return -1;
                    for (var i = 1; i < nodes.length; i++)
                        if (nodes[i].parent != parent)
                            return -1;
                    return 0
                }
            });
            Module.register("NodeModule", function() {
                return {
                    commands: {
                        AppendChildNode: AppendChildCommand,
                        AppendSiblingNode: AppendSiblingCommand,
                        RemoveNode: RemoveNodeCommand,
                        AppendParentNode: AppendParentCommand
                    },
                    commandShortcutKeys: {
                        appendsiblingnode: "normal::Enter",
                        appendchildnode: "normal::Insert|Tab",
                        appendparentnode: "normal::Shift+Tab|normal::Shift+Insert",
                        removenode: "normal::Del|Backspace"
                    }
                }
            })
        }
    },
    _p[53] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Command = (_p.r(33),
            _p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20)
              , Renderer = _p.r(27);
            Module.register("NoteModule", function() {
                var NoteCommand = kity.createClass("NoteCommand", {
                    base: Command,
                    execute: function(minder, note) {
                        var node = minder.getSelectedNode();
                        node.setData("note", note),
                        node.render(),
                        node.getMinder().layout(300)
                    },
                    queryState: function(minder) {
                        return 1 === minder.getSelectedNodes().length ? 0 : -1
                    },
                    queryValue: function(minder) {
                        var node = minder.getSelectedNode();
                        return node && node.getData("note")
                    }
                })
                  , NoteIcon = kity.createClass("NoteIcon", {
                    base: kity.Group,
                    constructor: function() {
                        this.callBase(),
                        this.width = 16,
                        this.height = 17,
                        this.rect = new kity.Rect(16,17,.5,-8.5,2).fill("transparent"),
                        this.path = (new kity.Path).setPathData("M9,9H3V8h6L9,9L9,9z M9,7H3V6h6V7z M9,5H3V4h6V5z M8.5,11H2V2h8v7.5 M9,12l2-2V1H1v11").setTranslate(2.5, -6.5),
                        this.addShapes([this.rect, this.path]),
                        this.on("mouseover", function() {
                            this.rect.fill("rgba(255, 255, 200, .8)")
                        }).on("mouseout", function() {
                            this.rect.fill("transparent")
                        }),
                        this.setStyle("cursor", "pointer")
                    }
                });
                return {
                    renderers: {
                        right: kity.createClass("NoteIconRenderer", {
                            base: Renderer,
                            create: function(node) {
                                var icon = new NoteIcon;
                                return icon.on("mousedown", function(e) {
                                    e.preventDefault(),
                                    node.getMinder().fire("editnoterequest")
                                }),
                                icon.on("mouseover", function() {
                                    node.getMinder().fire("shownoterequest", {
                                        node: node,
                                        icon: icon
                                    })
                                }),
                                icon.on("mouseout", function() {
                                    node.getMinder().fire("hidenoterequest", {
                                        node: node,
                                        icon: icon
                                    })
                                }),
                                icon
                            },
                            shouldRender: function(node) {
                                return node.getData("note")
                            },
                            update: function(icon, node, box) {
                                var x = box.right + node.getStyle("space-left")
                                  , y = box.cy;
                                return icon.path.fill(node.getStyle("color")),
                                icon.setTranslate(x, y),
                                new kity.Box(x,Math.round(y - icon.height / 2),icon.width,icon.height)
                            }
                        })
                    },
                    commands: {
                        note: NoteCommand
                    }
                }
            })
        }
    },
    _p[54] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Module = (_p.r(19),
            _p.r(21),
            _p.r(9),
            _p.r(20))
              , Renderer = _p.r(27)
              , OutlineRenderer = kity.createClass("OutlineRenderer", {
                base: Renderer,
                create: function(node) {
                    var outline = (new kity.Rect).setId(utils.uuid("node_outline"));
                    return this.bringToBack = !0,
                    outline
                },
                update: function(outline, node, box) {
                    var shape = node.getStyle("shape")
                      , paddingLeft = node.getStyle("padding-left")
                      , paddingRight = node.getStyle("padding-right")
                      , paddingTop = node.getStyle("padding-top")
                      , paddingBottom = node.getStyle("padding-bottom")
                      , outlineBox = {
                        x: box.x - paddingLeft,
                        y: box.y - paddingTop,
                        width: box.width + paddingLeft + paddingRight,
                        height: box.height + paddingTop + paddingBottom
                    }
                      , radius = node.getStyle("radius");
                    if (shape && "circle" == shape) {
                        var p = Math.pow;
                        radius = (0,
                        Math.round)(Math.sqrt(p(outlineBox.width, 2) + p(outlineBox.height, 2)) / 2),
                        outlineBox.x = box.cx - radius,
                        outlineBox.y = box.cy - radius,
                        outlineBox.width = 2 * radius,
                        outlineBox.height = 2 * radius
                    }
                    var prefix = node.isSelected() ? node.getMinder().isFocused() ? "selected-" : "blur-selected-" : "";
                    return outline.setPosition(outlineBox.x, outlineBox.y).setSize(outlineBox.width, outlineBox.height).setRadius(radius).fill(node.getData("background") || node.getStyle(prefix + "background") || node.getStyle("background")).stroke(node.getStyle(prefix + "stroke" || node.getStyle("stroke")), node.getStyle(prefix + "stroke-width")),
                    new kity.Box(outlineBox)
                }
            })
              , ShadowRenderer = kity.createClass("ShadowRenderer", {
                base: Renderer,
                create: function(node) {
                    return this.bringToBack = !0,
                    new kity.Rect
                },
                shouldRender: function(node) {
                    return node.getStyle("shadow")
                },
                update: function(shadow, node, box) {
                    shadow.setPosition(box.x + 4, box.y + 5).fill(node.getStyle("shadow"));
                    var shape = node.getStyle("shape");
                    if (shape) {
                        if ("circle" == shape) {
                            var width = Math.max(box.width, box.height);
                            shadow.setSize(width, width),
                            shadow.setRadius(width / 2)
                        }
                    } else
                        shadow.setSize(box.width, box.height),
                        shadow.setRadius(node.getStyle("radius"))
                }
            })
              , marker = new kity.Marker;
            marker.setWidth(10),
            marker.setHeight(12),
            marker.setRef(0, 0),
            marker.setViewBox(-6, -4, 8, 10),
            marker.addShape((new kity.Path).setPathData("M-5-3l5,3,-5,3").stroke("#33ffff"));
            var wireframeOption = /wire/.test(window.location.href)
              , WireframeRenderer = kity.createClass("WireframeRenderer", {
                base: Renderer,
                create: function() {
                    var wireframe = new kity.Group
                      , oxy = this.oxy = (new kity.Path).stroke("#f6f").setPathData("M0,-50L0,50M-50,0L50,0")
                      , box = this.wireframe = (new kity.Rect).stroke("lightgreen")
                      , vectorIn = this.vectorIn = (new kity.Path).stroke("#66ffff")
                      , vectorOut = this.vectorOut = (new kity.Path).stroke("#66ffff");
                    return vectorIn.setMarker(marker, "end"),
                    vectorOut.setMarker(marker, "end"),
                    wireframe.addShapes([oxy, box, vectorIn, vectorOut])
                },
                shouldRender: function() {
                    return wireframeOption
                },
                update: function(created, node, box) {
                    this.wireframe.setPosition(box.x, box.y).setSize(box.width, box.height);
                    var pin = node.getVertexIn()
                      , pout = node.getVertexOut()
                      , vin = node.getLayoutVectorIn().normalize(30)
                      , vout = node.getLayoutVectorOut().normalize(30);
                    this.vectorIn.setPathData(["M", pin.offset(vin.reverse()), "L", pin]),
                    this.vectorOut.setPathData(["M", pout, "l", vout])
                }
            });
            Module.register("OutlineModule", function() {
                return {
                    events: wireframeOption ? {
                        ready: function() {
                            this.getPaper().addResource(marker)
                        },
                        layoutallfinish: function() {
                            this.getRoot().traverse(function(node) {
                                node.getRenderer("WireframeRenderer").update(null, node, node.getContentBox())
                            })
                        }
                    } : null,
                    renderers: {
                        outline: OutlineRenderer,
                        outside: [ShadowRenderer, WireframeRenderer]
                    }
                }
            })
        }
    },
    _p[55] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Command = (_p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20)
              , Renderer = _p.r(27);
            Module.register("PriorityModule", function() {
                var PRIORITY_COLORS = [null, ["#ec5353", "#ec5353"], ["#fdb52d", "#fdb52d"], ["#4f95fc", "#4f95fc"], ["#20cf5c", "#20cf5c"], ["#8cbac0", "#8cbac0"], ["#8cbac0", "#8cbac0"], ["#8cbac0", "#8cbac0"], ["#8cbac0", "#8cbac0"], ["#8cbac0", "#8cbac0"]]
                  , MASK_PATH = "M20,10c0,3.866-3.134,7-7,7H7c-3.866,0-7-3.134-7-7V7c0-3.866,3.134-7,7-7h6c3.866,0,7,3.134,7,7V10z"
                  , PriorityIcon = kity.createClass("PriorityIcon", {
                    base: kity.Group,
                    constructor: function() {
                        this.callBase(),
                        this.setSize(20),
                        this.create(),
                        this.setId(utils.uuid("node_priority"))
                    },
                    setSize: function(size) {
                        this.width = this.height = size
                    },
                    create: function() {
                        var back, mask, number;
                        (new kity.Path).setPathData(MASK_PATH).fill("white"),
                        back = (new kity.Path).setPathData("M0,13c0,3.866,3.134,7,7,7h6c3.866,0,7-3.134,7-7V7H0V13z").setTranslate(.5, .5),
                        mask = (new kity.Path).setPathData(MASK_PATH).setTranslate(.5, .5),
                        number = (new kity.Text).setTranslate(1, 1).setX(this.width / 2 - .5).setY(this.height / 2).setTextAnchor("middle").setVerticalAlign("middle").setFontSize(12).fill("white"),
                        this.addShapes([back, mask, number]),
                        this.mask = mask,
                        this.back = back,
                        this.number = number
                    },
                    setValue: function(value) {
                        var back = this.back
                          , mask = this.mask
                          , number = this.number
                          , color = PRIORITY_COLORS[value];
                        color && (back.fill(color[1]),
                        mask.fill(color[0])),
                        number.setContent(value)
                    }
                });
                return {
                    commands: {
                        priority: kity.createClass("SetPriorityCommand", {
                            base: Command,
                            execute: function(km, value) {
                                for (var nodes = km.getSelectedNodes(), i = 0; i < nodes.length; i++)
                                    nodes[i].setData("priority", value || null).render();
                                km.layout()
                            },
                            queryValue: function(km) {
                                for (var val, nodes = km.getSelectedNodes(), i = 0; i < nodes.length && !(val = nodes[i].getData("priority")); i++)
                                    ;
                                return val || null
                            },
                            queryState: function(km) {
                                return km.getSelectedNodes().length ? 0 : -1
                            }
                        })
                    },
                    renderers: {
                        left: kity.createClass("PriorityRenderer", {
                            base: Renderer,
                            create: function(node) {
                                return new PriorityIcon
                            },
                            shouldRender: function(node) {
                                return node.getData("priority")
                            },
                            update: function(icon, node, box) {
                                var x, y, data = node.getData("priority"), spaceLeft = node.getStyle("space-left");
                                return icon.setValue(data),
                                x = box.left - icon.width - spaceLeft,
                                y = -icon.height / 2,
                                icon.setTranslate(x, y),
                                new kity.Box({
                                    x: x,
                                    y: y,
                                    width: icon.width,
                                    height: icon.height
                                })
                            }
                        })
                    }
                }
            })
        }
    },
    _p[56] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , Command = (_p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20)
              , Renderer = _p.r(27);
            Module.register("ProgressModule", function() {
                var minder = this
                  , FRAME_GRAD = (new kity.LinearGradient).pipe(function(g) {
                    g.setStartPosition(0, 0),
                    g.setEndPosition(0, .1),
                    g.addStop(0, "#20cf5c"),
                    g.addStop(1, "#20cf5c")
                });
                minder.getPaper().addResource(FRAME_GRAD);
                var ProgressIcon = kity.createClass("ProgressIcon", {
                    base: kity.Group,
                    constructor: function(value) {
                        this.callBase(),
                        this.setSize(20),
                        this.create(),
                        this.setValue(value),
                        this.setId(utils.uuid("node_progress")),
                        this.translate(.5, .5)
                    },
                    setSize: function(size) {
                        this.width = this.height = size
                    },
                    create: function() {
                        var bg, pie, frame, check;
                        bg = new kity.Circle(9).fill("#FFF"),
                        pie = new kity.Pie(9,1).fill("#20cf5c").setAngleOffset(-90),
                        frame = (new kity.Path).setTranslate(-10, -10).setPathData("M10,0C4.477,0,0,4.477,0,10c0,5.523,4.477,10,10,10s10-4.477,10-10C20,4.477,15.523,0,10,0zM10,18c-4.418,0-8-3.582-8-8s3.582-8,8-8s8,3.582,8,8S14.418,18,10,18z").fill(FRAME_GRAD),
                        check = (new kity.Path).setTranslate(-10, -10).setPathData("M15.812,7.896l-6.75,6.75l-4.5-4.5L6.25,8.459l2.812,2.803l5.062-5.053L15.812,7.896z").fill("#FEE");
                        var play = (new kity.Path).setTranslate(-2, -4).setPathData("m0,0l0,8l6,-4l-6,-4z").fill(FRAME_GRAD);
                        this.pie = pie,
                        this.check = check,
                        this.play = play,
                        this.addShapes([bg, pie, check, frame, this.play])
                    },
                    setValue: function(value) {
                        this.pie.setAngle(360 * (value - 1) / 8),
                        this.check.setVisible(9 == value),
                        this.play.setVisible(1 == value)
                    }
                });
                return {
                    commands: {
                        progress: kity.createClass("ProgressCommand", {
                            base: Command,
                            execute: function(km, value) {
                                for (var nodes = km.getSelectedNodes(), i = 0; i < nodes.length; i++)
                                    nodes[i].setData("progress", value || null).render();
                                km.layout()
                            },
                            queryValue: function(km) {
                                for (var val, nodes = km.getSelectedNodes(), i = 0; i < nodes.length && !(val = nodes[i].getData("progress")); i++)
                                    ;
                                return val || null
                            },
                            queryState: function(km) {
                                return km.getSelectedNodes().length ? 0 : -1
                            }
                        })
                    },
                    renderers: {
                        left: kity.createClass("ProgressRenderer", {
                            base: Renderer,
                            create: function(node) {
                                return new ProgressIcon
                            },
                            shouldRender: function(node) {
                                return node.getData("progress")
                            },
                            update: function(icon, node, box) {
                                var x, y, data = node.getData("progress"), spaceLeft = node.getStyle("space-left");
                                return icon.setValue(data),
                                x = box.left - icon.width - spaceLeft,
                                y = -icon.height / 2,
                                icon.setTranslate(x + icon.width / 2, y + icon.height / 2),
                                new kity.Box(x,y,icon.width,icon.height)
                            }
                        })
                    }
                }
            })
        }
    },
    _p[57] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = (_p.r(33),
            _p.r(19))
              , Command = (_p.r(21),
            _p.r(9))
              , Module = _p.r(20)
              , Renderer = _p.r(27);
            Module.register("Resource", function() {
                var blake32 = function() {
                    var k, g, r, l, m, o, p, q, t, w, x;
                    return x = 4 * (1 << 30),
                    k = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
                    m = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479],
                    w = function(i) {
                        return i < 0 && (i += x),
                        ("00000000" + i.toString(16)).slice(-8)
                    }
                    ,
                    o = [[16, 50, 84, 118, 152, 186, 220, 254], [174, 132, 249, 109, 193, 32, 123, 53], [139, 12, 37, 223, 234, 99, 23, 73], [151, 19, 205, 235, 98, 165, 4, 143], [9, 117, 66, 250, 30, 203, 134, 211], [194, 166, 176, 56, 212, 87, 239, 145], [92, 241, 222, 164, 112, 54, 41, 184], [189, 231, 28, 147, 5, 79, 104, 162], [246, 158, 59, 128, 44, 125, 65, 90], [42, 72, 103, 81, 191, 233, 195, 13]],
                    p = function(a, b, n) {
                        var s = q[a] ^ q[b];
                        q[a] = s >>> n | s << 32 - n
                    }
                    ,
                    g = function(i, a, b, c, d) {
                        var u = l + o[r][i] % 16
                          , v = l + (o[r][i] >> 4);
                        a %= 4,
                        b = 4 + b % 4,
                        c = 8 + c % 4,
                        d = 12 + d % 4,
                        q[a] += q[b] + (t[u] ^ m[v % 16]),
                        p(d, a, 16),
                        q[c] += q[d],
                        p(b, c, 12),
                        q[a] += q[b] + (t[v] ^ m[u % 16]),
                        p(d, a, 8),
                        q[c] += q[d],
                        p(b, c, 7)
                    }
                    ,
                    function(a, b) {
                        b instanceof Array && 4 === b.length || (b = [0, 0, 0, 0]);
                        var c, d, e, L, f, h, j, i;
                        for (d = k.slice(0),
                        c = m.slice(0, 8),
                        r = 0; r < 4; r += 1)
                            c[r] ^= b[r];
                        if (e = 16 * a.length,
                        f = e % 512 > 446 || e % 512 == 0 ? 0 : e,
                        e % 512 == 432)
                            a += "老";
                        else {
                            for (a += "耀"; a.length % 32 != 27; )
                                a += "\0";
                            a += ""
                        }
                        for (t = [],
                        i = 0; i < a.length; i += 2)
                            t.push(65536 * a.charCodeAt(i) + a.charCodeAt(i + 1));
                        for (t.push(0),
                        t.push(e),
                        h = t.length - 16,
                        j = 0,
                        l = 0; l < t.length; l += 16) {
                            for (j += 512,
                            L = l === h ? f : Math.min(e, j),
                            q = d.concat(c),
                            q[12] ^= L,
                            q[13] ^= L,
                            r = 0; r < 10; r += 1)
                                for (i = 0; i < 8; i += 1)
                                    i < 4 ? g(i, i, i, i, i) : g(i, i, i + 1, i + 2, i + 3);
                            for (i = 0; i < 8; i += 1)
                                d[i] ^= b[i % 4] ^ q[i] ^ q[i + 8]
                        }
                        return d.map(w).join("")
                    }
                }()
                  , RESOURCE_COLOR_SERIES = [51, 303, 75, 200, 157, 0, 26, 254].map(function(h) {
                    return kity.Color.createHSL(h, 100, 85)
                });
                kity.extendClass(Minder, {
                    getHashCode: function(str) {
                        str = blake32(str);
                        var i, ch, hash = 1315423911;
                        for (i = str.length - 1; i >= 0; i--)
                            ch = str.charCodeAt(i),
                            hash ^= (hash << 5) + ch + (hash >> 2);
                        return 2147483647 & hash
                    },
                    getResourceColor: function(resource) {
                        var nextIndex, colorMapping = this._getResourceColorIndexMapping();
                        return Object.prototype.hasOwnProperty.call(colorMapping, resource) || (nextIndex = this._getNextResourceColorIndex(),
                        colorMapping[resource] = nextIndex),
                        RESOURCE_COLOR_SERIES[colorMapping[resource]] || kity.Color.createHSL(Math.floor(this.getHashCode(resource) / 2147483647 * 359), 100, 85)
                    },
                    getUsedResource: function() {
                        var resource, mapping = this._getResourceColorIndexMapping(), used = [];
                        for (resource in mapping)
                            Object.prototype.hasOwnProperty.call(mapping, resource) && used.push(resource);
                        return used
                    },
                    _getNextResourceColorIndex: function() {
                        var resource, used, i, colorMapping = this._getResourceColorIndexMapping();
                        used = [];
                        for (resource in colorMapping)
                            Object.prototype.hasOwnProperty.call(colorMapping, resource) && used.push(colorMapping[resource]);
                        for (i = 0; i < RESOURCE_COLOR_SERIES.length; i++)
                            if (!~used.indexOf(i))
                                return i;
                        return -1
                    },
                    _getResourceColorIndexMapping: function() {
                        return this._resourceColorMapping || (this._resourceColorMapping = {})
                    }
                });
                var ResourceCommand = kity.createClass("ResourceCommand", {
                    base: Command,
                    execute: function(minder, resource) {
                        var nodes = minder.getSelectedNodes();
                        "string" == typeof resource && (resource = [resource]),
                        nodes.forEach(function(node) {
                            node.setData("resource", resource).render()
                        }),
                        minder.layout(200)
                    },
                    queryValue: function(minder) {
                        var nodes = minder.getSelectedNodes()
                          , resource = [];
                        return nodes.forEach(function(node) {
                            var nodeResource = node.getData("resource");
                            nodeResource && nodeResource.forEach(function(name) {
                                ~resource.indexOf(name) || resource.push(name)
                            })
                        }),
                        resource
                    },
                    queryState: function(km) {
                        return km.getSelectedNode() ? 0 : -1
                    }
                })
                  , ResourceOverlay = kity.createClass("ResourceOverlay", {
                    base: kity.Group,
                    constructor: function() {
                        this.callBase();
                        var text, rect;
                        rect = this.rect = (new kity.Rect).setRadius(4),
                        text = this.text = (new kity.Text).setFontSize(12).setVerticalAlign("middle"),
                        this.addShapes([rect, text])
                    },
                    setValue: function(resourceName, color) {
                        var text, box, rect;
                        text = this.text,
                        resourceName == this.lastResourceName ? box = this.lastBox : (text.setContent(resourceName),
                        box = text.getBoundaryBox(),
                        this.lastResourceName = resourceName,
                        this.lastBox = box),
                        text.setX(8).fill(color.dec("l", 70)),
                        rect = this.rect,
                        rect.setPosition(0, box.y - 4),
                        this.width = Math.round(box.width + 16),
                        this.height = Math.round(box.height + 8),
                        rect.setSize(this.width, this.height),
                        rect.fill(color)
                    }
                });
                return {
                    commands: {
                        resource: ResourceCommand
                    },
                    renderers: {
                        right: kity.createClass("ResourceRenderer", {
                            base: Renderer,
                            create: function(node) {
                                return this.overlays = [],
                                new kity.Group
                            },
                            shouldRender: function(node) {
                                return node.getData("resource") && node.getData("resource").length
                            },
                            update: function(container, node, box) {
                                var spaceRight = node.getStyle("space-right")
                                  , overlays = this.overlays
                                  , resource = node.getData("resource").filter(function(ele) {
                                    return null !== ele
                                });
                                if (0 !== resource.length) {
                                    var i, overlay, x, minder = node.getMinder();
                                    for (x = 0,
                                    i = 0; i < resource.length; i++)
                                        x += spaceRight,
                                        overlay = overlays[i],
                                        overlay || (overlay = new ResourceOverlay,
                                        overlays.push(overlay),
                                        container.addShape(overlay)),
                                        overlay.setVisible(!0),
                                        overlay.setValue(resource[i], minder.getResourceColor(resource[i])),
                                        overlay.setTranslate(x, -1),
                                        x += overlay.width;
                                    for (; overlay = overlays[i++]; )
                                        overlay.setVisible(!1);
                                    return container.setTranslate(box.right, 0),
                                    new kity.Box({
                                        x: box.right,
                                        y: Math.round(-overlays[0].height / 2),
                                        width: x,
                                        height: overlays[0].height
                                    })
                                }
                            }
                        })
                    }
                }
            })
        }
    },
    _p[58] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Module = (_p.r(33),
            _p.r(19),
            _p.r(21),
            _p.r(9),
            _p.r(20));
            _p.r(27);
            Module.register("Select", function() {
                var minder = this
                  , rc = minder.getRenderContainer()
                  , marqueeActivator = function() {
                    var startPosition = null
                      , marqueeShape = new kity.Path
                      , marqueeMode = !1;
                    return {
                        selectStart: function(e) {
                            if (!e.originEvent.button && !e.originEvent.altKey)
                                return startPosition ? this.selectEnd() : void (startPosition = e.getPosition(rc).round())
                        },
                        selectMove: function(e) {
                            if ("textedit" != minder.getStatus() && startPosition) {
                                var p1 = startPosition
                                  , p2 = e.getPosition(rc);
                                if (!marqueeMode) {
                                    if (kity.Vector.fromPoints(p1, p2).length() < 10)
                                        return;
                                    marqueeMode = !0,
                                    rc.addShape(marqueeShape),
                                    marqueeShape.fill(minder.getStyle("marquee-background")).stroke(minder.getStyle("marquee-stroke")).setOpacity(.8).getDrawer().clear()
                                }
                                var marquee = new kity.Box(p1.x,p1.y,p2.x - p1.x,p2.y - p1.y)
                                  , selectedNodes = [];
                                marquee.left = Math.round(marquee.left),
                                marquee.top = Math.round(marquee.top),
                                marquee.right = Math.round(marquee.right),
                                marquee.bottom = Math.round(marquee.bottom),
                                marqueeShape.getDrawer().pipe(function() {
                                    this.clear(),
                                    this.moveTo(marquee.left, marquee.top),
                                    this.lineTo(marquee.right, marquee.top),
                                    this.lineTo(marquee.right, marquee.bottom),
                                    this.lineTo(marquee.left, marquee.bottom),
                                    this.close()
                                }),
                                minder.getRoot().traverse(function(node) {
                                    node.getLayoutBox().intersect(marquee).isEmpty() || selectedNodes.push(node)
                                }),
                                minder.select(selectedNodes, !0),
                                window.getSelection().removeAllRanges()
                            }
                        },
                        selectEnd: function(e) {
                            startPosition && (startPosition = null),
                            marqueeMode && (marqueeShape.fadeOut(200, "ease", 0, function() {
                                marqueeShape.remove && marqueeShape.remove()
                            }),
                            marqueeMode = !1)
                        }
                    }
                }()
                  , lastDownNode = null
                  , lastDownPosition = null;
                return {
                    init: function() {
                        window.addEventListener("mouseup", function() {
                            marqueeActivator.selectEnd()
                        })
                    },
                    events: {
                        mousedown: function(e) {
                            var downNode = e.getTargetNode();
                            downNode ? e.isShortcutKey("Ctrl") ? this.toggleSelect(downNode) : downNode.isSelected() ? this.isSingleSelect() || (lastDownNode = downNode,
                            lastDownPosition = e.getPosition()) : this.select(downNode, !0) : (this.removeAllSelectedNodes(),
                            marqueeActivator.selectStart(e),
                            this.setStatus("normal"))
                        },
                        mousemove: marqueeActivator.selectMove,
                        mouseup: function(e) {
                            var upNode = e.getTargetNode();
                            if (upNode && upNode == lastDownNode) {
                                var upPosition = e.getPosition();
                                kity.Vector.fromPoints(lastDownPosition, upPosition).length() < 1 && this.select(lastDownNode, !0),
                                lastDownNode = null
                            }
                            marqueeActivator.selectEnd(e)
                        },
                        "normal.keydown": function(e) {
                            if (e.isShortcutKey("ctrl+a")) {
                                var selectedNodes = [];
                                this.getRoot().traverse(function(node) {
                                    selectedNodes.push(node)
                                }),
                                this.select(selectedNodes, !0),
                                e.preventDefault()
                            }
                        }
                    }
                }
            })
        }
    },
    _p[59] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Command = (_p.r(33),
            _p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20);
            _p.r(27);
            Module.register("StyleModule", function() {
                function hasStyle(node) {
                    for (var data = node.getData(), i = 0; i < styleNames.length; i++)
                        if (styleNames[i]in data)
                            return !0
                }
                var styleNames = ["font-size", "font-family", "font-weight", "font-style", "background", "color"]
                  , styleClipBoard = null;
                return {
                    commands: {
                        copystyle: kity.createClass("CopyStyleCommand", {
                            base: Command,
                            execute: function(minder) {
                                var node = minder.getSelectedNode()
                                  , nodeData = node.getData();
                                return styleClipBoard = {},
                                styleNames.forEach(function(name) {
                                    name in nodeData ? styleClipBoard[name] = nodeData[name] : (styleClipBoard[name] = null,
                                    delete styleClipBoard[name])
                                }),
                                styleClipBoard
                            },
                            queryState: function(minder) {
                                var nodes = minder.getSelectedNodes();
                                return 1 !== nodes.length ? -1 : hasStyle(nodes[0]) ? 0 : -1
                            }
                        }),
                        pastestyle: kity.createClass("PastStyleCommand", {
                            base: Command,
                            execute: function(minder) {
                                return minder.getSelectedNodes().forEach(function(node) {
                                    for (var name in styleClipBoard)
                                        styleClipBoard.hasOwnProperty(name) && node.setData(name, styleClipBoard[name])
                                }),
                                minder.renderNodeBatch(minder.getSelectedNodes()),
                                minder.layout(300),
                                styleClipBoard
                            },
                            queryState: function(minder) {
                                return styleClipBoard && minder.getSelectedNodes().length ? 0 : -1
                            }
                        }),
                        clearstyle: kity.createClass("ClearStyleCommand", {
                            base: Command,
                            execute: function(minder) {
                                return minder.getSelectedNodes().forEach(function(node) {
                                    styleNames.forEach(function(name) {
                                        node.setData(name)
                                    })
                                }),
                                minder.renderNodeBatch(minder.getSelectedNodes()),
                                minder.layout(300),
                                styleClipBoard
                            },
                            queryState: function(minder) {
                                var nodes = minder.getSelectedNodes();
                                if (!nodes.length)
                                    return -1;
                                for (var i = 0; i < nodes.length; i++)
                                    if (hasStyle(nodes[i]))
                                        return 0;
                                return -1
                            }
                        })
                    }
                }
            })
        }
    },
    _p[60] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , utils = _p.r(33)
              , MinderNode = (_p.r(19),
            _p.r(21))
              , Command = _p.r(9)
              , Module = _p.r(20)
              , Renderer = _p.r(27)
              , FONT_ADJUST = {
                safari: {
                    "微软雅黑,Microsoft YaHei": -.17,
                    "楷体,楷体_GB2312,SimKai": -.1,
                    "隶书, SimLi": -.1,
                    "comic sans ms": -.23,
                    "impact,chicago": -.15,
                    "times new roman": -.1,
                    "arial black,avant garde": -.17,
                    default: 0
                },
                ie: {
                    10: {
                        "微软雅黑,Microsoft YaHei": -.17,
                        "comic sans ms": -.17,
                        "impact,chicago": -.08,
                        "times new roman": .04,
                        "arial black,avant garde": -.17,
                        default: -.15
                    },
                    11: {
                        "微软雅黑,Microsoft YaHei": -.17,
                        "arial,helvetica,sans-serif": -.17,
                        "comic sans ms": -.17,
                        "impact,chicago": -.08,
                        "times new roman": .04,
                        "sans-serif": -.16,
                        "arial black,avant garde": -.17,
                        default: -.15
                    }
                },
                edge: {
                    "微软雅黑,Microsoft YaHei": -.15,
                    "arial,helvetica,sans-serif": -.17,
                    "comic sans ms": -.17,
                    "impact,chicago": -.08,
                    "sans-serif": -.16,
                    "arial black,avant garde": -.17,
                    default: -.15
                },
                sg: {
                    "微软雅黑,Microsoft YaHei": -.15,
                    "arial,helvetica,sans-serif": -.05,
                    "comic sans ms": -.22,
                    "impact,chicago": -.16,
                    "times new roman": -.03,
                    "arial black,avant garde": -.22,
                    default: -.15
                },
                chrome: {
                    Mac: {
                        "andale mono": -.05,
                        "comic sans ms": -.3,
                        "impact,chicago": -.13,
                        "times new roman": -.1,
                        "arial black,avant garde": -.17,
                        default: 0
                    },
                    Win: {
                        "微软雅黑,Microsoft YaHei": -.15,
                        "arial,helvetica,sans-serif": -.02,
                        "arial black,avant garde": -.2,
                        "comic sans ms": -.2,
                        "impact,chicago": -.12,
                        "times new roman": -.02,
                        default: -.15
                    },
                    Lux: {
                        "andale mono": -.05,
                        "comic sans ms": -.3,
                        "impact,chicago": -.13,
                        "times new roman": -.1,
                        "arial black,avant garde": -.17,
                        default: 0
                    }
                },
                firefox: {
                    Mac: {
                        "微软雅黑,Microsoft YaHei": -.2,
                        "宋体,SimSun": .05,
                        "comic sans ms": -.2,
                        "impact,chicago": -.15,
                        "arial black,avant garde": -.17,
                        "times new roman": -.1,
                        default: .05
                    },
                    Win: {
                        "微软雅黑,Microsoft YaHei": -.16,
                        "andale mono": -.17,
                        "arial,helvetica,sans-serif": -.17,
                        "comic sans ms": -.22,
                        "impact,chicago": -.23,
                        "times new roman": -.22,
                        "sans-serif": -.22,
                        "arial black,avant garde": -.17,
                        default: -.16
                    },
                    Lux: {
                        "宋体,SimSun": -.2,
                        "微软雅黑,Microsoft YaHei": -.2,
                        "黑体, SimHei": -.2,
                        "隶书, SimLi": -.2,
                        "楷体,楷体_GB2312,SimKai": -.2,
                        "andale mono": -.2,
                        "arial,helvetica,sans-serif": -.2,
                        "comic sans ms": -.2,
                        "impact,chicago": -.2,
                        "times new roman": -.2,
                        "sans-serif": -.2,
                        "arial black,avant garde": -.2,
                        default: -.16
                    }
                }
            }
              , TextRenderer = kity.createClass("TextRenderer", {
                base: Renderer,
                create: function() {
                    return (new kity.Group).setId(utils.uuid("node_text"))
                },
                update: function(textGroup, node) {
                    function getDataOrStyle(name) {
                        return node.getData(name) || node.getStyle(name)
                    }
                    var adjust, nodeText = node.getText(), textArr = nodeText ? nodeText.split("\n") : [" "], lineHeight = node.getStyle("line-height"), fontSize = getDataOrStyle("font-size"), fontFamily = getDataOrStyle("font-family") || "default", height = lineHeight * fontSize * textArr.length - (lineHeight - 1) * fontSize, yStart = -height / 2, Browser = kity.Browser;
                    Browser.chrome || Browser.opera || Browser.bd || "chrome" === Browser.lb ? adjust = FONT_ADJUST.chrome[Browser.platform][fontFamily] : Browser.gecko ? adjust = FONT_ADJUST.firefox[Browser.platform][fontFamily] : Browser.sg ? adjust = FONT_ADJUST.sg[fontFamily] : Browser.safari ? adjust = FONT_ADJUST.safari[fontFamily] : Browser.ie ? adjust = FONT_ADJUST.ie[Browser.version][fontFamily] : Browser.edge ? adjust = FONT_ADJUST.edge[fontFamily] : Browser.lb && (adjust = .9),
                    textGroup.setTranslate(0, (adjust || 0) * fontSize);
                    var rBox = new kity.Box
                      , r = Math.round;
                    this.setTextStyle(node, textGroup);
                    var i, ci, textShape, text, textLength = textArr.length, textGroupLength = textGroup.getItems().length;
                    if (textLength < textGroupLength)
                        for (i = textLength,
                        ci; ci = textGroup.getItem(i); )
                            textGroup.removeItem(i);
                    else if (textLength > textGroupLength)
                        for (var growth = textLength - textGroupLength; growth--; )
                            textShape = (new kity.Text).setAttr("text-rendering", "inherit"),
                            kity.Browser.ie || kity.Browser.edge ? textShape.setVerticalAlign("top") : textShape.setAttr("dominant-baseline", "text-before-edge"),
                            textGroup.addItem(textShape);
                    for (i = 0,
                    textShape; text = textArr[i],
                    textShape = textGroup.getItem(i); i++)
                        textShape.setContent(text),
                        (kity.Browser.ie || kity.Browser.edge) && textShape.fixPosition();
                    this.setTextStyle(node, textGroup);
                    var textHash = node.getText() + ["font-size", "font-name", "font-weight", "font-style"].map(getDataOrStyle).join("/");
                    return node._currentTextHash == textHash && node._currentTextGroupBox ? node._currentTextGroupBox : (node._currentTextHash = textHash,
                    function() {
                        textGroup.eachItem(function(i, textShape) {
                            var y = yStart + i * fontSize * lineHeight;
                            textShape.setY(y);
                            var bbox = textShape.getBoundaryBox();
                            rBox = rBox.merge(new kity.Box(0,y,bbox.height && bbox.width || 1,fontSize))
                        });
                        var nBox = new kity.Box(r(rBox.x),r(rBox.y),r(rBox.width),r(rBox.height));
                        return node._currentTextGroupBox = nBox,
                        nBox
                    }
                    )
                },
                setTextStyle: function(node, text) {
                    TextRenderer._styleHooks.forEach(function(hook) {
                        hook(node, text)
                    })
                }
            })
              , TextCommand = kity.createClass({
                base: Command,
                execute: function(minder, text) {
                    var node = minder.getSelectedNode();
                    node && (node.setText(text),
                    node.render(),
                    minder.layout())
                },
                queryState: function(minder) {
                    return 1 == minder.getSelectedNodes().length ? 0 : -1
                },
                queryValue: function(minder) {
                    var node = minder.getSelectedNode();
                    return node ? node.getText() : null
                }
            });
            utils.extend(TextRenderer, {
                _styleHooks: [],
                registerStyleHook: function(fn) {
                    TextRenderer._styleHooks.push(fn)
                }
            }),
            kity.extendClass(MinderNode, {
                getTextGroup: function() {
                    return this.getRenderer("TextRenderer").getRenderShape()
                }
            }),
            Module.register("text", {
                commands: {
                    text: TextCommand
                },
                renderers: {
                    center: TextRenderer
                }
            }),
            module.exports = TextRenderer
        }
    },
    _p[61] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Command = (_p.r(33),
            _p.r(19),
            _p.r(21),
            _p.r(9))
              , Module = _p.r(20)
              , ViewDragger = (_p.r(27),
            kity.createClass("ViewDragger", {
                constructor: function(minder) {
                    this._minder = minder,
                    this._enabled = !1,
                    this._bind();
                    var me = this;
                    this._minder.getViewDragger = function() {
                        return me
                    }
                    ,
                    this.setEnabled(!1)
                },
                isEnabled: function() {
                    return this._enabled
                },
                setEnabled: function(value) {
                    var paper = this._minder.getPaper();
                    paper.setStyle("cursor", value ? "pointer" : "default"),
                    paper.setStyle("cursor", value ? "-webkit-grab" : "default"),
                    this._enabled = value
                },
                timeline: function() {
                    return this._moveTimeline
                },
                move: function(offset, duration) {
                    var targetPosition = (this._minder,
                    this.getMovement().offset(offset));
                    this.moveTo(targetPosition, duration)
                },
                moveTo: function(position, duration) {
                    if (duration) {
                        var dragger = this;
                        return this._moveTimeline && this._moveTimeline.stop(),
                        this._moveTimeline = this._minder.getRenderContainer().animate(new kity.Animator(this.getMovement(),position,function(target, value) {
                            dragger.moveTo(value)
                        }
                        ), duration, "easeOutCubic").timeline(),
                        this._moveTimeline.on("finish", function() {
                            dragger._moveTimeline = null
                        }),
                        this
                    }
                    this._minder.getRenderContainer().setTranslate(position.round()),
                    this._minder.fire("viewchange")
                },
                getMovement: function() {
                    var translate = this._minder.getRenderContainer().transform.translate;
                    return translate ? translate[0] : new kity.Point
                },
                getView: function() {
                    var minder = this._minder
                      , c = minder._lastClientSize || {
                        width: minder.getRenderTarget().clientWidth,
                        height: minder.getRenderTarget().clientHeight
                    }
                      , m = this.getMovement()
                      , box = new kity.Box(0,0,c.width,c.height);
                    return minder.getPaper().getViewPortMatrix().inverse().translate(-m.x, -m.y).transformBox(box)
                },
                _bind: function() {
                    function dragEnd(e) {
                        if (lastPosition) {
                            lastPosition = null,
                            e.stopPropagation(),
                            isTempDrag && (dragger.setEnabled(!1),
                            isTempDrag = !1,
                            "hand" == dragger._minder.getStatus() && dragger._minder.rollbackStatus());
                            dragger._minder.getPaper().setStyle("cursor", "hand" == dragger._minder.getStatus() ? "-webkit-grab" : "default"),
                            dragger._minder.fire("viewchanged")
                        }
                    }
                    var dragger = this
                      , isTempDrag = !1
                      , lastPosition = null
                      , currentPosition = null;
                    this._minder.on("normal.mousedown normal.touchstart inputready.mousedown inputready.touchstart readonly.mousedown readonly.touchstart", function(e) {
                        2 == e.originEvent.button && e.originEvent.preventDefault(),
                        (e.getTargetNode() == this.getRoot() || 2 == e.originEvent.button || e.originEvent.altKey) && (lastPosition = e.getPosition("view"),
                        isTempDrag = !0)
                    }).on("normal.mousemove normal.touchmove readonly.mousemove readonly.touchmove inputready.mousemove inputready.touchmove", function(e) {
                        if ("touchmove" == e.type && e.preventDefault(),
                        isTempDrag) {
                            if (kity.Vector.fromPoints(lastPosition, e.getPosition("view")).length() > 10) {
                                this.setStatus("hand", !0);
                                dragger._minder.getPaper().setStyle("cursor", "-webkit-grabbing")
                            }
                        }
                    }).on("hand.beforemousedown hand.beforetouchstart", function(e) {
                        if (dragger.isEnabled()) {
                            lastPosition = e.getPosition("view"),
                            e.stopPropagation();
                            dragger._minder.getPaper().setStyle("cursor", "-webkit-grabbing")
                        }
                    }).on("hand.beforemousemove hand.beforetouchmove", function(e) {
                        if (lastPosition) {
                            currentPosition = e.getPosition("view");
                            var offset = kity.Vector.fromPoints(lastPosition, currentPosition);
                            dragger.move(offset),
                            e.stopPropagation(),
                            e.preventDefault(),
                            e.originEvent.preventDefault(),
                            lastPosition = currentPosition
                        }
                    }).on("mouseup touchend", dragEnd),
                    window.addEventListener("mouseup", dragEnd),
                    this._minder.on("contextmenu", function(e) {
                        e.preventDefault()
                    })
                }
            }));
            Module.register("View", function() {
                var ToggleHandCommand = kity.createClass("ToggleHandCommand", {
                    base: Command,
                    execute: function(minder) {
                        "hand" != minder.getStatus() ? minder.setStatus("hand", !0) : minder.rollbackStatus(),
                        this.setContentChanged(!1)
                    },
                    queryState: function(minder) {
                        return "hand" == minder.getStatus() ? 1 : 0
                    },
                    enableReadOnly: !0
                })
                  , CameraCommand = kity.createClass("CameraCommand", {
                    base: Command,
                    execute: function(km, focusNode) {
                        focusNode = focusNode || km.getRoot();
                        var viewport = km.getPaper().getViewPort()
                          , offset = focusNode.getRenderContainer().getRenderBox("view")
                          , dx = viewport.center.x - offset.x - offset.width / 2
                          , dy = viewport.center.y - offset.y
                          , dragger = km._viewDragger
                          , duration = km.getOption("viewAnimationDuration");
                        dragger.move(new kity.Point(dx,dy), duration),
                        this.setContentChanged(!1)
                    },
                    enableReadOnly: !0
                })
                  , MoveCommand = kity.createClass("MoveCommand", {
                    base: Command,
                    execute: function(km, dir) {
                        var dragger = km._viewDragger
                          , size = km._lastClientSize
                          , duration = km.getOption("viewAnimationDuration");
                        switch (dir) {
                        case "up":
                            dragger.move(new kity.Point(0,size.height / 2), duration);
                            break;
                        case "down":
                            dragger.move(new kity.Point(0,-size.height / 2), duration);
                            break;
                        case "left":
                            dragger.move(new kity.Point(size.width / 2,0), duration);
                            break;
                        case "right":
                            dragger.move(new kity.Point(-size.width / 2,0), duration)
                        }
                    },
                    enableReadOnly: !0
                });
                return {
                    init: function() {
                        this._viewDragger = new ViewDragger(this)
                    },
                    commands: {
                        hand: ToggleHandCommand,
                        camera: CameraCommand,
                        move: MoveCommand
                    },
                    events: {
                        statuschange: function(e) {
                            this._viewDragger.setEnabled("hand" == e.currentStatus)
                        },
                        mousewheel: function(e) {
                            var dx, dy;
                            if (e = e.originEvent,
                            !e.ctrlKey && !e.shiftKey) {
                                "wheelDeltaX"in e ? (dx = e.wheelDeltaX || 0,
                                dy = e.wheelDeltaY || 0) : (dx = 0,
                                dy = e.wheelDelta),
                                this._viewDragger.move({
                                    x: dx / 2.5,
                                    y: dy / 2.5
                                });
                                var me = this;
                                clearTimeout(this._mousewheeltimer),
                                this._mousewheeltimer = setTimeout(function() {
                                    me.fire("viewchanged")
                                }, 100),
                                e.preventDefault()
                            }
                        },
                        "normal.dblclick readonly.dblclick": function(e) {
                            e.kityEvent.targetShape instanceof kity.Paper && this.execCommand("camera", this.getRoot(), 800)
                        },
                        "paperrender finishInitHook": function() {
                            this.getRenderTarget() && (this.execCommand("camera", null, 0),
                            this._lastClientSize = {
                                width: this.getRenderTarget().clientWidth,
                                height: this.getRenderTarget().clientHeight
                            })
                        },
                        resize: function(e) {
                            var a = {
                                width: this.getRenderTarget().clientWidth,
                                height: this.getRenderTarget().clientHeight
                            }
                              , b = this._lastClientSize;
                            this._viewDragger.move(new kity.Point((a.width - b.width) / 2 | 0,(a.height - b.height) / 2 | 0)),
                            this._lastClientSize = a
                        },
                        "selectionchange layoutallfinish": function(e) {
                            var selected = this.getSelectedNode()
                              , minder = this;
                            if (kity.Browser.edge && this.fire("paperrender"),
                            selected) {
                                var dragger = this._viewDragger
                                  , timeline = dragger.timeline();
                                if (timeline)
                                    return void timeline.on("finish", function() {
                                        minder.fire("selectionchange")
                                    });
                                var view = dragger.getView()
                                  , focus = selected.getLayoutBox()
                                  , dx = 0
                                  , dy = 0;
                                focus.right > view.right ? dx += view.right - focus.right - 50 : focus.left < view.left && (dx += view.left - focus.left + 50),
                                focus.bottom > view.bottom && (dy += view.bottom - focus.bottom - 50),
                                focus.top < view.top && (dy += view.top - focus.top + 50),
                                (dx || dy) && dragger.move(new kity.Point(dx,dy), 100)
                            }
                        }
                    }
                }
            })
        }
    },
    _p[62] = {
        value: function(require, exports, module) {
            var kity = _p.r(17)
              , Minder = (_p.r(33),
            _p.r(19))
              , Command = (_p.r(21),
            _p.r(9))
              , Module = _p.r(20);
            _p.r(27);
            Module.register("Zoom", function() {
                function setTextRendering() {
                    var value = me._zoomValue >= 100 ? "optimize-speed" : "geometricPrecision";
                    me.getRenderContainer().setAttr("text-rendering", value)
                }
                function fixPaperCTM(paper) {
                    var node = paper.shapeNode
                      , ctm = node.getCTM()
                      , matrix = new kity.Matrix(ctm.a,ctm.b,ctm.c,ctm.d,.5 + (0 | ctm.e),.5 + (0 | ctm.f));
                    node.setAttribute("transform", "matrix(" + matrix.toString() + ")")
                }
                function zoomMinder(minder, value) {
                    var paper = minder.getPaper();
                    paper.getViewPort();
                    if (value) {
                        setTextRendering();
                        var duration = minder.getOption("zoomAnimationDuration");
                        if (minder.getRoot().getComplex() > 200 || !duration)
                            minder._zoomValue = value,
                            minder.zoom(value),
                            minder.fire("viewchange");
                        else {
                            var animator = new kity.Animator({
                                beginValue: minder._zoomValue,
                                finishValue: value,
                                setter: function(target, value) {
                                    target.zoom(value)
                                }
                            });
                            minder._zoomValue = value,
                            timeline && timeline.pause(),
                            timeline = animator.start(minder, duration, "easeInOutSine"),
                            timeline.on("finish", function() {
                                minder.fire("viewchange")
                            })
                        }
                        minder.fire("zoom", {
                            zoom: value
                        })
                    }
                }
                var timeline, me = this;
                kity.extendClass(Minder, {
                    zoom: function(value) {
                        var paper = this.getPaper()
                          , viewport = paper.getViewPort();
                        viewport.zoom = value / 100,
                        viewport.center = {
                            x: viewport.center.x,
                            y: viewport.center.y
                        },
                        paper.setViewPort(viewport),
                        100 == value && fixPaperCTM(paper)
                    },
                    getZoomValue: function() {
                        return this._zoomValue
                    }
                });
                var ZoomCommand = kity.createClass("Zoom", {
                    base: Command,
                    execute: zoomMinder,
                    queryValue: function(minder) {
                        return minder._zoomValue
                    }
                })
                  , ZoomInCommand = kity.createClass("ZoomInCommand", {
                    base: Command,
                    execute: function(minder) {
                        zoomMinder(minder, this.nextValue(minder))
                    },
                    queryState: function(minder) {
                        return +!this.nextValue(minder)
                    },
                    nextValue: function(minder) {
                        var i, stack = minder.getOption("zoom");
                        for (i = 0; i < stack.length; i++)
                            if (stack[i] > minder._zoomValue)
                                return stack[i];
                        return 0
                    },
                    enableReadOnly: !0
                })
                  , ZoomOutCommand = kity.createClass("ZoomOutCommand", {
                    base: Command,
                    execute: function(minder) {
                        zoomMinder(minder, this.nextValue(minder))
                    },
                    queryState: function(minder) {
                        return +!this.nextValue(minder)
                    },
                    nextValue: function(minder) {
                        var i, stack = minder.getOption("zoom");
                        for (i = stack.length - 1; i >= 0; i--)
                            if (stack[i] < minder._zoomValue)
                                return stack[i];
                        return 0
                    },
                    enableReadOnly: !0
                });
                return {
                    init: function() {
                        this._zoomValue = 100,
                        this.setDefaultOptions({
                            zoom: [10, 20, 50, 100, 200]
                        }),
                        setTextRendering()
                    },
                    commands: {
                        zoomin: ZoomInCommand,
                        zoomout: ZoomOutCommand,
                        zoom: ZoomCommand
                    },
                    events: {
                        "normal.mousewheel readonly.mousewheel": function(e) {
                            if (e.originEvent.ctrlKey || e.originEvent.metaKey) {
                                var delta = e.originEvent.wheelDelta
                                  , me = this;
                                kity.Browser.mac || (delta = -delta),
                                Math.abs(delta) > 100 && (clearTimeout(this._wheelZoomTimeout),
                                this._wheelZoomTimeout = setTimeout(function() {
                                    me.getPaper()._zoom;
                                    delta < 0 ? me.execCommand("zoom-in") : delta > 0 && me.execCommand("zoom-out")
                                }, 100),
                                e.originEvent.preventDefault())
                            }
                        }
                    },
                    commandShortcutKeys: {
                        zoomin: "ctrl+=",
                        zoomout: "ctrl+-"
                    }
                }
            })
        }
    },
    _p[63] = {
        value: function(require, exports, module) {
            _p.r(12).registerProtocol("json", module.exports = {
                fileDescription: "KityMinder 格式",
                fileExtension: ".km",
                dataType: "text",
                mineType: "application/json",
                encode: function(json) {
                    return JSON.stringify(json)
                },
                decode: function(local) {
                    return JSON.parse(local)
                }
            })
        }
    },
    _p[64] = {
        value: function(require, exports, module) {
            function encode(json) {
                return _build(json, 1).join("\n")
            }
            function _build(node, level) {
                var lines = [];
                level = level || 1;
                var sharps = _generateHeaderSharp(level);
                lines.push(sharps + " " + node.data.text),
                lines.push(EMPTY_LINE);
                var note = node.data.note;
                if (note) {
                    var hasSharp = /^#/.test(note);
                    hasSharp && (lines.push(NOTE_MARK_START),
                    note = note.replace(/^#+/gm, function($0) {
                        return sharps + $0
                    })),
                    lines.push(note),
                    hasSharp && lines.push(NOTE_MARK_CLOSE),
                    lines.push(EMPTY_LINE)
                }
                return node.children && node.children.forEach(function(child) {
                    lines = lines.concat(_build(child, level + 1))
                }),
                lines
            }
            function _generateHeaderSharp(level) {
                for (var sharps = ""; level--; )
                    sharps += "#";
                return sharps
            }
            function decode(markdown) {
                var lines, line, lineInfo, level, node, noteProgress, codeBlock, parentMap = {};
                markdown = markdown.replace(/^(.+)\n={3,}/, function($0, $1) {
                    return "# " + $1
                }),
                lines = markdown.split(LINE_ENDING_SPLITER);
                for (var i = 0; i < lines.length; i++)
                    line = lines[i],
                    lineInfo = _resolveLine(line),
                    lineInfo.noteClose ? noteProgress = !1 : lineInfo.noteStart ? noteProgress = !0 : (codeBlock = lineInfo.codeBlock ? !codeBlock : codeBlock,
                    noteProgress || codeBlock || !lineInfo.level || lineInfo.level > level + 1 ? node && _pushNote(node, line) : (level = lineInfo.level,
                    node = _initNode(lineInfo.content, parentMap[level - 1]),
                    parentMap[level] = node));
                return _cleanUp(parentMap[1]),
                parentMap[1]
            }
            function _initNode(text, parent) {
                var node = {
                    data: {
                        text: text,
                        note: ""
                    }
                };
                return parent && (parent.children ? parent.children.push(node) : parent.children = [node]),
                node
            }
            function _pushNote(node, line) {
                node.data.note += line + "\n"
            }
            function _resolveLine(line) {
                var match = /^(#+)?\s*(.*)$/.exec(line);
                return {
                    level: match[1] && match[1].length || null,
                    content: match[2],
                    noteStart: line == NOTE_MARK_START,
                    noteClose: line == NOTE_MARK_CLOSE,
                    codeBlock: /^\s*```/.test(line)
                }
            }
            function _cleanUp(node) {
                if (/\S/.test(node.data.note)) {
                    for (var notes = node.data.note.split("\n"); notes.length && !/\S/.test(notes[0]); )
                        notes.shift();
                    for (; notes.length && !/\S/.test(notes[notes.length - 1]); )
                        notes.pop();
                    node.data.note = notes.join("\n")
                } else
                    node.data.note = null,
                    delete node.data.note;
                node.children && node.children.forEach(_cleanUp)
            }
            var data = _p.r(12)
              , LINE_ENDING_SPLITER = /\r\n|\r|\n/
              , EMPTY_LINE = ""
              , NOTE_MARK_START = "\x3c!--Note--\x3e"
              , NOTE_MARK_CLOSE = "\x3c!--/Note--\x3e";
            data.registerProtocol("markdown", module.exports = {
                fileDescription: "Markdown/GFM 格式",
                fileExtension: ".md",
                mineType: "text/markdown",
                dataType: "text",
                encode: function(json) {
                    return encode(json.root)
                },
                decode: function(markdown) {
                    return decode(markdown)
                }
            })
        }
    },
    _p[65] = {
        value: function(require, exports, module) {
            function loadImage(info, callback) {
                return new Promise(function(resolve, reject) {
                    var image = document.createElement("img");
                    image.onload = function() {
                        resolve({
                            element: this,
                            x: info.x,
                            y: info.y,
                            width: info.width,
                            height: info.height
                        })
                    }
                    ,
                    image.onerror = function(err) {
                        reject(err)
                    }
                    ,
                    image.crossOrigin = "anonymous",
                    image.src = info.url
                }
                )
            }
            function xhrLoadImage(info, callback) {
                return Promise(function(resolve, reject) {
                    var xmlHttp = new XMLHttpRequest;
                    xmlHttp.open("GET", info.url + "?_=" + Date.now(), !0),
                    xmlHttp.responseType = "blob",
                    xmlHttp.onreadystatechange = function() {
                        if (4 === xmlHttp.readyState && 200 === xmlHttp.status) {
                            var blob = xmlHttp.response
                              , image = document.createElement("img");
                            image.src = DomURL.createObjectURL(blob),
                            image.onload = function() {
                                DomURL.revokeObjectURL(image.src),
                                resolve({
                                    element: image,
                                    x: info.x,
                                    y: info.y,
                                    width: info.width,
                                    height: info.height
                                })
                            }
                        }
                    }
                    ,
                    xmlHttp.send()
                })
            }
            function getSVGInfo(minder) {
                var paperTransform, svgXml, svgContainer, svgDom, blob, svgUrl, paper = minder.getPaper(), renderContainer = (paper.container,
                minder.getRenderContainer()), renderBox = renderContainer.getRenderBox(), width = renderBox.width + 1, height = renderBox.height + 1;
                paperTransform = paper.shapeNode.getAttribute("transform"),
                paper.shapeNode.setAttribute("transform", "translate(0.5, 0.5)"),
                renderContainer.translate(-renderBox.x, -renderBox.y),
                svgXml = paper.container.innerHTML,
                renderContainer.translate(renderBox.x, renderBox.y),
                paper.shapeNode.setAttribute("transform", paperTransform),
                svgContainer = document.createElement("div"),
                svgContainer.innerHTML = svgXml,
                svgDom = svgContainer.querySelector("svg"),
                svgDom.setAttribute("width", renderBox.width + 1),
                svgDom.setAttribute("height", renderBox.height + 1),
                svgDom.setAttribute("style", 'font-family: Arial, "Microsoft Yahei","Heiti SC";'),
                svgContainer = document.createElement("div"),
                svgContainer.appendChild(svgDom),
                svgXml = svgContainer.innerHTML,
                svgXml = svgXml.replace(' xmlns="http://www.w3.org/2000/svg" xmlns:NS1="" NS1:ns1:xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:NS2="" NS2:xmlns:ns1=""', ""),
                svgXml = svgXml.replace(/&nbsp;/g, "&#xa0;"),
                svgXml = svgXml.replace(/NS\d+:title/gi, "xlink:title"),
                blob = new Blob([svgXml],{
                    type: "image/svg+xml"
                }),
                svgUrl = DomURL.createObjectURL(blob);
                for (var allNodes = minder.getAllNode(), imagesInfo = [], i = 0; i < allNodes.length; i++) {
                    var nodeData = allNodes[i].data;
                    if (nodeData.image) {
                        minder.renderNode(allNodes[i]);
                        var imageUrl = nodeData.image
                          , imageSize = nodeData.imageSize
                          , imageRenderBox = allNodes[i].getRenderBox("ImageRenderer", minder.getRenderContainer())
                          , imageInfo = {
                            url: imageUrl,
                            width: imageSize.width,
                            height: imageSize.height,
                            x: -renderContainer.getBoundaryBox().x + imageRenderBox.x,
                            y: -renderContainer.getBoundaryBox().y + imageRenderBox.y
                        };
                        imagesInfo.push(imageInfo)
                    }
                }
                return {
                    width: width,
                    height: height,
                    dataUrl: svgUrl,
                    xml: svgXml,
                    imagesInfo: imagesInfo
                }
            }
            function encode(json, minder, option) {
                function fillBackground(ctx, style) {
                    ctx.save(),
                    ctx.fillStyle = style,
                    ctx.fillRect(0, 0, canvas.width, canvas.height),
                    ctx.restore()
                }
                function drawImage(ctx, image, x, y, width, height) {
                    width && height ? ctx.drawImage(image, x + padding, y + padding, width, height) : ctx.drawImage(image, x + padding, y + padding)
                }
                function generateDataUrl(canvas) {
                    return canvas.toDataURL("image/png")
                }
                function loadImages(imagesInfo) {
                    var imagePromises = imagesInfo.map(function(imageInfo) {
                        return xhrLoadImage(imageInfo)
                    });
                    return Promise.all(imagePromises)
                }
                function drawSVG() {
                    return loadImage({
                        url: svgDataUrl
                    }).then(function($image) {
                        return drawImage(ctx, $image.element, offsetX, offsetY, $image.width, $image.height),
                        loadImages(imagesInfo)
                    }).then(function($images) {
                        for (var i = 0; i < $images.length; i++)
                            drawImage(ctx, $images[i].element, $images[i].x + offsetX, $images[i].y + offsetY, $images[i].width, $images[i].height);
                        return DomURL.revokeObjectURL(svgDataUrl),
                        document.body.appendChild(canvas),
                        generateDataUrl(canvas)
                    }, function(err) {
                        return alert("脑图的节点中包含跨域图片，导出的 png 中节点图片不显示，你可以替换掉这些跨域的图片并重试。"),
                        DomURL.revokeObjectURL(svgDataUrl),
                        document.body.appendChild(canvas),
                        generateDataUrl(canvas)
                    })
                }
                var canvas = document.createElement("canvas")
                  , ctx = canvas.getContext("2d")
                  , bgDeclare = minder.getStyle("background").toString()
                  , bgUrl = /url\(\"(.+)\"\)/.exec(bgDeclare)
                  , bgColor = kity.Color.parse(bgDeclare)
                  , svgInfo = getSVGInfo(minder)
                  , width = option && option.width && option.width > svgInfo.width ? option.width : svgInfo.width
                  , height = option && option.height && option.height > svgInfo.height ? option.height : svgInfo.height
                  , offsetX = option && option.width && option.width > svgInfo.width ? (option.width - svgInfo.width) / 2 : 0
                  , offsetY = option && option.height && option.height > svgInfo.height ? (option.height - svgInfo.height) / 2 : 0
                  , svgDataUrl = svgInfo.dataUrl
                  , imagesInfo = svgInfo.imagesInfo
                  , padding = 20;
                if (canvas.width = width + 2 * padding,
                canvas.height = height + 2 * padding,
                bgUrl) {
                    return loadImage({
                        url: bgUrl[1]
                    }).then(function($image) {
                        return fillBackground(ctx, ctx.createPattern($image.element, "repeat")),
                        drawSVG()
                    })
                }
                return fillBackground(ctx, bgColor.toString()),
                drawSVG()
            }
            var kity = _p.r(17)
              , data = _p.r(12)
              , Promise = _p.r(25)
              , DomURL = window.URL || window.webkitURL || window;
            data.registerProtocol("png", module.exports = {
                fileDescription: "PNG 图片",
                fileExtension: ".png",
                mineType: "image/png",
                dataType: "base64",
                encode: encode
            })
        }
    },
    _p[66] = {
        value: function(require, exports, module) {
            function cleanSVG(svgDom, x, y) {
                function getTransformToElement(target, source) {
                    var matrix;
                    try {
                        matrix = source.getScreenCTM().inverse()
                    } catch (e) {
                        throw new Error("Can not inverse source element' ctm.")
                    }
                    return matrix.multiply(target.getScreenCTM())
                }
                function dealWithPath(d, dealWithPattern) {
                    dealWithPattern instanceof Function || (dealWithPattern = function() {}
                    );
                    for (var strArr = [], pattern = [], cache = [], i = 0, l = d.length; i < l; i++)
                        switch (d[i]) {
                        case "M":
                        case "L":
                        case "T":
                        case "S":
                        case "A":
                        case "C":
                        case "H":
                        case "V":
                        case "Q":
                            cache.length && (pattern.push(cache.join("")),
                            cache = []),
                            "," === pattern[pattern.length - 1] && pattern.pop(),
                            pattern.length && (dealWithPattern(pattern),
                            strArr.push(pattern.join("")),
                            pattern = []),
                            pattern.push(d[i]);
                            break;
                        case "Z":
                        case "z":
                            pattern.push(cache.join(""), d[i]),
                            dealWithPattern(pattern),
                            strArr.push(pattern.join("")),
                            cache = [],
                            pattern = [];
                            break;
                        case ".":
                        case "e":
                            cache.push(d[i]);
                            break;
                        case "-":
                            "e" !== d[i - 1] && (cache.length && pattern.push(cache.join(""), ","),
                            cache = []),
                            cache.push("-");
                            break;
                        case " ":
                        case ",":
                            cache.length && (pattern.push(cache.join(""), ","),
                            cache = []);
                            break;
                        default:
                            /\d/.test(d[i]) ? cache.push(d[i]) : cache.length ? (pattern.push(cache.join(""), d[i]),
                            cache = []) : ("," === pattern[pattern.length - 1] && pattern.pop(),
                            pattern.push(d[i])),
                            i + 1 === l && (cache.length && pattern.push(cache.join("")),
                            dealWithPattern(pattern),
                            strArr.push(pattern.join("")),
                            cache = null,
                            pattern = null)
                        }
                    return strArr.join("")
                }
                function replaceWithNode(svgNode, parentX, parentY) {
                    if (svgNode && "defs" !== svgNode.tagName) {
                        if ("transparent" === svgNode.getAttribute("fill") && svgNode.setAttribute("fill", "none"),
                        svgNode.getAttribute("marker-end") && svgNode.removeAttribute("marker-end"),
                        parentX = parentX || 0,
                        parentY = parentY || 0,
                        svgNode.getAttribute("transform")) {
                            var ctm = getTransformToElement(svgNode, svgNode.parentElement);
                            parentX -= ctm.e,
                            parentY -= ctm.f,
                            svgNode.removeAttribute("transform")
                        }
                        switch (svgNode.tagName.toLowerCase()) {
                        case "g":
                            break;
                        case "path":
                            var d = svgNode.getAttribute("d");
                            return void (d && (d = dealWithPath(d, function(pattern) {
                                switch (pattern[0]) {
                                case "V":
                                    pattern[1] = +pattern[1] - parentY;
                                    break;
                                case "H":
                                    pattern[1] = +pattern[1] - parentX;
                                    break;
                                case "M":
                                case "L":
                                case "T":
                                    pattern[1] = +pattern[1] - parentX,
                                    pattern[3] = +pattern[3] - parentY;
                                    break;
                                case "Q":
                                case "S":
                                    pattern[1] = +pattern[1] - parentX,
                                    pattern[3] = +pattern[3] - parentY,
                                    pattern[5] = +pattern[5] - parentX,
                                    pattern[7] = +pattern[7] - parentY;
                                    break;
                                case "A":
                                    pattern[11] = +pattern[11] - parentX,
                                    pattern[13] = +pattern[13] - parentY;
                                    break;
                                case "C":
                                    pattern[1] = +pattern[1] - parentX,
                                    pattern[3] = +pattern[3] - parentY,
                                    pattern[5] = +pattern[5] - parentX,
                                    pattern[7] = +pattern[7] - parentY,
                                    pattern[9] = +pattern[9] - parentX,
                                    pattern[11] = +pattern[11] - parentY
                                }
                            }),
                            svgNode.setAttribute("d", d),
                            svgNode.removeAttribute("transform")));
                        case "image":
                        case "text":
                            if (parentX && parentY) {
                                var x = +svgNode.getAttribute("x") || 0
                                  , y = +svgNode.getAttribute("y") || 0;
                                svgNode.setAttribute("x", x - parentX),
                                svgNode.setAttribute("y", y - parentY)
                            }
                            return svgNode.getAttribute("dominant-baseline") && (svgNode.removeAttribute("dominant-baseline"),
                            svgNode.setAttribute("dy", ".8em")),
                            void svgNode.removeAttribute("transform")
                        }
                        if (svgNode.children)
                            for (var i = 0, l = svgNode.children.length; i < l; i++)
                                replaceWithNode(svgNode.children[i], parentX, parentY)
                    }
                }
                svgDom.style.visibility = "hidden",
                replaceWithNode(svgDom, x || 0, y || 0),
                svgDom.style.visibility = "visible"
            }
            _p.r(12).registerProtocol("svg", module.exports = {
                fileDescription: "SVG 矢量图",
                fileExtension: ".svg",
                mineType: "image/svg+xml",
                dataType: "text",
                encode: function(json, minder) {
                    var svgXml, svgContainer, svgDom, paper = minder.getPaper(), paperTransform = paper.shapeNode.getAttribute("transform"), renderContainer = minder.getRenderContainer(), renderBox = renderContainer.getRenderBox(), width = (renderContainer.getTransform(),
                    renderBox.width), height = renderBox.height;
                    return paper.shapeNode.setAttribute("transform", "translate(0.5, 0.5)"),
                    svgXml = paper.container.innerHTML,
                    paper.shapeNode.setAttribute("transform", paperTransform),
                    svgContainer = document.createElement("div"),
                    document.body.appendChild(svgContainer),
                    svgContainer.innerHTML = svgXml,
                    svgDom = svgContainer.querySelector("svg"),
                    svgDom.setAttribute("width", width + 40 | 0),
                    svgDom.setAttribute("height", height + 40 | 0),
                    svgDom.setAttribute("style", "background: " + minder.getStyle("background")),
                    svgDom.setAttribute("viewBox", [0, 0, width + 40 | 0, height + 40 | 0].join(" ")),
                    tempSvgContainer = document.createElement("div"),
                    cleanSVG(svgDom, renderBox.x - 20 | 0, renderBox.y - 20 | 0),
                    document.body.removeChild(svgContainer),
                    tempSvgContainer.appendChild(svgDom),
                    svgXml = tempSvgContainer.innerHTML,
                    svgXml = svgXml.replace(/&nbsp;/g, "&#xa0;")
                }
            })
        }
    },
    _p[67] = {
        value: function(require, exports, module) {
            function repeat(s, n) {
                for (var result = ""; n--; )
                    result += s;
                return result
            }
            function encodeWrap(nodeText) {
                if (!nodeText)
                    return "";
                for (var textArr = [], WRAP_TEXT = ["\\", "n"], i = 0, j = 0, l = nodeText.length; i < l; i++)
                    if ("\n" !== nodeText[i] && "\r" !== nodeText[i])
                        if (nodeText[i] !== WRAP_TEXT[j]) {
                            switch (j) {
                            case 0:
                                textArr.push(nodeText[i]);
                                break;
                            case 1:
                                textArr.push(nodeText[i - 1], nodeText[i])
                            }
                            j = 0
                        } else
                            2 === ++j && (j = 0,
                            textArr.push("\\\\n"));
                    else
                        textArr.push("\\n"),
                        j = 0;
                return textArr.join("")
            }
            function decodeWrap(text) {
                if (!text)
                    return "";
                for (var textArr = [], WRAP_TEXT = ["\\", "\\", "n"], i = 0, j = 0, l = text.length; i < l; i++)
                    if (text[i] !== WRAP_TEXT[j])
                        switch (j) {
                        case 0:
                            textArr.push(text[i]),
                            j = 0;
                            break;
                        case 1:
                            "n" === text[i] ? textArr.push("\n") : textArr.push(text[i - 1], text[i]),
                            j = 0;
                            break;
                        case 2:
                            textArr.push(text[i - 2]),
                            "\\" !== text[i] && (j = 0,
                            textArr.push(text[i - 1], text[i]))
                        }
                    else
                        3 === ++j && (j = 0,
                        textArr.push("\\n"));
                return textArr.join("")
            }
            function encode(json, level) {
                var local = "";
                return level = level || 0,
                local += repeat("\t", level),
                local += encodeWrap(json.data.text) + LINE_ENDING,
                json.children && json.children.forEach(function(child) {
                    local += encode(child, level + 1)
                }),
                local
            }
            function isEmpty(line) {
                return !/\S/.test(line)
            }
            function getLevel(line) {
                for (var level = 0; TAB_CHAR.REGEXP.test(line); )
                    line = line.replace(TAB_CHAR.REGEXP, ""),
                    level++;
                return level
            }
            function getNode(line) {
                return {
                    data: {
                        text: decodeWrap(line.replace(TAB_CHAR.DELETE, ""))
                    }
                }
            }
            function decode(local) {
                for (var json, line, level, node, parentMap = {}, lines = local.split(LINE_ENDING_SPLITER), i = 0; i < lines.length; i++)
                    if (line = lines[i],
                    !isEmpty(line)) {
                        if (level = getLevel(line),
                        node = getNode(line),
                        0 === level) {
                            if (json)
                                throw new Error("Invalid local format");
                            json = node
                        } else {
                            if (!parentMap[level - 1])
                                throw new Error("Invalid local format");
                            !function(parent, child) {
                                (parent.children || (parent.children = [])).push(child)
                            }(parentMap[level - 1], node)
                        }
                        parentMap[level] = node
                    }
                return json
            }
            function Node2Text(node) {
                function exportNode(node) {
                    var exported = {};
                    exported.data = node.getData();
                    var childNodes = node.getChildren();
                    exported.children = [];
                    for (var i = 0; i < childNodes.length; i++)
                        exported.children.push(exportNode(childNodes[i]));
                    return exported
                }
                if (node)
                    return /^\s*$/.test(node.data.text) && (node.data.text = "分支主题"),
                    encode(exportNode(node))
            }
            var data = _p.r(12)
              , Browser = _p.r(17).Browser
              , LINE_ENDING = "\r"
              , LINE_ENDING_SPLITER = /\r\n|\r|\n/
              , TAB_CHAR = function(Browser) {
                return Browser.gecko ? {
                    REGEXP: new RegExp("^(\t|" + String.fromCharCode(160, 160, 32, 160) + ")"),
                    DELETE: new RegExp("^(\t|" + String.fromCharCode(160, 160, 32, 160) + ")+")
                } : Browser.ie || Browser.edge ? {
                    REGEXP: new RegExp("^(" + String.fromCharCode(32) + "|" + String.fromCharCode(160) + ")"),
                    DELETE: new RegExp("^(" + String.fromCharCode(32) + "|" + String.fromCharCode(160) + ")+")
                } : {
                    REGEXP: /^(\t|\x20{4})/,
                    DELETE: /^(\t|\x20{4})+/
                }
            }(Browser);
            data.registerProtocol("text", module.exports = {
                fileDescription: "大纲文本",
                fileExtension: ".txt",
                dataType: "text",
                mineType: "text/plain",
                encode: function(json) {
                    return encode(json.root, 0)
                },
                decode: function(local) {
                    return decode(local)
                },
                Node2Text: function(node) {
                    return Node2Text(node)
                }
            })
        }
    },
    _p[68] = {
        value: function(require, exports, module) {
            _p.r(31).register("default", {
                getLayout: function(node) {
                    if (node.getData("layout"))
                        return node.getData("layout");
                    var level = node.getLevel();
                    return 0 === level ? "mind" : 1 === level ? node.getLayoutPointPreview().x > 0 ? "right" : "left" : node.parent.getLayout()
                },
                getConnect: function(node) {
                    return 1 == node.getLevel() ? "arc" : "under"
                }
            })
        }
    },
    _p[69] = {
        value: function(require, exports, module) {
            _p.r(31).register("filetree", {
                getLayout: function(node) {
                    return node.getData("layout") ? node.getData("layout") : node.isRoot() ? "bottom" : "filetree-down"
                },
                getConnect: function(node) {
                    return 1 == node.getLevel() ? "poly" : "l"
                }
            })
        }
    },
    _p[70] = {
        value: function(require, exports, module) {
            _p.r(31).register("fish-bone", {
                getLayout: function(node) {
                    if (node.getData("layout"))
                        return node.getData("layout");
                    var level = node.getLevel();
                    return 0 === level ? "fish-bone-master" : 1 === level ? "fish-bone-slave" : node.getLayoutPointPreview().y > 0 ? "filetree-up" : "filetree-down"
                },
                getConnect: function(node) {
                    switch (node.getLevel()) {
                    case 1:
                        return "fish-bone-master";
                    case 2:
                        return "line";
                    default:
                        return "l"
                    }
                }
            })
        }
    },
    _p[71] = {
        value: function(require, exports, module) {
            _p.r(31).register("right", {
                getLayout: function(node) {
                    return node.getData("layout") || "right"
                },
                getConnect: function(node) {
                    return 1 == node.getLevel() ? "arc" : "bezier"
                }
            })
        }
    },
    _p[72] = {
        value: function(require, exports, module) {
            _p.r(31).register("structure", {
                getLayout: function(node) {
                    return node.getData("layout") || "bottom"
                },
                getConnect: function(node) {
                    return "poly"
                }
            })
        }
    },
    _p[73] = {
        value: function(require, exports, module) {
            _p.r(31).register("tianpan", {
                getLayout: function(node) {
                    return node.getData("layout") ? node.getData("layout") : 0 === node.getLevel() ? "tianpan" : node.parent.getLayout()
                },
                getConnect: function(node) {
                    return "arc_tp"
                }
            })
        }
    },
    _p[74] = {
        value: function(require, exports, module) {
            var theme = _p.r(32);
            ["classic", "classic-compact"].forEach(function(name) {
                var compact = "classic-compact" == name;
                theme.register(name, {
                    background: '#3A4144 url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQzg5QTQ0NDhENzgxMUUzOENGREE4QTg0RDgzRTZDNyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQzg5QTQ0NThENzgxMUUzOENGREE4QTg0RDgzRTZDNyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMwOEQ1NDRGOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMwOEQ1NDUwOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+e9P33AAAACVJREFUeNpisXJ0YUACTAyoAMr/+eM7EGGRZ4FQ7BycEAZAgAEAHbEGtkoQm/wAAAAASUVORK5CYII=") repeat',
                    "root-color": "#430",
                    "root-background": "#e9df98",
                    "root-stroke": "#e9df98",
                    "root-font-size": 24,
                    "root-padding": compact ? [10, 25] : [15, 25],
                    "root-margin": compact ? [15, 25] : [30, 100],
                    "root-radius": 30,
                    "root-space": 10,
                    "root-shadow": "rgba(0, 0, 0, .25)",
                    "main-color": "#333",
                    "main-background": "#a4c5c0",
                    "main-stroke": "#a4c5c0",
                    "main-font-size": 16,
                    "main-padding": compact ? [5, 15] : [6, 20],
                    "main-margin": compact ? [5, 10] : 20,
                    "main-radius": 10,
                    "main-space": 5,
                    "main-shadow": "rgba(0, 0, 0, .25)",
                    "sub-color": "white",
                    "sub-background": "transparent",
                    "sub-stroke": "none",
                    "sub-font-size": 12,
                    "sub-padding": [5, 10],
                    "sub-margin": compact ? [5, 10] : [15, 20],
                    "sub-tree-margin": 30,
                    "sub-radius": 5,
                    "sub-space": 5,
                    "connect-color": "white",
                    "connect-width": 2,
                    "main-connect-width": 3,
                    "connect-radius": 5,
                    "selected-background": "rgb(254, 219, 0)",
                    "selected-stroke": "rgb(254, 219, 0)",
                    "selected-color": "black",
                    "marquee-background": "rgba(255,255,255,.3)",
                    "marquee-stroke": "white",
                    "drop-hint-color": "yellow",
                    "sub-drop-hint-width": 2,
                    "main-drop-hint-width": 4,
                    "root-drop-hint-width": 4,
                    "order-hint-area-color": "rgba(0, 255, 0, .5)",
                    "order-hint-path-color": "#0f0",
                    "order-hint-path-width": 1,
                    "text-selection-color": "rgb(27,171,255)",
                    "line-height": 1.5
                })
            })
        }
    },
    _p[75] = {
        value: function(require, exports, module) {
            _p.r(32).register("fish", {
                background: '#3A4144 url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQzg5QTQ0NDhENzgxMUUzOENGREE4QTg0RDgzRTZDNyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQzg5QTQ0NThENzgxMUUzOENGREE4QTg0RDgzRTZDNyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMwOEQ1NDRGOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMwOEQ1NDUwOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+e9P33AAAACVJREFUeNpisXJ0YUACTAyoAMr/+eM7EGGRZ4FQ7BycEAZAgAEAHbEGtkoQm/wAAAAASUVORK5CYII=") repeat',
                "root-color": "#430",
                "root-background": "#e9df98",
                "root-stroke": "#e9df98",
                "root-font-size": 24,
                "root-padding": [35, 35],
                "root-margin": 30,
                "root-radius": 100,
                "root-space": 10,
                "root-shadow": "rgba(0, 0, 0, .25)",
                "main-color": "#333",
                "main-background": "#a4c5c0",
                "main-stroke": "#a4c5c0",
                "main-font-size": 16,
                "main-padding": [6, 20],
                "main-margin": [20, 20],
                "main-radius": 5,
                "main-space": 5,
                "main-shadow": "rgba(0, 0, 0, .25)",
                "sub-color": "black",
                "sub-background": "white",
                "sub-stroke": "white",
                "sub-font-size": 12,
                "sub-padding": [5, 10],
                "sub-margin": [10],
                "sub-radius": 5,
                "sub-space": 5,
                "connect-color": "white",
                "connect-width": 3,
                "main-connect-width": 3,
                "connect-radius": 5,
                "selected-background": "rgb(254, 219, 0)",
                "selected-stroke": "rgb(254, 219, 0)",
                "marquee-background": "rgba(255,255,255,.3)",
                "marquee-stroke": "white",
                "drop-hint-color": "yellow",
                "drop-hint-width": 4,
                "order-hint-area-color": "rgba(0, 255, 0, .5)",
                "order-hint-path-color": "#0f0",
                "order-hint-path-width": 1,
                "text-selection-color": "rgb(27,171,255)",
                "line-height": 1.5
            })
        }
    },
    _p[76] = {
        value: function(require, exports, module) {
            function hsl(h, s, l) {
                return kity.Color.createHSL(h, s, l)
            }
            function generate(h, compat) {
                return {
                    background: "#fbfbfb",
                    "root-color": "white",
                    "root-background": hsl(h, 37, 60),
                    "root-stroke": hsl(h, 37, 60),
                    "root-font-size": 16,
                    "root-padding": compat ? [6, 12] : [12, 24],
                    "root-margin": compat ? 10 : [30, 100],
                    "root-radius": 5,
                    "root-space": 10,
                    "main-color": "black",
                    "main-background": hsl(h, 33, 95),
                    "main-stroke": hsl(h, 37, 60),
                    "main-stroke-width": 1,
                    "main-font-size": 14,
                    "main-padding": [6, 20],
                    "main-margin": compat ? 8 : 20,
                    "main-radius": 3,
                    "main-space": 5,
                    "sub-color": "black",
                    "sub-background": "transparent",
                    "sub-stroke": "none",
                    "sub-font-size": 12,
                    "sub-padding": compat ? [3, 5] : [5, 10],
                    "sub-margin": compat ? [4, 8] : [15, 20],
                    "sub-radius": 5,
                    "sub-space": 5,
                    "connect-color": hsl(h, 37, 60),
                    "connect-width": 1,
                    "connect-radius": 5,
                    "selected-stroke": hsl(h, 26, 30),
                    "selected-stroke-width": "3",
                    "blur-selected-stroke": hsl(h, 10, 60),
                    "marquee-background": hsl(h, 100, 80).set("a", .1),
                    "marquee-stroke": hsl(h, 37, 60),
                    "drop-hint-color": hsl(h, 26, 35),
                    "drop-hint-width": 5,
                    "order-hint-area-color": hsl(h, 100, 30).set("a", .5),
                    "order-hint-path-color": hsl(h, 100, 25),
                    "order-hint-path-width": 1,
                    "text-selection-color": hsl(h, 100, 20),
                    "line-height": 1.5
                }
            }
            var name, kity = _p.r(17), theme = _p.r(32), plans = {
                red: 0,
                soil: 25,
                green: 122,
                blue: 204,
                purple: 246,
                pink: 334
            };
            for (name in plans)
                theme.register("fresh-" + name, generate(plans[name])),
                theme.register("fresh-" + name + "-compat", generate(plans[name], !0))
        }
    },
    _p[77] = {
        value: function(require, exports, module) {
            var theme = _p.r(32);
            ["snow", "snow-compact"].forEach(function(name) {
                var compact = "snow-compact" == name;
                theme.register(name, {
                    background: '#3A4144 url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQzg5QTQ0NDhENzgxMUUzOENGREE4QTg0RDgzRTZDNyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQzg5QTQ0NThENzgxMUUzOENGREE4QTg0RDgzRTZDNyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMwOEQ1NDRGOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMwOEQ1NDUwOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+e9P33AAAACVJREFUeNpisXJ0YUACTAyoAMr/+eM7EGGRZ4FQ7BycEAZAgAEAHbEGtkoQm/wAAAAASUVORK5CYII=") repeat',
                    "root-color": "#430",
                    "root-background": "#e9df98",
                    "root-stroke": "#e9df98",
                    "root-font-size": 24,
                    "root-padding": compact ? [5, 10] : [15, 25],
                    "root-margin": compact ? 15 : 30,
                    "root-radius": 5,
                    "root-space": 10,
                    "root-shadow": "rgba(0, 0, 0, .25)",
                    "main-color": "#333",
                    "main-background": "#a4c5c0",
                    "main-stroke": "#a4c5c0",
                    "main-font-size": 16,
                    "main-padding": compact ? [4, 10] : [6, 20],
                    "main-margin": compact ? [5, 10] : [20, 40],
                    "main-radius": 5,
                    "main-space": 5,
                    "main-shadow": "rgba(0, 0, 0, .25)",
                    "sub-color": "black",
                    "sub-background": "white",
                    "sub-stroke": "white",
                    "sub-font-size": 12,
                    "sub-padding": [5, 10],
                    "sub-margin": compact ? [5, 10] : [10, 20],
                    "sub-radius": 5,
                    "sub-space": 5,
                    "connect-color": "white",
                    "connect-width": 2,
                    "main-connect-width": 3,
                    "connect-radius": 5,
                    "selected-background": "rgb(254, 219, 0)",
                    "selected-stroke": "rgb(254, 219, 0)",
                    "marquee-background": "rgba(255,255,255,.3)",
                    "marquee-stroke": "white",
                    "drop-hint-color": "yellow",
                    "drop-hint-width": 4,
                    "order-hint-area-color": "rgba(0, 255, 0, .5)",
                    "order-hint-path-color": "#0f0",
                    "order-hint-path-width": 1,
                    "text-selection-color": "rgb(27,171,255)",
                    "line-height": 1.5
                })
            })
        }
    },
    _p[78] = {
        value: function(require, exports, module) {
            var theme = _p.r(32);
            ["tianpan", "tianpan-compact"].forEach(function(name) {
                var compact = "tianpan-compact" == name;
                theme.register(name, {
                    background: '#3A4144 url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowQzg5QTQ0NDhENzgxMUUzOENGREE4QTg0RDgzRTZDNyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowQzg5QTQ0NThENzgxMUUzOENGREE4QTg0RDgzRTZDNyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkMwOEQ1NDRGOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkMwOEQ1NDUwOEQ3NzExRTM4Q0ZEQThBODREODNFNkM3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+e9P33AAAACVJREFUeNpisXJ0YUACTAyoAMr/+eM7EGGRZ4FQ7BycEAZAgAEAHbEGtkoQm/wAAAAASUVORK5CYII=") repeat',
                    "root-color": "#430",
                    "root-background": "#e9df98",
                    "root-stroke": "#e9df98",
                    "root-font-size": 25,
                    "root-padding": compact ? 15 : 20,
                    "root-margin": compact ? [15, 25] : 100,
                    "root-radius": 30,
                    "root-space": 10,
                    "root-shadow": "rgba(0, 0, 0, .25)",
                    "root-shape": "circle",
                    "main-color": "#333",
                    "main-background": "#a4c5c0",
                    "main-stroke": "#a4c5c0",
                    "main-font-size": 15,
                    "main-padding": compact ? 10 : 12,
                    "main-margin": compact ? 10 : 12,
                    "main-radius": 10,
                    "main-space": 5,
                    "main-shadow": "rgba(0, 0, 0, .25)",
                    "main-shape": "circle",
                    "sub-color": "#333",
                    "sub-background": "#99ca6a",
                    "sub-stroke": "#a4c5c0",
                    "sub-font-size": 13,
                    "sub-padding": 5,
                    "sub-margin": compact ? 6 : 10,
                    "sub-tree-margin": 30,
                    "sub-radius": 5,
                    "sub-space": 5,
                    "sub-shadow": "rgba(0, 0, 0, .25)",
                    "sub-shape": "circle",
                    "connect-color": "white",
                    "connect-width": 2,
                    "main-connect-width": 3,
                    "connect-radius": 5,
                    "selected-background": "rgb(254, 219, 0)",
                    "selected-stroke": "rgb(254, 219, 0)",
                    "selected-color": "black",
                    "marquee-background": "rgba(255,255,255,.3)",
                    "marquee-stroke": "white",
                    "drop-hint-color": "yellow",
                    "sub-drop-hint-width": 2,
                    "main-drop-hint-width": 4,
                    "root-drop-hint-width": 4,
                    "order-hint-area-color": "rgba(0, 255, 0, .5)",
                    "order-hint-path-color": "#0f0",
                    "order-hint-path-width": 1,
                    "text-selection-color": "rgb(27,171,255)",
                    "line-height": 1.4
                })
            })
        }
    },
    _p[79] = {
        value: function(require, exports, module) {
            _p.r(32).register("wire", {
                background: "black",
                color: "#999",
                stroke: "none",
                padding: 10,
                margin: 20,
                "font-size": 14,
                "connect-color": "#999",
                "connect-width": 1,
                "selected-background": "#999",
                "selected-color": "black",
                "marquee-background": "rgba(255,255,255,.3)",
                "marquee-stroke": "white",
                "drop-hint-color": "yellow",
                "sub-drop-hint-width": 2,
                "main-drop-hint-width": 4,
                "root-drop-hint-width": 4,
                "order-hint-area-color": "rgba(0, 255, 0, .5)",
                "order-hint-path-color": "#0f0",
                "order-hint-path-width": 1,
                "text-selection-color": "rgb(27,171,255)",
                "line-height": 1.5
            })
        }
    };
    var moduleMapping = {
        "expose-kityminder": 34
    };
    !function(name) {
        _p.r([moduleMapping[name]])
    }("expose-kityminder")
}(),
angular.module("ui.colorpicker", []).directive("colorPicker", ["$compile", "localize", function($compile, localize) {
    return {
        restrict: "EA",
        scope: {
            setColor: "&"
        },
        link: function(scope, element, attrs) {
            function reCalculatePostion() {
                var newPostion = getColorpickerTemplatePosition(element);
                colorpickerTemplate.css(newPostion)
            }
            function isPickerEnable() {
                return !angular.isDefined(attrs.disabled) || !attrs.disabled
            }
            function selectColor(color) {
                scope.$emit("colorPicked", color),
                scope.hoveredColor = color,
                setLatestColor(color),
                scope.latestColor = getLatestColor()
            }
            function selectColorAndClose(color) {
                selectColor(color),
                closeColorPicker()
            }
            function previewColor(color) {
                scope.hoveredColor = color
            }
            function closeColorPicker() {
                colorpickerTemplate.css("display", "none")
            }
            function openColorPicker(e) {
                if (isPickerEnable()) {
                    e.stopPropagation();
                    var templatePostion = getColorpickerTemplatePosition(element);
                    colorpickerTemplate.css(templatePostion),
                    colorpickerTemplate.css("display", "block"),
                    colorpickerTemplate[0].focus()
                }
            }
            function keepPickerOpen(e) {
                e.stopPropagation()
            }
            function getUIMemory() {
                var uiMemory = window.localStorage.getItem("ui-color-picker");
                if (!uiMemory)
                    return null;
                try {
                    uiMemory = JSON.parse(uiMemory)
                } catch (e) {
                    return null
                }
                return uiMemory
            }
            function getLatestColor() {
                var uiMemory = getUIMemory();
                return uiMemory ? uiMemory.latestColor : []
            }
            function setLatestColor(color) {
                var uiMemory = getUIMemory() || {}
                  , latest = getLatestColor();
                if (latest && latest instanceof Array) {
                    var idx = latest.indexOf(color);
                    -1 != idx && latest.splice(idx, 1),
                    latest.unshift(color)
                } else
                    latest = [color];
                latest.length > 10 && (latest = latest.slice(0, 10)),
                uiMemory.latestColor = latest,
                window.localStorage.setItem("ui-color-picker", JSON.stringify(uiMemory))
            }
            function getOffset(elem, fixedPosition) {
                for (var x = 0, y = 0, scrollX = 0, scrollY = 0; elem && !isNaN(elem.offsetLeft) && !isNaN(elem.offsetTop); )
                    x += elem.offsetLeft,
                    y += elem.offsetTop,
                    fixedPosition || "BODY" !== elem.tagName ? (scrollX += elem.scrollLeft,
                    scrollY += elem.scrollTop) : (scrollX += document.documentElement.scrollLeft || elem.scrollLeft,
                    scrollY += document.documentElement.scrollTop || elem.scrollTop),
                    elem = elem.offsetParent;
                return {
                    top: y,
                    left: x,
                    scrollX: scrollX,
                    scrollY: scrollY
                }
            }
            function getColorpickerTemplatePosition(element) {
                var positionValue, positionOffset = getOffset(element[0]);
                return "top" === position ? positionValue = {
                    top: positionOffset.top - 147,
                    left: positionOffset.left
                } : "right" === position ? positionValue = {
                    top: positionOffset.top,
                    left: positionOffset.left + 126
                } : "bottom" === position ? positionValue = {
                    top: positionOffset.top + element[0].offsetHeight + 2,
                    left: positionOffset.left
                } : "left" === position && (positionValue = {
                    top: positionOffset.top,
                    left: positionOffset.left - 150
                }),
                {
                    top: positionValue.top + "px",
                    left: positionValue.left + "px"
                }
            }
            var defaultColor = scope.setColor() || attrs.defaultColor || "#fff"
              , defaultOptions = {
                clearText: localize.get("default_color"),
                defaultColor: defaultColor,
                latestText: localize.get("latest_used"),
                commonText: localize.get("theme_color"),
                commonColor: [["#ffffff", "#000000", "#eeece1", "#1f497d", "#4f81bd", "#c0504d", "#9bbb59", "#8064a2", "#4bacc6", "#f79646"], ["#f2f2f2", "#808080", "#ddd8c2", "#c6d9f1", "#dbe5f1", "#f2dbdb", "#eaf1dd", "#e5dfec", "#daeef3", "#fde9d9"], ["#d9d9d9", "#595959", "#c4bc96", "#8db3e2", "#b8cce4", "#e5b8b7", "#d6e3bc", "#ccc0d9", "#b6dde8", "#fbd4b4"], ["#bfbfbf", "#404040", "#938953", "#548dd4", "#95b3d7", "#d99594", "#c2d69b", "#b2a1c7", "#92cddc", "#fabf8f"], ["#a6a6a6", "#262626", "#4a442a", "#17365d", "#365f91", "#943634", "#76923c", "#5f497a", "#31849b", "#e36c0a"], ["#7f7f7f", "#0d0d0d", "#1c1a10", "#0f243e", "#243f60", "#622423", "#4e6128", "#3f3151", "#205867", "#974706"]],
                standardText: localize.get("standard_color"),
                standardColor: ["#c00000", "#ff0000", "#ffc000", "#ffff00", "#92d050", "#00b050", "#00b0f0", "#0070c0", "#002060", "#7030a0"],
                moreText: localize.get("more_color")
            }
              , pickerInputId = (1e6 * +new Date + Math.floor(1e6 * Math.random())).toString(36)
              , template = '<div class="colorpicker-container" tabindex="-1" ng-click="keepPickerOpen($event)"><div class="colorpicker-toolbar"><div class="colorpicker-preview" ng-style="{ \'background-color\': hoveredColor }"></div><div class="colorpicker-clear" ng-bind="defaultOptions.clearText" ng-click="selectColorAndClose(setColor() || defaultOptions.defaultColor)"></div></div><div class="colorpicker-title" ng-bind="defaultOptions.latestText" ng-if="latestColor.length > 0"></div><div class="colorpicker-latestcolor colorpicker-colors"><span class="colorpicker-colors-item" ng-repeat="color in latestColor" ng-style="{\'background-color\': color, \'border-color\': color}" ng-click="selectColorAndClose(color)" ng-mouseover="previewColor(color)" ng-mouseleave="previewColor(setColor() || defaultOptions.defaultColor)"></span></div><div class="colorpicker-title" ng-bind="defaultOptions.commonText"></div><div class="colorpicker-commoncolor"><div class="colorpicker-colors colorpicker-colors-line{{$index}}" ng-repeat="line in defaultOptions.commonColor"><span class="colorpicker-colors-item" ng-repeat="color in line" ng-style="{\'background-color\': color, \'border-color\': color}" ng-click="selectColorAndClose(color)" ng-mouseover="previewColor(color)" ng-mouseleave="previewColor(setColor() || defaultOptions.defaultColor)"></span></div></div><div class="colorpicker-title" ng-bind="defaultOptions.standardText"></div><div class="colorpicker-standardcolor colorpicker-colors"><span class="colorpicker-colors-item" ng-repeat="color in defaultOptions.standardColor" ng-style="{\'background-color\': color, \'border-color\': color}" ng-click="selectColorAndClose(color)" ng-mouseover="previewColor(color)" ng-mouseleave="previewColor(setColor() || defaultOptions.defaultColor)"></span></div><div class="colorpicker-title colorpicker-morecolor" ng-if="isSupportNativeColorPicker"><label for="native-color-picker' + pickerInputId + '" ng-bind="defaultOptions.moreText"></label><input id="native-color-picker' + pickerInputId + '" class="native-color-picker" type="color" ng-model="nativeColor" ng-change="selectColor(nativeColor);" /></div></div>'
              , $ = angular.element
              , colorpickerTemplate = $(template)
              , position = angular.isDefined(attrs.colorpickerPosition) ? attrs.colorpickerPosition : "bottom";
            scope.defaultOptions = defaultOptions,
            scope.isSupportNativeColorPicker = function() {
                var i = document.createElement("input");
                return i.setAttribute("type", "color"),
                "text" !== i.type
            }(),
            scope.latestColor = getLatestColor(),
            scope.selectColor = selectColor,
            scope.previewColor = previewColor,
            scope.selectColorAndClose = selectColorAndClose,
            scope.keepPickerOpen = keepPickerOpen,
            scope.hoveredColor = defaultOptions.defaultColor,
            $compile(colorpickerTemplate)(scope),
            $(document.body).append(colorpickerTemplate),
            element.on("click", openColorPicker),
            $(document).on("click", closeColorPicker),
            scope.$on("openColorPicker", openColorPicker),
            scope.$on("closeColorPicker", closeColorPicker),
            window.attachEvent ? window.attachEvent("onresize", reCalculatePostion) : window.addEventListener && window.addEventListener("resize", reCalculatePostion)
        }
    }
}
]),
angular.module("ui.colorpicker").provider("localize", function() {
    this.map = {
        "zh-cn": {
            default_color: "默认颜色",
            latest_used: "最近使用",
            theme_color: "主题颜色",
            standard_color: "标准颜色",
            more_color: "更多颜色.."
        },
        "en-us": {
            default_color: "default",
            latest_used: "latest used",
            theme_color: "theme color",
            standard_color: "standard color",
            more_color: "more.."
        }
    },
    this.defaultLang = "zh-cn",
    this.setDefaultLang = function(lang) {
        var supported = Object.keys(this.map);
        if (-1 === supported.indexOf(lang))
            return void console.error("Unsupported language: ", lang, ", please choose in :", supported.join(", "));
        this.defaultLang = lang
    }
    ,
    this.$get = function() {
        var me = this;
        return {
            get: function(key) {
                return me.map[me.defaultLang].hasOwnProperty(key) ? me.map[me.defaultLang][key] : (console.warn("Missing lang pair for : ", key),
                "")
            }
        }
    }
}),
function() {
    var _p = {
        r: function(index) {
            if (_p[index].inited)
                return _p[index].value;
            if ("function" != typeof _p[index].value)
                return _p[index].inited = !0,
                _p[index].value;
            var module = {
                exports: {}
            }
              , returnValue = _p[index].value(null, module.exports, module);
            if (_p[index].inited = !0,
            _p[index].value = returnValue,
            void 0 !== returnValue)
                return returnValue;
            for (var key in module.exports)
                if (module.exports.hasOwnProperty(key))
                    return _p[index].inited = !0,
                    _p[index].value = module.exports,
                    module.exports
        }
    };
    _p[0] = {
        value: function(require, exports, module) {
            function assemble(runtime) {
                runtimes.push(runtime)
            }
            function KMEditor(selector) {
                this.selector = selector;
                for (var i = 0; i < runtimes.length; i++)
                    "function" == typeof runtimes[i] && runtimes[i].call(this, this)
            }
            var runtimes = [];
            return KMEditor.assemble = assemble,
            assemble(_p.r(7)),
            assemble(_p.r(9)),
            assemble(_p.r(14)),
            assemble(_p.r(18)),
            assemble(_p.r(11)),
            assemble(_p.r(12)),
            assemble(_p.r(5)),
            assemble(_p.r(6)),
            assemble(_p.r(8)),
            assemble(_p.r(15)),
            assemble(_p.r(10)),
            assemble(_p.r(13)),
            assemble(_p.r(16)),
            assemble(_p.r(17)),
            module.exports = KMEditor
        }
    },
    _p[1] = {
        value: function(require, exports, module) {
            return module.exports = kityminder.Editor = _p.r(0)
        }
    },
    _p[2] = {
        value: function(require, exports, module) {
            return module.exports = window.HotBox
        }
    },
    _p[3] = {
        value: function(require, exports, module) {}
    },
    _p[4] = {
        value: function(require, exports, module) {
            return module.exports = window.kityminder.Minder
        }
    },
    _p[5] = {
        value: function(require, exports, module) {
            function MimeType() {
                function process(mimetype, text) {
                    if (!this.isPureText(text)) {
                        if (!this.whichMimeType(text))
                            throw new Error("unknow mimetype!");
                        text = this.getPureText(text)
                    }
                    return !1 === mimetype ? text : mimetype + SPLITOR + text
                }
                var SPLITOR = "\ufeff"
                  , MIMETYPE = {
                    "application/km": "￿"
                }
                  , SIGN = {
                    "\ufeff": "SPLITOR",
                    "￿": "application/km"
                };
                this.registMimeTypeProtocol = function(type, sign) {
                    if (sign && SIGN[sign])
                        throw new Error("sing has registed!");
                    if (type && MIMETYPE[type])
                        throw new Error("mimetype has registed!");
                    SIGN[sign] = type,
                    MIMETYPE[type] = sign
                }
                ,
                this.getMimeTypeProtocol = function(type, text) {
                    var mimetype = MIMETYPE[type] || !1;
                    return void 0 === text ? process.bind(this, mimetype) : process(mimetype, text)
                }
                ,
                this.getSpitor = function() {
                    return SPLITOR
                }
                ,
                this.getMimeType = function(sign) {
                    return void 0 !== sign ? SIGN[sign] || null : MIMETYPE
                }
            }
            function MimeTypeRuntime() {
                this.minder.supportClipboardEvent && !kity.Browser.gecko && (this.MimeType = new MimeType)
            }
            return MimeType.prototype.isPureText = function(text) {
                return !~text.indexOf(this.getSpitor())
            }
            ,
            MimeType.prototype.getPureText = function(text) {
                return this.isPureText(text) ? text : text.split(this.getSpitor())[1]
            }
            ,
            MimeType.prototype.whichMimeType = function(text) {
                return this.isPureText(text) ? null : this.getMimeType(text.split(this.getSpitor())[0])
            }
            ,
            module.exports = MimeTypeRuntime
        }
    },
    _p[6] = {
        value: function(require, exports, module) {
            function ClipboardRuntime() {
                function encode(nodes) {
                    for (var _nodes = [], i = 0, l = nodes.length; i < l; i++)
                        _nodes.push(minder.exportNode(nodes[i]));
                    return kmencode(Data.getRegisterProtocol("json").encode(_nodes))
                }
                var minder = this.minder
                  , Data = window.kityminder.data;
                if (minder.supportClipboardEvent && !kity.Browser.gecko) {
                    var fsm = this.fsm
                      , receiver = this.receiver
                      , MimeType = this.MimeType
                      , kmencode = MimeType.getMimeTypeProtocol("application/km")
                      , decode = Data.getRegisterProtocol("json").decode
                      , _selectedNodes = []
                      , beforeCopy = function(e) {
                        if (document.activeElement == receiver.element) {
                            var clipBoardEvent = e;
                            switch (fsm.state()) {
                            case "input":
                                break;
                            case "normal":
                                var nodes = [].concat(minder.getSelectedNodes());
                                if (nodes.length) {
                                    if (nodes.length > 1) {
                                        var targetLevel;
                                        if (nodes.sort(function(a, b) {
                                            return a.getLevel() - b.getLevel()
                                        }),
                                        (targetLevel = nodes[0].getLevel()) !== nodes[nodes.length - 1].getLevel()) {
                                            var pnode, idx = 0, l = nodes.length, pidx = l - 1;
                                            for (pnode = nodes[pidx]; pnode.getLevel() !== targetLevel; ) {
                                                for (idx = 0; idx < l && nodes[idx].getLevel() === targetLevel; ) {
                                                    if (nodes[idx].isAncestorOf(pnode)) {
                                                        nodes.splice(pidx, 1);
                                                        break
                                                    }
                                                    idx++
                                                }
                                                pidx--,
                                                pnode = nodes[pidx]
                                            }
                                        }
                                    }
                                    var str = encode(nodes);
                                    clipBoardEvent.clipboardData.setData("text/plain", str)
                                }
                                e.preventDefault()
                            }
                        }
                    }
                      , beforeCut = function(e) {
                        if (document.activeElement == receiver.element) {
                            if ("normal" !== minder.getStatus())
                                return void e.preventDefault();
                            var clipBoardEvent = e;
                            switch (fsm.state()) {
                            case "input":
                                break;
                            case "normal":
                                var nodes = minder.getSelectedNodes();
                                nodes.length && (clipBoardEvent.clipboardData.setData("text/plain", encode(nodes)),
                                minder.execCommand("removenode")),
                                e.preventDefault()
                            }
                        }
                    }
                      , beforePaste = function(e) {
                        if (document.activeElement == receiver.element) {
                            if ("normal" !== minder.getStatus())
                                return void e.preventDefault();
                            var clipBoardEvent = e
                              , state = fsm.state()
                              , textData = clipBoardEvent.clipboardData.getData("text/plain");
                            switch (state) {
                            case "input":
                                if (!MimeType.isPureText(textData))
                                    return void e.preventDefault();
                                break;
                            case "normal":
                                var sNodes = minder.getSelectedNodes();
                                if ("application/km" === MimeType.whichMimeType(textData)) {
                                    var _node, nodes = decode(MimeType.getPureText(textData));
                                    sNodes.forEach(function(node) {
                                        for (var i = nodes.length - 1; i >= 0; i--)
                                            _node = minder.createNode(null, node),
                                            minder.importNode(_node, nodes[i]),
                                            _selectedNodes.push(_node),
                                            node.appendChild(_node)
                                    }),
                                    minder.select(_selectedNodes, !0),
                                    _selectedNodes = [],
                                    minder.refresh()
                                } else {
                                    if (clipBoardEvent.clipboardData && clipBoardEvent.clipboardData.items[0].type.indexOf("image") > -1) {
                                        var imageFile = clipBoardEvent.clipboardData.items[0].getAsFile();
                                        return angular.element(document.body).injector().get("server").uploadImage(imageFile).then(function(json) {
                                            var resp = json.data;
                                            0 === resp.errno && minder.execCommand("image", resp.data.url)
                                        })
                                    }
                                    sNodes.forEach(function(node) {
                                        minder.Text2Children(node, textData)
                                    })
                                }
                                e.preventDefault()
                            }
                        }
                    };
                    document.addEventListener("copy", beforeCopy),
                    document.addEventListener("cut", beforeCut),
                    document.addEventListener("paste", beforePaste)
                }
            }
            return module.exports = ClipboardRuntime
        }
    },
    _p[7] = {
        value: function(require, exports, module) {
            function ContainerRuntime() {
                var container;
                if (!(container = "string" == typeof this.selector ? document.querySelector(this.selector) : this.selector))
                    throw new Error("Invalid selector: " + this.selector);
                container.classList.add("km-editor"),
                this.container = container
            }
            return module.exports = ContainerRuntime
        }
    },
    _p[8] = {
        value: function(require, exports, module) {
            function DragRuntime() {
                function move(direction, speed) {
                    if (!direction)
                        return freeHorizen = freeVirtical = !1,
                        frame && kity.releaseFrame(frame),
                        void (frame = null);
                    frame || (frame = kity.requestFrame(function(direction, speed, minder) {
                        return function(frame) {
                            switch (direction) {
                            case "left":
                                minder._viewDragger.move({
                                    x: -speed,
                                    y: 0
                                }, 0);
                                break;
                            case "top":
                                minder._viewDragger.move({
                                    x: 0,
                                    y: -speed
                                }, 0);
                                break;
                            case "right":
                                minder._viewDragger.move({
                                    x: speed,
                                    y: 0
                                }, 0);
                                break;
                            case "bottom":
                                minder._viewDragger.move({
                                    x: 0,
                                    y: speed
                                }, 0);
                                break;
                            default:
                                return
                            }
                            frame.next()
                        }
                    }(direction, speed, minder)))
                }
                var fsm = this.fsm
                  , minder = this.minder
                  , hotbox = this.hotbox
                  , receiver = this.receiver;
                receiver.element;
                !function() {
                    fsm.when("* -> drag", function() {}),
                    fsm.when("drag -> *", function(exit, enter, reason) {})
                }();
                var downX, downY, maxX, maxY, osx, osy, containerY, frame, flag = 1, freeHorizen = !1, freeVirtical = !1;
                minder.on("mousedown", function(e) {
                    flag = 0;
                    var rect = minder.getPaper().container.getBoundingClientRect();
                    downX = e.originEvent.clientX,
                    downY = e.originEvent.clientY,
                    containerY = rect.top,
                    maxX = rect.width,
                    maxY = rect.height
                }),
                minder.on("mousemove", function(e) {
                    if ("drag" === fsm.state() && 0 == flag && minder.getSelectedNode() && (Math.abs(downX - e.originEvent.clientX) > 20 || Math.abs(downY - e.originEvent.clientY) > 20) && (osx = e.originEvent.clientX,
                    osy = e.originEvent.clientY - containerY,
                    osx < 20 ? move("right", 20 - osx) : osx > maxX - 20 ? move("left", 20 + osx - maxX) : freeHorizen = !0,
                    osy < 20 ? move("bottom", osy) : osy > maxY - 20 ? move("top", 20 + osy - maxY) : freeVirtical = !0,
                    freeHorizen && freeVirtical && move(!1)),
                    "drag" !== fsm.state() && 0 === flag && minder.getSelectedNode() && (Math.abs(downX - e.originEvent.clientX) > 20 || Math.abs(downY - e.originEvent.clientY) > 20))
                        return "hotbox" === fsm.state() && hotbox.active(Hotbox.STATE_IDLE),
                        fsm.jump("drag", "user-drag")
                }),
                window.addEventListener("mouseup", function() {
                    if (flag = 1,
                    "drag" === fsm.state())
                        return move(!1),
                        fsm.jump("normal", "drag-finish")
                }, !1)
            }
            var Hotbox = _p.r(2)
              , Debug = _p.r(19);
            new Debug("drag");
            return module.exports = DragRuntime
        }
    },
    _p[9] = {
        value: function(require, exports, module) {
            function handlerConditionMatch(condition, when, exit, enter) {
                if (condition.when != when)
                    return !1;
                if ("*" != condition.enter && condition.enter != enter)
                    return !1;
                if ("*" == condition.exit || condition.exit == exit)
                    return !0
            }
            function FSM(defaultState) {
                var currentState = defaultState
                  , handlers = [];
                this.jump = function(newState, reason) {
                    if (!reason)
                        throw new Error("Please tell fsm the reason to jump");
                    var i, handler, oldState = currentState, notify = [oldState, newState].concat([].slice.call(arguments, 1));
                    for (i = 0; i < handlers.length; i++)
                        if (handler = handlers[i],
                        handlerConditionMatch(handler.condition, "before", oldState, newState) && handler.apply(null, notify))
                            return;
                    for (currentState = newState,
                    debug.log("[{0}] {1} -> {2}", reason, oldState, newState),
                    i = 0; i < handlers.length; i++)
                        handler = handlers[i],
                        handlerConditionMatch(handler.condition, "after", oldState, newState) && handler.apply(null, notify);
                    return currentState
                }
                ,
                this.state = function() {
                    return currentState
                }
                ,
                this.when = function(condition, handler) {
                    1 == arguments.length && (handler = condition,
                    condition = "* -> *");
                    var when, resolved, exit, enter;
                    if (resolved = condition.split(" - "),
                    2 == resolved.length ? when = "before" : (resolved = condition.split(" -> "),
                    2 == resolved.length && (when = "after")),
                    !when)
                        throw new Error("Illegal fsm condition: " + condition);
                    exit = resolved[0],
                    enter = resolved[1],
                    handler.condition = {
                        when: when,
                        exit: exit,
                        enter: enter
                    },
                    handlers.push(handler)
                }
            }
            function FSMRumtime() {
                this.fsm = new FSM("normal")
            }
            var Debug = _p.r(19)
              , debug = new Debug("fsm");
            return module.exports = FSMRumtime
        }
    },
    _p[10] = {
        value: function(require, exports, module) {
            function HistoryRuntime() {
                function reset() {
                    undoDiffs = [],
                    redoDiffs = [],
                    lastSnap = minder.exportJson()
                }
                function makeUndoDiff() {
                    var headSnap = minder.exportJson()
                      , diff = jsonDiff(headSnap, lastSnap);
                    if (diff.length) {
                        for (undoDiffs.push(diff); undoDiffs.length > MAX_HISTORY; )
                            undoDiffs.shift();
                        return lastSnap = headSnap,
                        !0
                    }
                }
                function makeRedoDiff() {
                    var revertSnap = minder.exportJson();
                    redoDiffs.push(jsonDiff(revertSnap, lastSnap)),
                    lastSnap = revertSnap
                }
                function undo() {
                    patchLock = !0;
                    var undoDiff = undoDiffs.pop();
                    undoDiff && (minder.applyPatches(undoDiff),
                    makeRedoDiff()),
                    patchLock = !1
                }
                function redo() {
                    patchLock = !0;
                    var redoDiff = redoDiffs.pop();
                    redoDiff && (minder.applyPatches(redoDiff),
                    makeUndoDiff()),
                    patchLock = !1
                }
                function changed() {
                    patchLock || makeUndoDiff() && (redoDiffs = [])
                }
                function hasUndo() {
                    return !!undoDiffs.length
                }
                function hasRedo() {
                    return !!redoDiffs.length
                }
                function updateSelection(e) {
                    if (patchLock) {
                        var patch = e.patch;
                        switch (patch.express) {
                        case "node.add":
                            minder.select(patch.node.getChild(patch.index), !0);
                            break;
                        case "node.remove":
                        case "data.replace":
                        case "data.remove":
                        case "data.add":
                            minder.select(patch.node, !0)
                        }
                    }
                }
                var lastSnap, patchLock, undoDiffs, redoDiffs, minder = this.minder, hotbox = this.hotbox, MAX_HISTORY = 100;
                this.history = {
                    reset: reset,
                    undo: undo,
                    redo: redo,
                    hasUndo: hasUndo,
                    hasRedo: hasRedo
                },
                reset(),
                minder.on("contentchange", changed),
                minder.on("import", reset),
                minder.on("patch", updateSelection);
                var main = hotbox.state("main");
                main.button({
                    position: "top",
                    label: "撤销",
                    key: "Ctrl + Z",
                    enable: hasUndo,
                    action: undo,
                    next: "idle"
                }),
                main.button({
                    position: "top",
                    label: "重做",
                    key: "Ctrl + Y",
                    enable: hasRedo,
                    action: redo,
                    next: "idle"
                })
            }
            var jsonDiff = _p.r(22);
            return window.diff = jsonDiff,
            module.exports = HistoryRuntime
        }
    },
    _p[11] = {
        value: function(require, exports, module) {
            function HotboxRuntime() {
                var fsm = this.fsm
                  , minder = this.minder
                  , receiver = this.receiver
                  , container = this.container
                  , hotbox = new Hotbox(container);
                hotbox.setParentFSM(fsm),
                fsm.when("normal -> hotbox", function(exit, enter, reason) {
                    var position, node = minder.getSelectedNode();
                    if (node) {
                        var box = node.getRenderBox();
                        position = {
                            x: box.cx,
                            y: box.cy
                        }
                    }
                    hotbox.active("main", position)
                }),
                fsm.when("normal -> normal", function(exit, enter, reason, e) {
                    if ("shortcut-handle" == reason) {
                        hotbox.dispatch(e) ? e.preventDefault() : minder.dispatchKeyEvent(e)
                    }
                }),
                fsm.when("modal -> normal", function(exit, enter, reason, e) {
                    "import-text-finish" == reason && receiver.element.focus()
                }),
                this.hotbox = hotbox
            }
            var Hotbox = _p.r(2);
            return module.exports = HotboxRuntime
        }
    },
    _p[12] = {
        value: function(require, exports, module) {
            function InputRuntime() {
                function editText() {
                    var node = minder.getSelectedNode();
                    if (node) {
                        var textContainer = receiverElement;
                        if (receiverElement.innerText = "",
                        "bold" === node.getData("font-weight")) {
                            var b = document.createElement("b");
                            textContainer.appendChild(b),
                            textContainer = b
                        }
                        if ("italic" === node.getData("font-style")) {
                            var i = document.createElement("i");
                            textContainer.appendChild(i),
                            textContainer = i
                        }
                        textContainer.innerText = minder.queryCommandValue("text"),
                        isGecko && receiver.fixFFCaretDisappeared(),
                        fsm.jump("input", "input-request"),
                        receiver.selectAll()
                    }
                }
                function enterInputMode() {
                    var node = minder.getSelectedNode();
                    if (node) {
                        var fontSize = node.getData("font-size") || node.getStyle("font-size");
                        receiverElement.style.fontSize = fontSize + "px",
                        receiverElement.style.minWidth = 0,
                        receiverElement.style.minWidth = receiverElement.clientWidth + "px",
                        receiverElement.style.fontWeight = node.getData("font-weight") || "",
                        receiverElement.style.fontStyle = node.getData("font-style") || "",
                        receiverElement.classList.add("input"),
                        receiverElement.focus()
                    }
                }
                function commitInputText(textNodes) {
                    for (var str, _divChildNodes, space_l, text = "", STR_CHECK = /\S/, SPACE_CHAR_REGEXP = new RegExp("( |" + String.fromCharCode(160) + ")"), BR = document.createElement("br"), isBold = !1, isItalic = !1, i = 0, l = textNodes.length; i < l; i++)
                        switch (str = textNodes[i],
                        Object.prototype.toString.call(str)) {
                        case "[object HTMLBRElement]":
                            text += "\n";
                            break;
                        case "[object Text]":
                            if (str = str.textContent.replace("&nbsp;", " "),
                            STR_CHECK.test(str))
                                text += str;
                            else
                                for (space_l = str.length; space_l--; )
                                    SPACE_CHAR_REGEXP.test(str[space_l]) ? text += " " : "\t" === str[space_l] && (text += "\t");
                            break;
                        case "[object HTMLElement]":
                            switch (str.nodeName) {
                            case "B":
                                isBold = !0;
                                break;
                            case "I":
                                isItalic = !0
                            }
                            [].splice.apply(textNodes, [i, 1].concat([].slice.call(str.childNodes))),
                            l = textNodes.length,
                            i--;
                            break;
                        case "[object HTMLSpanElement]":
                            [].splice.apply(textNodes, [i, 1].concat([].slice.call(str.childNodes))),
                            l = textNodes.length,
                            i--;
                            break;
                        case "[object HTMLImageElement]":
                            str.src && /http(|s):\/\//.test(str.src) && minder.execCommand("Image", str.src, str.alt);
                            break;
                        case "[object HTMLDivElement]":
                            _divChildNodes = [];
                            for (var di = 0, l = str.childNodes.length; di < l; di++)
                                _divChildNodes.push(str.childNodes[di]);
                            _divChildNodes.push(BR),
                            [].splice.apply(textNodes, [i, 1].concat(_divChildNodes)),
                            l = textNodes.length,
                            i--;
                            break;
                        default:
                            if (str && str.childNodes.length) {
                                _divChildNodes = [];
                                for (var di = 0, l = str.childNodes.length; di < l; di++)
                                    _divChildNodes.push(str.childNodes[di]);
                                _divChildNodes.push(BR),
                                [].splice.apply(textNodes, [i, 1].concat(_divChildNodes)),
                                l = textNodes.length,
                                i--
                            } else
                                str && void 0 !== str.textContent ? text += str.textContent : text += ""
                        }
                    return text = text.replace(/^\n*|\n*$/g, ""),
                    text = text.replace(new RegExp("(\n|\r|\n\r)( |" + String.fromCharCode(160) + "){4}","g"), "$1\t"),
                    minder.getSelectedNode().setText(text),
                    isBold ? minder.queryCommandState("bold") || minder.execCommand("bold") : minder.queryCommandState("bold") && minder.execCommand("bold"),
                    isItalic ? minder.queryCommandState("italic") || minder.execCommand("italic") : minder.queryCommandState("italic") && minder.execCommand("italic"),
                    exitInputMode(),
                    text
                }
                function commitInputNode(node, text) {
                    try {
                        minder.decodeData("text", text).then(function(json) {
                            function importText(node, json, minder) {
                                var data = json.data;
                                node.setText(data.text || "");
                                for (var childrenTreeData = json.children || [], i = 0; i < childrenTreeData.length; i++) {
                                    importText(minder.createNode(null, node), childrenTreeData[i], minder)
                                }
                                return node
                            }
                            importText(node, json, minder),
                            minder.fire("contentchange"),
                            minder.getRoot().renderTree(),
                            minder.layout(300)
                        })
                    } catch (e) {
                        if (minder.fire("contentchange"),
                        minder.getRoot().renderTree(),
                        "Error: Invalid local format" !== e.toString())
                            throw e
                    }
                }
                function commitInputResult() {
                    var textNodes = [].slice.call(receiverElement.childNodes);
                    setTimeout(function() {
                        receiverElement.innerHTML = ""
                    }, 0);
                    var node = minder.getSelectedNode();
                    if (textNodes = commitInputText(textNodes),
                    commitInputNode(node, textNodes),
                    "root" == node.type) {
                        var rootText = minder.getRoot().getText();
                        minder.fire("initChangeRoot", {
                            text: rootText
                        })
                    }
                }
                function exitInputMode() {
                    receiverElement.classList.remove("input"),
                    receiver.selectAll()
                }
                function updatePosition() {
                    var planed = updatePosition
                      , focusNode = minder.getSelectedNode();
                    focusNode && (planed.timer || (planed.timer = setTimeout(function() {
                        var box = focusNode.getRenderBox("TextRenderer");
                        receiverElement.style.left = Math.round(box.x) + "px",
                        receiverElement.style.top = (debug.flaged ? Math.round(box.bottom + 30) : Math.round(box.y)) + "px",
                        planed.timer = 0
                    })))
                }
                var fsm = this.fsm
                  , minder = this.minder
                  , hotbox = this.hotbox
                  , receiver = this.receiver
                  , receiverElement = receiver.element
                  , isGecko = window.kity.Browser.gecko;
                !function() {
                    debug.flaged && receiverElement.classList.add("debug"),
                    receiverElement.onmousedown = function(e) {
                        e.stopPropagation()
                    }
                    ,
                    minder.on("layoutallfinish viewchange viewchanged selectionchange", function(e) {
                        "viewchange" == e.type && "input" != fsm.state() || updatePosition()
                    }),
                    updatePosition()
                }(),
                function() {
                    fsm.when("* -> input", enterInputMode),
                    fsm.when("input -> *", function(exit, enter, reason) {
                        switch (reason) {
                        case "input-cancel":
                            return exitInputMode();
                        case "input-commit":
                        default:
                            return commitInputResult()
                        }
                    }),
                    receiver.onblur(function(e) {
                        "input" == fsm.state() && fsm.jump("normal", "input-commit")
                    }),
                    minder.on("beforemousedown", function() {
                        "input" == fsm.state() && fsm.jump("normal", "input-commit")
                    }),
                    minder.on("dblclick", function() {
                        minder.getSelectedNode() && "readonly" !== minder._status && editText()
                    })
                }(),
                function() {
                    hotbox.state("main").button({
                        position: "center",
                        label: "编辑",
                        key: "F2",
                        enable: function() {
                            return -1 != minder.queryCommandState("text")
                        },
                        action: editText
                    })
                }(),
                this.editText = editText
            }
            _p.r(21);
            var Debug = _p.r(19)
              , debug = new Debug("input");
            return module.exports = InputRuntime
        }
    },
    _p[13] = {
        value: function(require, exports, module) {
            function isIntendToInput(e) {
                return !(e.ctrlKey || e.metaKey || e.altKey) && (e.keyCode >= 65 && e.keyCode <= 90 || (e.keyCode >= 48 && e.keyCode <= 57 || (108 != e.keyCode && e.keyCode >= 96 && e.keyCode <= 111 || (108 != e.keyCode && e.keyCode >= 96 && e.keyCode <= 111 || (229 == e.keyCode || 0 === e.keyCode)))))
            }
            function JumpingRuntime() {
                var fsm = this.fsm
                  , minder = this.minder
                  , receiver = this.receiver
                  , container = this.container
                  , receiverElement = receiver.element
                  , hotbox = this.hotbox;
                receiver.listen("normal", function(e) {
                    if (receiver.enable(),
                    e.is("Space"))
                        return e.preventDefault(),
                        kity.Browser.safari && (receiverElement.innerHTML = ""),
                        fsm.jump("hotbox", "space-trigger");
                    switch (e.type) {
                    case "keydown":
                        if (minder.getSelectedNode()) {
                            if (isIntendToInput(e))
                                return fsm.jump("input", "user-input")
                        } else
                            receiverElement.innerHTML = "";
                        fsm.jump("normal", "shortcut-handle", e)
                    }
                }),
                receiver.listen("hotbox", function(e) {
                    receiver.disable(),
                    e.preventDefault();
                    hotbox.dispatch(e);
                    if (hotbox.state() == Hotbox.STATE_IDLE && "hotbox" == fsm.state())
                        return fsm.jump("normal", "hotbox-idle")
                }),
                receiver.listen("input", function(e) {
                    if (receiver.enable(),
                    "keydown" == e.type) {
                        if (e.is("Enter"))
                            return e.preventDefault(),
                            fsm.jump("normal", "input-commit");
                        if (e.is("Esc"))
                            return e.preventDefault(),
                            fsm.jump("normal", "input-cancel");
                        (e.is("Tab") || e.is("Shift + Tab")) && e.preventDefault()
                    } else if ("keyup" == e.type && e.is("Esc"))
                        return e.preventDefault(),
                        fsm.jump("normal", "input-cancel")
                });
                var downX, downY;
                container.addEventListener("mousedown", function(e) {
                    2 == e.button && e.preventDefault(),
                    "hotbox" == fsm.state() ? (hotbox.active(Hotbox.STATE_IDLE),
                    fsm.jump("normal", "blur")) : "normal" == fsm.state() && 2 == e.button && (downX = e.clientX,
                    downY = e.clientY)
                }, !1),
                container.addEventListener("mousewheel", function(e) {
                    "hotbox" == fsm.state() && (hotbox.active(Hotbox.STATE_IDLE),
                    fsm.jump("normal", "mousemove-blur"))
                }, !1),
                container.addEventListener("contextmenu", function(e) {
                    e.preventDefault()
                }),
                container.addEventListener("mouseup", function(e) {
                    "normal" == fsm.state() && 2 == e.button && e.clientX == downX && e.clientY == downY && minder.getSelectedNode() && fsm.jump("hotbox", "content-menu")
                }, !1),
                hotbox.$element.addEventListener("mousedown", function(e) {
                    e.stopPropagation()
                })
            }
            var Hotbox = _p.r(2);
            return module.exports = JumpingRuntime
        }
    },
    _p[14] = {
        value: function(require, exports, module) {
            function MinderRuntime() {
                var minder = new Minder({
                    enableKeyReceiver: !1,
                    enableAnimation: !0
                });
                minder.renderTo(this.selector),
                minder.setTheme(null),
                minder.select(minder.getRoot(), !0),
                minder.execCommand("text", "中心主题"),
                this.minder = minder
            }
            var Minder = _p.r(4);
            return module.exports = MinderRuntime
        }
    },
    _p[15] = {
        value: function(require, exports, module) {
            function NodeRuntime() {
                function importNodeData() {
                    minder.fire("importNodeData")
                }
                function exportNodeData() {
                    minder.fire("exportNodeData")
                }
                var runtime = this
                  , minder = this.minder
                  , hotbox = this.hotbox
                  , fsm = this.fsm
                  , main = hotbox.state("main")
                  , buttons = ["前移:Alt+Up:ArrangeUp", "下级:Tab|Insert:AppendChildNode", "同级:Enter:AppendSiblingNode", "后移:Alt+Down:ArrangeDown", "删除:Delete|Backspace:RemoveNode", "上级:Shift+Tab|Shift+Insert:AppendParentNode"]
                  , AppendLock = 0;
                buttons.forEach(function(button) {
                    var parts = button.split(":")
                      , label = parts.shift()
                      , key = parts.shift()
                      , command = parts.shift();
                    main.button({
                        position: "ring",
                        label: label,
                        key: key,
                        action: function() {
                            function afterAppend() {
                                --AppendLock || runtime.editText(),
                                minder.off("layoutallfinish", afterAppend)
                            }
                            0 === command.indexOf("Append") ? (AppendLock++,
                            minder.execCommand(command, "分支主题"),
                            minder.on("layoutallfinish", afterAppend)) : (minder.execCommand(command),
                            fsm.jump("normal", "command-executed"))
                        },
                        enable: function() {
                            return -1 != minder.queryCommandState(command)
                        }
                    })
                }),
                main.button({
                    position: "bottom",
                    label: "导入节点",
                    key: "Alt + V",
                    enable: function() {
                        return 1 == minder.getSelectedNodes().length
                    },
                    action: importNodeData,
                    next: "idle"
                }),
                main.button({
                    position: "bottom",
                    label: "导出节点",
                    key: "Alt + C",
                    enable: function() {
                        return 1 == minder.getSelectedNodes().length
                    },
                    action: exportNodeData,
                    next: "idle"
                })
            }
            return module.exports = NodeRuntime
        }
    },
    _p[16] = {
        value: function(require, exports, module) {
            function PriorityRuntime() {
                var minder = this.minder
                  , hotbox = this.hotbox;
                hotbox.state("main").button({
                    position: "top",
                    label: "优先级",
                    key: "P",
                    next: "priority",
                    enable: function() {
                        return -1 != minder.queryCommandState("priority")
                    }
                });
                var priority = hotbox.state("priority");
                "123456789".replace(/./g, function(p) {
                    priority.button({
                        position: "ring",
                        label: "P" + p,
                        key: p,
                        action: function() {
                            minder.execCommand("Priority", p)
                        }
                    })
                }),
                priority.button({
                    position: "center",
                    label: "移除",
                    key: "Del",
                    action: function() {
                        minder.execCommand("Priority", 0)
                    }
                }),
                priority.button({
                    position: "top",
                    label: "返回",
                    key: "esc",
                    next: "back"
                })
            }
            return module.exports = PriorityRuntime
        }
    },
    _p[17] = {
        value: function(require, exports, module) {
            function ProgressRuntime() {
                var minder = this.minder
                  , hotbox = this.hotbox;
                hotbox.state("main").button({
                    position: "top",
                    label: "进度",
                    key: "G",
                    next: "progress",
                    enable: function() {
                        return -1 != minder.queryCommandState("progress")
                    }
                });
                var progress = hotbox.state("progress");
                "012345678".replace(/./g, function(p) {
                    progress.button({
                        position: "ring",
                        label: "G" + p,
                        key: p,
                        action: function() {
                            minder.execCommand("Progress", parseInt(p) + 1)
                        }
                    })
                }),
                progress.button({
                    position: "center",
                    label: "移除",
                    key: "Del",
                    action: function() {
                        minder.execCommand("Progress", 0)
                    }
                }),
                progress.button({
                    position: "top",
                    label: "返回",
                    key: "esc",
                    next: "back"
                })
            }
            return module.exports = ProgressRuntime
        }
    },
    _p[18] = {
        value: function(require, exports, module) {
            function ReceiverRuntime() {
                function dispatchKeyEvent(e) {
                    e.is = function(keyExpression) {
                        for (var subs = keyExpression.split("|"), i = 0; i < subs.length; i++)
                            if (key.is(this, subs[i]))
                                return !0;
                        return !1
                    }
                    ;
                    for (var listener, i = 0; i < listeners.length; i++)
                        if (listener = listeners[i],
                        ("*" == listener.notifyState || listener.notifyState == fsm.state()) && listener.call(null, e))
                            return
                }
                var fsm = this.fsm
                  , minder = this.minder
                  , element = document.createElement("div");
                element.contentEditable = !0,
                element.setAttribute("tabindex", -1),
                element.classList.add("receiver"),
                element.onkeydown = element.onkeypress = element.onkeyup = dispatchKeyEvent,
                this.container.appendChild(element);
                var receiver = {
                    element: element,
                    selectAll: function() {
                        element.innerHTML || (element.innerHTML = "&nbsp;");
                        var range = document.createRange()
                          , selection = window.getSelection();
                        range.selectNodeContents(element),
                        selection.removeAllRanges(),
                        selection.addRange(range),
                        element.focus()
                    },
                    enable: function() {
                        element.setAttribute("contenteditable", !0)
                    },
                    disable: function() {
                        element.setAttribute("contenteditable", !1)
                    },
                    fixFFCaretDisappeared: function() {
                        element.removeAttribute("contenteditable"),
                        element.setAttribute("contenteditable", "true"),
                        element.blur(),
                        element.focus()
                    },
                    onblur: function(handler) {
                        element.onblur = handler
                    }
                };
                receiver.selectAll(),
                minder.on("beforemousedown", receiver.selectAll),
                minder.on("receiverfocus", receiver.selectAll),
                minder.on("readonly", function() {
                    minder.disable(),
                    editor.receiver.element.parentElement.removeChild(editor.receiver.element),
                    editor.hotbox.$container.removeChild(editor.hotbox.$element)
                });
                var listeners = [];
                receiver.listen = function(state, listener) {
                    1 == arguments.length && (listener = state,
                    state = "*"),
                    listener.notifyState = state,
                    listeners.push(listener)
                }
                ,
                this.receiver = receiver
            }
            var key = _p.r(23);
            _p.r(2);
            return module.exports = ReceiverRuntime
        }
    },
    _p[19] = {
        value: function(require, exports, module) {
            function noop() {}
            function stringHash(str) {
                for (var hash = 0, i = 0; i < str.length; i++)
                    hash += str.charCodeAt(i);
                return hash
            }
            function Debug(flag) {
                if (this.flaged = -1 != window.location.search.indexOf(flag)) {
                    var h = stringHash(flag) % 360
                      , flagStyle = format("background: hsl({0}, 50%, 80%); color: hsl({0}, 100%, 30%); padding: 2px 3px; margin: 1px 3px 0 0;border-radius: 2px;", h);
                    this.log = function() {
                        var output = format.apply(null, arguments);
                        console.log(format("%c{0}%c{1}", flag, output), flagStyle, "background: none; color: black;")
                    }
                } else
                    this.log = noop
            }
            var format = _p.r(20);
            return module.exports = Debug
        }
    },
    _p[20] = {
        value: function(require, exports, module) {
            function format(template, args) {
                return "object" != typeof args && (args = [].slice.call(arguments, 1)),
                String(template).replace(/\{(\w+)\}/gi, function(match, $key) {
                    return args[$key] || $key
                })
            }
            return module.exports = format
        }
    },
    _p[21] = {
        value: function(require, exports, module) {
            !("innerText"in document.createElement("a")) && "getSelection"in window && (HTMLElement.prototype.__defineGetter__("innerText", function() {
                var str, i, selection = window.getSelection(), ranges = [];
                for (i = 0; i < selection.rangeCount; i++)
                    ranges[i] = selection.getRangeAt(i);
                for (selection.removeAllRanges(),
                selection.selectAllChildren(this),
                str = selection.toString(),
                selection.removeAllRanges(),
                i = 0; i < ranges.length; i++)
                    selection.addRange(ranges[i]);
                return str
            }),
            HTMLElement.prototype.__defineSetter__("innerText", function(text) {
                this.innerHTML = (text || "").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>")
            }))
        }
    },
    _p[22] = {
        value: function(require, exports, module) {
            function escapePathComponent(str) {
                return -1 === str.indexOf("/") && -1 === str.indexOf("~") ? str : str.replace(/~/g, "~0").replace(/\//g, "~1")
            }
            function deepClone(obj) {
                return "object" == typeof obj ? JSON.parse(JSON.stringify(obj)) : obj
            }
            function _generate(mirror, obj, patches, path) {
                for (var newKeys = _objectKeys(obj), oldKeys = _objectKeys(mirror), deleted = !1, t = oldKeys.length - 1; t >= 0; t--) {
                    var key = oldKeys[t]
                      , oldVal = mirror[key];
                    if (obj.hasOwnProperty(key)) {
                        var newVal = obj[key];
                        "object" == typeof oldVal && null != oldVal && "object" == typeof newVal && null != newVal ? _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key)) : oldVal != newVal && (!0,
                        patches.push({
                            op: "replace",
                            path: path + "/" + escapePathComponent(key),
                            value: deepClone(newVal)
                        }))
                    } else
                        patches.push({
                            op: "remove",
                            path: path + "/" + escapePathComponent(key)
                        }),
                        deleted = !0
                }
                if (deleted || newKeys.length != oldKeys.length)
                    for (var t = 0; t < newKeys.length; t++) {
                        var key = newKeys[t];
                        mirror.hasOwnProperty(key) || patches.push({
                            op: "add",
                            path: path + "/" + escapePathComponent(key),
                            value: deepClone(obj[key])
                        })
                    }
            }
            function compare(tree1, tree2) {
                var patches = [];
                return _generate(tree1, tree2, patches, ""),
                patches
            }
            var _objectKeys = function() {
                return Object.keys ? Object.keys : function(o) {
                    var keys = [];
                    for (var i in o)
                        o.hasOwnProperty(i) && keys.push(i);
                    return keys
                }
            }();
            return module.exports = compare
        }
    },
    _p[23] = {
        value: function(require, exports, module) {
            function hash(unknown) {
                return "string" == typeof unknown ? hashKeyExpression(unknown) : hashKeyEvent(unknown)
            }
            function is(a, b) {
                return a && b && hash(a) == hash(b)
            }
            function hashKeyEvent(keyEvent) {
                var hashCode = 0;
                if ((keyEvent.ctrlKey || keyEvent.metaKey) && (hashCode |= CTRL_MASK),
                keyEvent.altKey && (hashCode |= ALT_MASK),
                keyEvent.shiftKey && (hashCode |= SHIFT_MASK),
                -1 === [16, 17, 18, 91].indexOf(keyEvent.keyCode)) {
                    if (229 === keyEvent.keyCode && keyEvent.keyIdentifier)
                        return hashCode |= parseInt(keyEvent.keyIdentifier.substr(2), 16);
                    hashCode |= keyEvent.keyCode
                }
                return hashCode
            }
            function hashKeyExpression(keyExpression) {
                var hashCode = 0;
                return keyExpression.toLowerCase().split(/\s*\+\s*/).forEach(function(name) {
                    switch (name) {
                    case "ctrl":
                    case "cmd":
                        hashCode |= CTRL_MASK;
                        break;
                    case "alt":
                        hashCode |= ALT_MASK;
                        break;
                    case "shift":
                        hashCode |= SHIFT_MASK;
                        break;
                    default:
                        hashCode |= keymap[name]
                    }
                }),
                hashCode
            }
            var keymap = _p.r(24)
              , CTRL_MASK = 4096
              , ALT_MASK = 8192
              , SHIFT_MASK = 16384;
            exports.hash = hash,
            exports.is = is
        }
    },
    _p[24] = {
        value: function(require, exports, module) {
            var keymap = {
                Shift: 16,
                Control: 17,
                Alt: 18,
                CapsLock: 20,
                BackSpace: 8,
                Tab: 9,
                Enter: 13,
                Esc: 27,
                Space: 32,
                PageUp: 33,
                PageDown: 34,
                End: 35,
                Home: 36,
                Insert: 45,
                Left: 37,
                Up: 38,
                Right: 39,
                Down: 40,
                Direction: {
                    37: 1,
                    38: 1,
                    39: 1,
                    40: 1
                },
                Del: 46,
                NumLock: 144,
                Cmd: 91,
                CmdFF: 224,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                "`": 192,
                "=": 187,
                "-": 189,
                "/": 191,
                ".": 190
            };
            for (var key in keymap)
                keymap.hasOwnProperty(key) && (keymap[key.toLowerCase()] = keymap[key]);
            var aCharCode = "a".charCodeAt(0);
            "abcdefghijklmnopqrstuvwxyz".split("").forEach(function(letter) {
                keymap[letter] = letter.charCodeAt(0) - aCharCode + 65
            });
            var n = 9;
            do {
                keymap[n.toString()] = n + 48
            } while (--n);
            module.exports = keymap
        }
    };
    var moduleMapping = {
        "expose-editor": 1
    };
    angular.module("kityminderEditor", ["ui.bootstrap", "ui.codemirror", "ui.colorpicker"]).config(["$sceDelegateProvider", function($sceDelegateProvider) {
        $sceDelegateProvider.resourceUrlWhitelist(["self", "http://agroup.baidu.com:8910/**", "http://cq01-fe-rdtest01.vm.baidu.com:8910/**", "http://agroup.baidu.com:8911/**"])
    }
    ]),
    angular.module("kityminderEditor").run(["$templateCache", function($templateCache) {
        "use strict";
        $templateCache.put("/res/mind/ui/directive/appendNode/appendNode.html", "<div class=\"km-btn-group append-group\"><div class=\"km-btn-item append-child-node\" ng-disabled=\"minder.queryCommandState('AppendChildNode') === -1\" ng-click=\"minder.queryCommandState('AppendChildNode') === -1 || execCommand('AppendChildNode')\" title=\"{{ 'appendchildnode' | lang:'ui/command' }}\"><i class=\"km-btn-icon\"></i> <span class=\"km-btn-caption\">{{ 'appendchildnode' | lang:'ui/command' }}</span></div><div class=\"km-btn-item append-sibling-node\" ng-disabled=\"minder.queryCommandState('AppendSiblingNode') === -1\" ng-click=\"minder.queryCommandState('AppendSiblingNode') === -1 ||execCommand('AppendSiblingNode')\" title=\"{{ 'appendsiblingnode' | lang:'ui/command' }}\"><i class=\"km-btn-icon\"></i> <span class=\"km-btn-caption\">{{ 'appendsiblingnode' | lang:'ui/command' }}</span></div></div>"),
        $templateCache.put("/res/mind/ui/directive/arrange/arrange.html", "<div class=\"km-btn-group arrange-group\"><div class=\"km-btn-item arrange-up\" ng-disabled=\"minder.queryCommandState('ArrangeUp') === -1\" ng-click=\"minder.queryCommandState('ArrangeUp') === -1 || minder.execCommand('ArrangeUp')\" title=\"{{ 'arrangeup' | lang:'ui/command' }}\"><i class=\"km-btn-icon\"></i> <span class=\"km-btn-caption\">{{ 'arrangeup' | lang:'ui/command' }}</span></div><div class=\"km-btn-item arrange-down\" ng-disabled=\"minder.queryCommandState('ArrangeDown') === -1\" ng-click=\"minder.queryCommandState('ArrangeDown') === -1 || minder.execCommand('ArrangeDown');\" title=\"{{ 'arrangedown' | lang:'ui/command' }}\"><i class=\"km-btn-icon\"></i> <span class=\"km-btn-caption\">{{ 'arrangedown' | lang:'ui/command' }}</span></div></div>"),
        $templateCache.put("/res/mind/ui/directive/colorPanel/colorPanel.html", '<div class="bg-color-wrap"><span class="quick-bg-color" ng-click="minder.queryCommandState(\'background\') === -1 || minder.execCommand(\'background\', bgColor)" ng-disabled="minder.queryCommandState(\'background\') === -1"></span> <span color-picker class="bg-color" set-color="setDefaultBg()" ng-disabled="minder.queryCommandState(\'background\') === -1"><span class="caret"></span></span> <span class="bg-color-preview" ng-style="{ \'background-color\': bgColor }" ng-click="minder.queryCommandState(\'background\') === -1 || minder.execCommand(\'background\', bgColor)" ng-disabled="minder.queryCommandState(\'background\') === -1"></span></div>'),
        $templateCache.put("/res/mind/ui/directive/expandLevel/expandLevel.html", '<div class="btn-group-vertical" dropdown is-open="isopen"><button type="button" class="btn btn-default expand" title="{{ \'expandtoleaf\' | lang:\'ui\' }}" ng-class="{\'active\': isopen}" ng-click="minder.execCommand(\'ExpandToLevel\', 9999)"></button> <button type="button" class="btn btn-default expand-caption dropdown-toggle" title="{{ \'expandtoleaf\' | lang:\'ui\' }}" dropdown-toggle><span class="caption">{{ \'expandtoleaf\' | lang:\'ui\' }}</span> <span class="caret"></span> <span class="sr-only">{{ \'expandtoleaf\' | lang:\'ui\' }}</span></button><ul class="dropdown-menu" role="menu"><li ng-repeat="level in levels"><a href ng-click="minder.execCommand(\'ExpandToLevel\', level)">{{ \'expandtolevel\' + level | lang:\'ui/command\' }}</a></li></ul></div>'),
        $templateCache.put("/res/mind/ui/directive/fontOperator/fontOperator.html", '<div class="font-operator"><div class="dropdown font-family-list" dropdown><div class="dropdown-toggle current-font-item" dropdown-toggle ng-disabled="minder.queryCommandState(\'fontfamily\') === -1"><a href class="current-font-family" title="{{ \'fontfamily\' | lang: \'ui\' }}">{{ getFontfamilyName(minder.queryCommandValue(\'fontfamily\')) || \'字体\' }}</a> <span class="caret"></span></div><ul class="dropdown-menu font-list"><li ng-repeat="f in fontFamilyList" class="font-item-wrap"><a ng-click="minder.execCommand(\'fontfamily\', f.val)" class="font-item" ng-class="{ \'font-item-selected\' : f == minder.queryCommandValue(\'fontfamily\') }" ng-style="{\'font-family\': f.val }">{{ f.name }}</a></li></ul></div><div class="dropdown font-size-list" dropdown><div class="dropdown-toggle current-font-item" dropdown-toggle ng-disabled="minder.queryCommandState(\'fontsize\') === -1"><a href class="current-font-size" title="{{ \'fontsize\' | lang: \'ui\' }}">{{ minder.queryCommandValue(\'fontsize\') || \'字号\' }}</a> <span class="caret"></span></div><ul class="dropdown-menu font-list"><li ng-repeat="f in fontSizeList" class="font-item-wrap"><a ng-click="minder.execCommand(\'fontsize\', f)" class="font-item" ng-class="{ \'font-item-selected\' : f == minder.queryCommandValue(\'fontsize\') }" ng-style="{\'font-size\': f + \'px\'}">{{ f }}</a></li></ul></div><span class="s-btn-icon font-bold" ng-click="minder.queryCommandState(\'bold\') === -1 || minder.execCommand(\'bold\')" ng-class="{\'font-bold-selected\' : minder.queryCommandState(\'bold\') == 1}" ng-disabled="minder.queryCommandState(\'bold\') === -1"></span> <span class="s-btn-icon font-italics" ng-click="minder.queryCommandState(\'italic\') === -1 || minder.execCommand(\'italic\')" ng-class="{\'font-italics-selected\' : minder.queryCommandState(\'italic\') == 1}" ng-disabled="minder.queryCommandState(\'italic\') === -1"></span><div class="font-color-wrap"><span class="quick-font-color" ng-click="minder.queryCommandState(\'forecolor\') === -1 || minder.execCommand(\'forecolor\', foreColor)" ng-disabled="minder.queryCommandState(\'forecolor\') === -1">A</span> <span color-picker class="font-color" set-color="setDefaultColor()" ng-disabled="minder.queryCommandState(\'forecolor\') === -1"><span class="caret"></span></span> <span class="font-color-preview" ng-style="{ \'background-color\': foreColor }" ng-click="minder.queryCommandState(\'forecolor\') === -1 || minder.execCommand(\'forecolor\', foreColor)" ng-disabled="minder.queryCommandState(\'forecolor\') === -1"></span></div><color-panel minder="minder" class="inline-directive"></color-panel></div>'),
        $templateCache.put("/res/mind/ui/directive/hyperLink/hyperLink.html", '<div class="btn-group-vertical" dropdown is-open="isopen"><button type="button" class="btn btn-default hyperlink" title="{{ \'link\' | lang:\'ui\' }}" ng-class="{\'active\': isopen}" ng-click="addHyperlink()" ng-disabled="minder.queryCommandState(\'HyperLink\') === -1"></button> <button type="button" class="btn btn-default hyperlink-caption dropdown-toggle" ng-disabled="minder.queryCommandState(\'HyperLink\') === -1" title="{{ \'link\' | lang:\'ui\' }}" dropdown-toggle><span class="caption">{{ \'link\' | lang:\'ui\' }}</span> <span class="caret"></span> <span class="sr-only">{{ \'link\' | lang:\'ui\' }}</span></button><ul class="dropdown-menu" role="menu"><li><a href ng-click="addHyperlink()">{{ \'insertlink\' | lang:\'ui\' }}</a></li><li><a href ng-click="minder.execCommand(\'HyperLink\', null)">{{ \'removelink\' | lang:\'ui\' }}</a></li></ul></div>'),
        $templateCache.put("/res/mind/ui/directive/imageBtn/imageBtn.html", '<div class="btn-group-vertical" dropdown is-open="isopen"><button type="button" class="btn btn-default image-btn" title="{{ \'image\' | lang:\'ui\' }}" ng-class="{\'active\': isopen}" ng-click="addImage()" ng-disabled="minder.queryCommandState(\'Image\') === -1"></button> <button type="button" class="btn btn-default image-btn-caption dropdown-toggle" ng-disabled="minder.queryCommandState(\'Image\') === -1" title="{{ \'image\' | lang:\'ui\' }}" dropdown-toggle><span class="caption">{{ \'image\' | lang:\'ui\' }}</span> <span class="caret"></span> <span class="sr-only">{{ \'image\' | lang:\'ui\' }}</span></button><ul class="dropdown-menu" role="menu"><li><a href ng-click="addImage()">{{ \'insertimage\' | lang:\'ui\' }}</a></li><li><a href ng-click="minder.execCommand(\'Image\', \'\')">{{ \'removeimage\' | lang:\'ui\' }}</a></li></ul></div>'),
        $templateCache.put("/res/mind/ui/directive/kityminderEditor/kityminderEditor.html", '<div class="minder-editor-container"><div class="top-tab" top-tab="minder" editor="editor" ng-if="minder"></div><div search-box minder="minder" ng-if="minder"></div><div class="minder-editor"></div><div class="km-note" note-editor minder="minder" ng-if="minder"></div><div class="note-previewer" note-previewer ng-if="minder"></div><div class="navigator" navigator minder="minder" ng-if="minder"></div></div>'),
        $templateCache.put("/res/mind/ui/directive/kityminderViewer/kityminderViewer.html", '<div class="minder-editor-container"><div class="minder-viewer"></div><div class="note-previewer" note-previewer ng-if="minder"></div><div class="navigator" navigator minder="minder" ng-if="minder"></div></div>'),
        $templateCache.put("/res/mind/ui/directive/layout/layout.html", '<div class="readjust-layout"><a ng-click="minder.queryCommandState(\'resetlayout\') === -1 || minder.execCommand(\'resetlayout\')" class="btn-wrap" ng-disabled="minder.queryCommandState(\'resetlayout\') === -1"><span class="btn-icon reset-layout-icon"></span> <span class="btn-label">{{ \'resetlayout\' | lang: \'ui/command\' }}</span></a></div>'),
        $templateCache.put("/res/mind/ui/directive/navigator/navigator.html", '<div class="nav-previewer" ng-show="isNavOpen"></div>'),
        $templateCache.put("/res/mind/ui/directive/noteBtn/noteBtn.html", '<div class="btn-group-vertical note-btn-group" dropdown is-open="isopen"><button type="button" class="btn btn-default note-btn" title="{{ \'note\' | lang:\'ui\' }}" ng-class="{\'active\': isopen}" ng-click="addNote()" ng-disabled="minder.queryCommandState(\'note\') === -1"></button> <button type="button" class="btn btn-default note-btn-caption dropdown-toggle" ng-disabled="minder.queryCommandState(\'note\') === -1" title="{{ \'note\' | lang:\'ui\' }}" dropdown-toggle><span class="caption">{{ \'note\' | lang:\'ui\' }}</span> <span class="caret"></span> <span class="sr-only">{{ \'note\' | lang:\'ui\' }}</span></button><ul class="dropdown-menu" role="menu"><li><a href ng-click="addNote()">{{ \'insertnote\' | lang:\'ui\' }}</a></li><li><a href ng-click="minder.execCommand(\'note\', null)">{{ \'removenote\' | lang:\'ui\' }}</a></li></ul></div>'),
        $templateCache.put("/res/mind/ui/directive/noteEditor/noteEditor.html", '<div class="panel panel-default" ng-init="noteEditorOpen = false" ng-show="noteEditorOpen"><div class="panel-heading"><h3 class="panel-title">备注</h3><span>（<a class="help" href="https://www.zybuluo.com/techird/note/46064" target="_blank">支持 GFM 语法书写</a>）</span> <i class="close-note-editor glyphicon glyphicon-remove" ng-click="closeNoteEditor()"></i></div><div class="panel-body"><div ng-show="noteEnabled" ui-codemirror="{ onLoad: codemirrorLoaded }" ng-model="noteContent" ui-codemirror-opts="{\n                gfm: true,\n                breaks: true,\n                lineWrapping : true,\n                mode: \'gfm\',\n                dragDrop: false,\n                lineNumbers:true\n             }"></div><p ng-show="!noteEnabled" class="km-note-tips">请选择节点编辑备注</p></div></div>'),
        $templateCache.put("/res/mind/ui/directive/notePreviewer/notePreviewer.html", '<div id="previewer-content" ng-show="showNotePreviewer" ng-style="previewerStyle" ng-bind-html="noteContent"></div>'),
        $templateCache.put("/res/mind/ui/directive/operation/operation.html", "<div class=\"km-btn-group operation-group\"><div class=\"km-btn-item edit-node\" ng-disabled=\"minder.queryCommandState('text') === -1\" ng-click=\"minder.queryCommandState('text') === -1 || editNode()\" title=\"{{ 'editnode' | lang:'ui/command' }}\"><i class=\"km-btn-icon\"></i> <span class=\"km-btn-caption\">{{ 'editnode' | lang:'ui/command' }}</span></div><div class=\"km-btn-item remove-node\" ng-disabled=\"minder.queryCommandState('RemoveNode') === -1\" ng-click=\"minder.queryCommandState('RemoveNode') === -1 || minder.execCommand('RemoveNode');\" title=\"{{ 'removenode' | lang:'ui/command' }}\"><i class=\"km-btn-icon\"></i> <span class=\"km-btn-caption\">{{ 'removenode' | lang:'ui/command' }}</span></div></div>"),
        $templateCache.put("/res/mind/ui/directive/priorityEditor/priorityEditor.html", '<ul class="km-priority tool-group" ng-disabled="commandDisabled"><li class="km-priority-item tool-group-item" ng-repeat="p in priorities" ng-click="commandDisabled || minder.execCommand(\'priority\', p)" ng-class="{ active: commandValue == p }" title="{{ getPriorityTitle(p) }}"><div class="km-priority-icon tool-group-icon priority-{{p}}"></div></li></ul>'),
        $templateCache.put("/res/mind/ui/directive/progressEditor/progressEditor.html", '<ul class="km-progress tool-group" ng-disabled="commandDisabled"><li class="km-progress-item tool-group-item" ng-repeat="p in progresses" ng-click="commandDisabled || minder.execCommand(\'progress\', p)" ng-class="{ active: commandValue == p }" title="{{ getProgressTitle(p) }}"><div class="km-progress-icon tool-group-icon progress-{{p}}"></div></li></ul>'),
        $templateCache.put("/res/mind/ui/directive/resourceEditor/resourceEditor.html", '<div class="resource-editor"><div class="input-group"><input class="form-control" type="text" ng-model="newResourceName" ng-required ng-keypress="$event.keyCode == 13 && addResource(newResourceName)" ng-disabled="!enabled"> <span class="input-group-btn"><button class="btn btn-default" ng-click="addResource(newResourceName)" ng-disabled="!enabled">添加</button></span></div><div class="resource-dropdown clearfix" id="resource-dropdown"><ul class="km-resource" ng-init="resourceListOpen = false" ng-class="{\'open\': resourceListOpen}"><li ng-repeat="resource in used" ng-disabled="!enabled" ng-blur="blurCB()"><label style="background: {{resourceColor(resource.name)}}"><input type="checkbox" ng-model="resource.selected" ng-disabled="!enabled"> <span>{{resource.name}}</span></label></li></ul><div class="resource-caret" click-anywhere-but-here="resourceListOpen = false" is-active="resourceListOpen" ng-click="resourceListOpen = !resourceListOpen"><span class="caret"></span></div></div></div>'),
        $templateCache.put("/res/mind/ui/directive/searchBox/searchBox.html", '<div id="search" class="search-box clearfix" ng-show="showSearch"><div class="input-group input-group-sm search-input-wrap"><input type="text" id="search-input" class="form-control search-input" ng-model="keyword" ng-keydown="handleKeyDown($event)" aria-describedby="basic-addon2"> <span class="input-group-addon search-addon" id="basic-addon2" ng-show="showTip" ng-bind="\'第 \' + curIndex + \' 条，共 \' + resultNum + \' 条\'"></span></div><div class="btn-group btn-group-sm prev-and-next-btn" role="group"><button type="button" class="btn btn-default" ng-click="doSearch(keyword, \'prev\')"><span class="glyphicon glyphicon-chevron-up"></span></button> <button type="button" class="btn btn-default" ng-click="doSearch(keyword, \'next\')"><span class="glyphicon glyphicon-chevron-down"></span></button></div><div class="close-search" ng-click="exitSearch()"><span class="glyphicon glyphicon-remove"></span></div></div>'),
        $templateCache.put("/res/mind/ui/directive/searchBtn/searchBtn.html", '<div class="btn-group-vertical" dropdown is-open="isopen"><button type="button" class="btn btn-default search" title="{{ \'search\' | lang:\'ui\' }}" ng-class="{\'active\': isopen}" ng-click="enterSearch()"></button> <button type="button" class="btn btn-default search-caption dropdown-toggle" ng-click="enterSearch()" title="{{ \'search\' | lang:\'ui\' }}"><span class="caption">{{ \'search\' | lang:\'ui\' }}</span> <span class="sr-only">{{ \'search\' | lang:\'ui\' }}</span></button></div>'),
        $templateCache.put("/res/mind/ui/directive/selectAll/selectAll.html", '<div class="btn-group-vertical" dropdown is-open="isopen"><button type="button" class="btn btn-default select" title="{{ \'selectall\' | lang:\'ui\' }}" ng-class="{\'active\': isopen}" ng-click="select[\'all\']()"></button> <button type="button" class="btn btn-default select-caption dropdown-toggle" title="{{ \'selectall\' | lang:\'ui\' }}" dropdown-toggle><span class="caption">{{ \'selectall\' | lang:\'ui\' }}</span> <span class="caret"></span> <span class="sr-only">{{ \'selectall\' | lang:\'ui\' }}</span></button><ul class="dropdown-menu" role="menu"><li ng-repeat="item in items"><a href ng-click="select[item]()">{{ \'select\' + item | lang:\'ui\' }}</a></li></ul></div>'),
        $templateCache.put("/res/mind/ui/directive/styleOperator/styleOperator.html", '<div class="style-operator"><a ng-click="minder.queryCommandState(\'clearstyle\') === -1 || minder.execCommand(\'clearstyle\')" class="btn-wrap clear-style" ng-disabled="minder.queryCommandState(\'clearstyle\') === -1"><span class="btn-icon clear-style-icon"></span> <span class="btn-label">{{ \'clearstyle\' | lang: \'ui\' }}</span></a><div class="s-btn-group-vertical"><a class="s-btn-wrap" href ng-click="minder.queryCommandState(\'copystyle\') === -1 || minder.execCommand(\'copystyle\')" ng-disabled="minder.queryCommandState(\'copystyle\') === -1"><span class="s-btn-icon copy-style-icon"></span> <span class="s-btn-label">{{ \'copystyle\' | lang: \'ui\' }}</span></a> <a class="s-btn-wrap paste-style-wrap" href ng-click="minder.queryCommandState(\'pastestyle\') === -1 || minder.execCommand(\'pastestyle\')" ng-disabled="minder.queryCommandState(\'pastestyle\') === -1"><span class="s-btn-icon paste-style-icon"></span> <span class="s-btn-label">{{ \'pastestyle\' | lang: \'ui\' }}</span></a></div></div>'),
        $templateCache.put("/res/mind/ui/directive/templateList/templateList.html", '<div class="dropdown temp-panel" dropdown on-toggle="toggled(open)"><div class="dropdown-toggle current-temp-item" ng-disabled="minder.queryCommandState(\'template\') === -1" dropdown-toggle><a href class="temp-item {{ minder.queryCommandValue(\'template\') }}" title="{{ minder.queryCommandValue(\'template\') | lang: \'template\' }}"></a> <span class="caret"></span></div><ul class="dropdown-menu temp-list"><li ng-repeat="(key, templateObj) in templateList" class="temp-item-wrap"><a ng-click="minder.execCommand(\'template\', key);" class="temp-item {{key}}" ng-class="{ \'temp-item-selected\' : key == minder.queryCommandValue(\'template\') }" title="{{ key | lang: \'template\' }}"></a></li></ul></div>'),
        $templateCache.put("/res/mind/ui/directive/themeList/themeList.html", '<div class="dropdown theme-panel" dropdown><div class="dropdown-toggle theme-item-selected" dropdown-toggle ng-disabled="minder.queryCommandState(\'theme\') === -1"><a href class="theme-item" ng-style="getThemeThumbStyle(minder.queryCommandValue(\'theme\'))" title="{{ minder.queryCommandValue(\'theme\') | lang: \'theme\'; }}">{{ minder.queryCommandValue(\'theme\') | lang: \'theme\'; }}</a> <span class="caret"></span></div><ul class="dropdown-menu theme-list"><li ng-repeat="key in themeKeyList" class="theme-item-wrap"><a ng-click="minder.execCommand(\'theme\', key);" class="theme-item" ng-style="getThemeThumbStyle(key)" title="{{ key | lang: \'theme\'; }}">{{ key | lang: \'theme\'; }}</a></li></ul></div>'),
        $templateCache.put("/res/mind/ui/directive/topTab/topTab.html", '<tabset><tab><undo-redo editor="editor"></undo-redo><append-node minder="minder"></append-node><arrange minder="minder"></arrange><operation minder="minder"></operation><style-operator minder="minder" class="inline-directive"></style-operator><font-operator minder="minder" class="inline-directive"></font-operator><hyper-link minder="minder"></hyper-link><image-btn minder="minder"></image-btn><note-btn minder="minder"></note-btn><priority-editor minder="minder"></priority-editor><progress-editor minder="minder"></progress-editor><template-list minder="minder" class="inline-directive"></template-list><theme-list minder="minder"></theme-list><layout minder="minder" class="inline-directive"></layout><expand-level minder="minder"></expand-level><select-all minder="minder"></select-all><search-btn minder="minder"></search-btn></tab></tasetb>'),
        $templateCache.put("/res/mind/ui/directive/undoRedo/undoRedo.html", '<div class="km-btn-group do-group"><div class="km-btn-item undo" ng-disabled="editor.history.hasUndo() == false" ng-click="editor.history.hasUndo() == false || editor.history.undo();" title="{{ \'undo\' | lang:\'ui\' }}"><i class="km-btn-icon"></i></div><div class="km-btn-item redo" ng-disabled="editor.history.hasRedo() == false" ng-click="editor.history.hasRedo() == false || editor.history.redo()" title="{{ \'redo\' | lang:\'ui\' }}"><i class="km-btn-icon"></i></div></div>'),
        $templateCache.put("/res/mind/ui/dialog/hyperlink/hyperlink.tpl.html", '<div class="modal-header"><h3 class="modal-title">链接</h3></div><div class="modal-body"><form><div class="form-group" id="link-url-wrap" ng-class="{true: \'has-success\', false: \'has-error\'}[urlPassed]"><label for="link-url">链接地址：</label><input type="text" class="form-control" ng-model="url" ng-blur="urlPassed = R_URL.test(url)" ng-focus="this.value = url" ng-keydown="shortCut($event)" id="link-url" placeholder="必填：以 http(s):// 或 ftp:// 开头"></div><div class="form-group" ng-class="{\'has-success\' : titlePassed}"><label for="link-title">提示文本：</label><input type="text" class="form-control" ng-model="title" ng-blur="titlePassed = true" id="link-title" placeholder="选填：鼠标在链接上悬停时提示的文本"></div></form></div><div class="modal-footer"><button class="btn btn-primary" ng-click="ok()">确定</button> <button class="btn btn-warning" ng-click="cancel()">取消</button></div>'),
        $templateCache.put("/res/mind/ui/dialog/imExportNode/imExportNode.tpl.html", '<div class="modal-header"><h3 class="modal-title">{{ title }}</h3></div><div class="modal-body"><textarea type="text" class="form-control single-input" rows="8" ng-keydown="shortCut($event);" ng-model="value" ng-readonly="type === \'export\'">\n    </textarea></div><div class="modal-footer"><button class="btn btn-primary" ng-click="ok()" ng-disabled="type === \'import\' && value == \'\'">OK</button> <button class="btn btn-warning" ng-click="cancel()">Cancel</button></div>'),
        $templateCache.put("/res/mind/ui/dialog/image/image.tpl.html", '<div class="modal-header"><h3 class="modal-title">图片</h3></div><div class="modal-body"><tabset><tab heading="图片搜索"><form class="form-inline"><div class="form-group"><label for="search-keyword">关键词：</label><input type="text" class="form-control" ng-model="data.searchKeyword2" id="search-keyword" placeholder="请输入搜索的关键词"></div><button class="btn btn-primary" ng-click="searchImage()">百度一下</button></form><div class="search-result" id="search-result"><ul><li ng-repeat="image in list" id="{{ \'img-item\' + $index }}" ng-class="{\'selected\' : isSelected}" ng-click="selectImage($event)"><img id="{{ \'img-\' + $index }}" ng-src="{{ image.src || \'\' }}" alt="{{ image.title }}" onerror="this.parentNode.removeChild(this)"> <span>{{ image.title }}</span></li></ul></div></tab><tab heading="外链图片" active="true"><form><div class="form-group" ng-class="{true: \'has-success\', false: \'has-error\'}[urlPassed]"><label for="image-url">链接地址：</label><input type="text" class="form-control" ng-model="data.url" ng-blur="urlPassed = data.R_URL.test(data.url)" ng-focus="this.value = data.url" ng-keydown="shortCut($event)" id="image-url" placeholder="必填：以 http(s):// 开头"></div><div class="form-group" ng-class="{\'has-success\' : titlePassed}"><label for="image-title">提示文本：</label><input type="text" class="form-control" ng-model="data.title" ng-blur="titlePassed = true" id="image-title" placeholder="选填：鼠标在图片上悬停时提示的文本"></div><div class="form-group"><label for="image-preview">图片预览：</label><img class="image-preview" id="image-preview" ng-src="{{ data.url }}" alt="{{ data.title }}"></div></form></tab></tabset></div><div class="modal-footer"><button class="btn btn-primary" ng-click="ok()">确定</button> <button class="btn btn-warning" ng-click="cancel()">取消</button></div>')
    }
    ]),
    angular.module("kityminderEditor").service("commandBinder", function() {
        return {
            bind: function(minder, command, scope) {
                minder.on("interactchange", function() {
                    scope.commandDisabled = -1 === minder.queryCommandState(command),
                    scope.commandValue = minder.queryCommandValue(command),
                    scope.$apply()
                })
            }
        }
    }),
    angular.module("kityminderEditor").provider("config", function() {
        this.config = {
            ctrlPanelMin: 250,
            ctrlPanelWidth: parseInt(window.localStorage.__dev_minder_ctrlPanelWidth) || 250,
            dividerWidth: 3,
            defaultLang: "zh-cn",
            zoom: [10, 20, 30, 50, 80, 100, 120, 150, 200],
            imageUpload: "server/imageUpload.php"
        },
        this.set = function(key, value) {
            var supported = Object.keys(this.config)
              , configObj = {};
            "object" == typeof key ? configObj = key : configObj[key] = value;
            for (var i in configObj) {
                if (!configObj.hasOwnProperty(i) || -1 === supported.indexOf(i))
                    return console.error("Unsupported config key: ", key, ", please choose in :", supported.join(", ")),
                    !1;
                this.config[i] = configObj[i]
            }
            return !0
        }
        ,
        this.$get = function() {
            var me = this;
            return {
                get: function(key) {
                    return 0 === arguments.length ? me.config : me.config.hasOwnProperty(key) ? me.config[key] : (console.warn("Missing config key pair for : ", key),
                    "")
                }
            }
        }
    }),
    angular.module("kityminderEditor").service("lang.zh-cn", function() {
        return {
            "zh-cn": {
                template: {
                    default: "思维导图",
                    tianpan: "天盘图",
                    structure: "组织结构图",
                    filetree: "目录组织图",
                    right: "逻辑结构图",
                    "fish-bone": "鱼骨头图"
                },
                theme: {
                    classic: "脑图经典",
                    "classic-compact": "紧凑经典",
                    snow: "温柔冷光",
                    "snow-compact": "紧凑冷光",
                    fish: "鱼骨图",
                    wire: "线框",
                    "fresh-red": "清新红",
                    "fresh-soil": "泥土黄",
                    "fresh-green": "文艺绿",
                    "fresh-blue": "天空蓝",
                    "fresh-purple": "浪漫紫",
                    "fresh-pink": "脑残粉",
                    "fresh-red-compat": "紧凑红",
                    "fresh-soil-compat": "紧凑黄",
                    "fresh-green-compat": "紧凑绿",
                    "fresh-blue-compat": "紧凑蓝",
                    "fresh-purple-compat": "紧凑紫",
                    "fresh-pink-compat": "紧凑粉",
                    tianpan: "经典天盘",
                    "tianpan-compact": "紧凑天盘"
                },
                maintopic: "中心主题",
                topic: "分支主题",
                panels: {
                    history: "历史",
                    template: "模板",
                    theme: "皮肤",
                    layout: "布局",
                    style: "样式",
                    font: "文字",
                    color: "颜色",
                    background: "背景",
                    insert: "插入",
                    arrange: "调整",
                    nodeop: "当前",
                    priority: "优先级",
                    progress: "进度",
                    resource: "资源",
                    note: "备注",
                    attachment: "附件",
                    word: "文字"
                },
                error_message: {
                    title: "哎呀，脑图出错了",
                    err_load: "加载脑图失败",
                    err_save: "保存脑图失败",
                    err_network: "网络错误",
                    err_doc_resolve: "文档解析失败",
                    err_unknown: "发生了奇怪的错误",
                    err_localfile_read: "文件读取错误",
                    err_download: "文件下载失败",
                    err_remove_share: "取消分享失败",
                    err_create_share: "分享失败",
                    err_mkdir: "目录创建失败",
                    err_ls: "读取目录失败",
                    err_share_data: "加载分享内容出错",
                    err_share_sync_fail: "分享内容同步失败",
                    err_move_file: "文件移动失败",
                    err_rename: "重命名失败",
                    unknownreason: "可能是外星人篡改了代码...",
                    pcs_code: {
                        31061: "文件已经存在",
                        31066: "文件不存在",
                        31067: "文件处理出错",
                        31071: "不能读取文件元信息",
                    }
                },
                ui: {
                    shared_file_title: "[分享的] {0} (只读)",
                    load_share_for_edit: "正在加载分享的文件...",
                    share_sync_success: "分享内容已同步",
                    recycle_clear_confirm: "确认清空回收站么？清空后的文件无法恢复。",
                    fullscreen_exit_hint: "按 Esc 或 F11 退出全屏",
                    error_detail: "详细信息",
                    copy_and_feedback: "复制并反馈",
                    move_file_confirm: '确定把 "{0}" 移动到 "{1}" 吗？',
                    rename: "重命名",
                    rename_success: "{0} 重命名成功",
                    move_success: "{0} 移动成功到 {1}",
                    command: {
                        appendsiblingnode: "插入同级主题",
                        // appendparentnode: "插入上级主题",
                        appendchildnode: "插入下级主题",
                        removenode: "删除",
                        editnode: "编辑",
                        arrangeup: "上移",
                        arrangedown: "下移",
                        resetlayout: "整理布局",
                        expandtoleaf: "展开全部节点",
                        expandtolevel1: "展开到一级节点",
                        expandtolevel2: "展开到二级节点",
                        expandtolevel3: "展开到三级节点",
                        expandtolevel4: "展开到四级节点",
                        expandtolevel5: "展开到五级节点",
                        expandtolevel6: "展开到六级节点",
                        fullscreen: "全屏",
                        outline: "大纲"
                    },
                    search: "搜索",
                    expandtoleaf: "展开",
                    back: "返回",
                    undo: "撤销 (Ctrl + Z)",
                    redo: "重做 (Ctrl + Y)",
                    // tabs: {
                    //     idea: "思路",
                    //     appearence: "外观",
                    //     view: "视图"
                    // },
                    quickvisit: {
                        new: "新建 (Ctrl + Alt + N)",
                        save: "保存 (Ctrl + S)",
                        share: "分享 (Ctrl + Alt + S)",
                        feedback: "反馈问题（F1）",
                        editshare: "编辑"
                    },
                    menu: {
                        mainmenutext: "百度脑图",
                        newtab: "新建",
                        opentab: "打开",
                        savetab: "保存",
                        sharetab: "分享",
                        preferencetab: "设置",
                        helptab: "帮助",
                        feedbacktab: "反馈",
                        recenttab: "最近使用",
                        netdisktab: "百度云存储",
                        localtab: "本地文件",
                        drafttab: "草稿箱",
                        downloadtab: "导出到本地",
                        createsharetab: "当前脑图",
                        managesharetab: "已分享",
                        newheader: "新建脑图",
                        openheader: "打开",
                        saveheader: "保存到",
                        draftheader: "草稿箱",
                        shareheader: "分享我的脑图",
                        downloadheader: "导出到指定格式",
                        preferenceheader: "偏好设置",
                        helpheader: "帮助",
                        feedbackheader: "反馈"
                    },
                    mydocument: "我的文档",
                    emptydir: "目录为空！",
                    pickfile: "选择文件...",
                    acceptfile: "支持的格式：{0}",
                    dropfile: "或将文件拖至此处",
                    unsupportedfile: "不支持的文件格式",
                    untitleddoc: "未命名文档",
                    overrideconfirm: "{0} 已存在，确认覆盖吗？",
                    checklogin: "检查登录状态中...",
                    loggingin: "正在登录...",
                    recent: "最近打开",
                    clearrecent: "清空",
                    clearrecentconfirm: "确认清空最近文档列表？",
                    cleardraft: "清空",
                    cleardraftconfirm: "确认清空草稿箱？",
                    none_share: "不分享",
                    public_share: "公开分享",
                    password_share: "私密分享",
                    email_share: "邮件邀请",
                    url_share: "脑图 URL 地址：",
                    sns_share: "社交网络分享：",
                    sns_share_text: "“{0}” - 我用百度脑图制作的思维导图，快看看吧！（地址：{1}）",
                    none_share_description: "不分享当前脑图",
                    public_share_description: "创建任何人可见的分享",
                    share_button_text: "创建",
                    password_share_description: "创建需要密码才可见的分享",
                    email_share_description: "创建指定人可见的分享，您还可以允许他们编辑",
                    ondev: "敬请期待！",
                    create_share_failed: "分享失败：{0}",
                    remove_share_failed: "删除失败：{1}",
                    copy: "复制",
                    copied: "已复制",
                    shared_tip: "当前脑图被 {0}  分享，你可以修改之后保存到自己的网盘上或再次分享",
                    current_share: "当前脑图",
                    manage_share: "我的分享",
                    share_remove_action: "不分享该脑图",
                    share_view_action: "打开分享地址",
                    share_edit_action: "编辑分享的文件",
                    login: "登录",
                    logout: "注销",
                    switchuser: "切换账户",
                    userinfo: "个人信息",
                    gotonetdisk: "我的网盘",
                    requirelogin: '请 <a class="login-button">登录</a> 后使用',
                    saveas: "保存为",
                    filename: "文件名",
                    fileformat: "保存格式",
                    save: "保存",
                    mkdir: "新建目录",
                    recycle: "回收站",
                    newdir: "未命名目录",
                    bold: "加粗",
                    italic: "斜体",
                    forecolor: "字体颜色",
                    fontfamily: "字体",
                    fontsize: "字号",
                    layoutstyle: "主题",
                    node: "节点操作",
                    saveto: "另存为",
                    hand: "允许拖拽",
                    camera: "定位根节点",
                    "zoom-in": "放大（Ctrl+）",
                    "zoom-out": "缩小（Ctrl-）",
                    markers: "标签",
                    resource: "资源",
                    help: "帮助",
                    preference: "偏好设置",
                    expandnode: "展开到叶子",
                    collapsenode: "收起到一级节点",
                    template: "模板",
                    theme: "皮肤",
                    clearstyle: "清除样式",
                    copystyle: "复制样式",
                    pastestyle: "粘贴样式",
                    appendsiblingnode: "同级主题",
                    appendchildnode: "下级主题",
                    arrangeup: "前调",
                    arrangedown: "后调",
                    editnode: "编辑",
                    removenode: "移除",
                    priority: "优先级",
                    progress: {
                        p1: "未开始",
                        p2: "完成 1/8",
                        p3: "完成 1/4",
                        p4: "完成 3/8",
                        p5: "完成一半",
                        p6: "完成 5/8",
                        p7: "完成 3/4",
                        p8: "完成 7/8",
                        p9: "已完成",
                        p0: "清除进度"
                    },
                    link: "链接",
                    image: "图片",
                    note: "备注",
                    insertlink: "插入链接",
                    insertimage: "插入图片",
                    insertnote: "插入备注",
                    removelink: "移除已有链接",
                    removeimage: "移除已有图片",
                    removenote: "移除已有备注",
                    resetlayout: "整理",
                    justnow: "刚刚",
                    minutesago: "{0} 分钟前",
                    hoursago: "{0} 小时前",
                    yesterday: "昨天",
                    daysago: "{0} 天前",
                    longago: "很久之前",
                    redirect: "您正在打开连接 {0}，百度脑图不能保证连接的安全性，是否要继续？",
                    navigator: "导航器",
                    unsavedcontent: "当前文件还没有保存到网盘：\n\n{0}\n\n虽然未保存的数据会缓存在草稿箱，但是清除浏览器缓存会导致草稿箱清除。",
                    shortcuts: "快捷键",
                    contact: "联系与反馈",
                    email: "邮件组",
                    qq_group: "QQ 群",
                    github_issue: "Github",
                    baidu_tieba: "贴吧",
                    clipboardunsupported: "您的浏览器不支持剪贴板，请使用快捷键复制",
                    load_success: "{0} 加载成功",
                    save_success: "{0} 已保存于 {1}",
                    autosave_success: "{0} 已自动保存于 {1}",
                    selectall: "全选",
                    selectrevert: "反选",
                    selectsiblings: "选择兄弟节点",
                    selectlevel: "选择同级节点",
                    selectpath: "选择路径",
                    selecttree: "选择子树"
                },
                popupcolor: {
                    clearColor: "清空颜色",
                    standardColor: "标准颜色",
                    themeColor: "主题颜色"
                },
                dialogs: {
                    markers: {
                        static: {
                            lang_input_text: "文本内容：",
                            lang_input_url: "链接地址：",
                            lang_input_title: "标题：",
                            lang_input_target: "是否在新窗口："
                        },
                        priority: "优先级",
                        none: "无",
                        progress: {
                            title: "进度",
                            notdone: "未完成",
                            done1: "完成 1/8",
                            done2: "完成 1/4",
                            done3: "完成 3/8",
                            done4: "完成 1/2",
                            done5: "完成 5/8",
                            done6: "完成 3/4",
                            done7: "完成 7/8",
                            done: "已完成"
                        }
                    },
                    help: {},
                    hyperlink: {},
                    image: {},
                    resource: {}
                },
                hyperlink: {
                    hyperlink: "链接...",
                    unhyperlink: "移除链接"
                },
                image: {
                    image: "图片...",
                    removeimage: "移除图片"
                },
                marker: {
                    marker: "进度/优先级..."
                },
                resource: {
                    resource: "资源..."
                }
            }
        }
    }),
    angular.module("kityminderEditor").service("memory", function() {
        function isQuotaExceeded(e) {
            var quotaExceeded = !1;
            if (e)
                if (e.code)
                    switch (e.code) {
                    case 22:
                        quotaExceeded = !0;
                        break;
                    case 1014:
                        "NS_ERROR_DOM_QUOTA_REACHED" === e.name && (quotaExceeded = !0)
                    }
                else
                    -2147024882 === e.number && (quotaExceeded = !0);
            return quotaExceeded
        }
        return {
            get: function(key) {
                var value = window.localStorage.getItem(key);
                return JSON.parse(value)
            },
            set: function(key, value) {
                try {
                    return window.localStorage.setItem(key, JSON.stringify(value)),
                    !0
                } catch (e) {
                    if (isQuotaExceeded(e))
                        return !1
                }
            },
            remove: function(key) {
                var value = window.localStorage.getItem(key);
                return window.localStorage.removeItem(key),
                value
            },
            clear: function() {
                window.localStorage.clear()
            }
        }
    }),
    angular.module("kityminderEditor").service("minder.service", function() {
        function registerEvent(callback) {
            callbackQueue.push(callback)
        }
        function executeCallback() {
            callbackQueue.forEach(function(ele) {
                ele.apply(this, arguments)
            })
        }
        var callbackQueue = [];
        return {
            registerEvent: registerEvent,
            executeCallback: executeCallback
        }
    }),
    angular.module("kityminderEditor").service("resourceService", ["$document", function($document) {
        var openScope = null;
        this.open = function(dropdownScope) {
            openScope || ($document.bind("click", closeDropdown),
            $document.bind("keydown", escapeKeyBind)),
            openScope && openScope !== dropdownScope && (openScope.resourceListOpen = !1),
            openScope = dropdownScope
        }
        ,
        this.close = function(dropdownScope) {
            openScope === dropdownScope && (openScope = null,
            $document.unbind("click", closeDropdown),
            $document.unbind("keydown", escapeKeyBind))
        }
        ;
        var closeDropdown = function(evt) {
            if (openScope) {
                var toggleElement = openScope.getToggleElement();
                evt && toggleElement && toggleElement[0].contains(evt.target) || openScope.$apply(function() {
                    console.log("to close the resourcelist"),
                    openScope.resourceListOpen = !1
                })
            }
        }
          , escapeKeyBind = function(evt) {
            27 === evt.which && (openScope.focusToggleElement(),
            closeDropdown())
        }
    }
    ]),
    angular.module("kityminderEditor").service("revokeDialog", ["$modal", "minder.service", function($modal, minderService) {
        return minderService.registerEvent(function() {
            var minder = window.minder
              , editor = window.editor
              , parentFSM = editor.hotbox.getParentFSM();
            minder.on("importNodeData", function() {
                parentFSM.jump("modal", "import-text-modal"),
                $modal.open({
                    animation: !0,
                    templateUrl: "/res/mind/ui/dialog/imExportNode/imExportNode.tpl.html",
                    controller: "imExportNode.ctrl",
                    size: "md",
                    resolve: {
                        title: function() {
                            return "导入节点"
                        },
                        defaultValue: function() {
                            return ""
                        },
                        type: function() {
                            return "import"
                        }
                    }
                }).result.then(function(result) {
                    try {
                        minder.Text2Children(minder.getSelectedNode(), result)
                    } catch (e) {
                        alert(e)
                    }
                    parentFSM.jump("normal", "import-text-finish"),
                    editor.receiver.selectAll()
                }, function() {
                    parentFSM.jump("normal", "import-text-finish"),
                    editor.receiver.selectAll()
                })
            }),
            minder.on("exportNodeData", function() {
                parentFSM.jump("modal", "export-text-modal"),
                $modal.open({
                    animation: !0,
                    templateUrl: "/res/mind/ui/dialog/imExportNode/imExportNode.tpl.html",
                    controller: "imExportNode.ctrl",
                    size: "md",
                    resolve: {
                        title: function() {
                            return "导出节点"
                        },
                        defaultValue: function() {
                            var selectedNode = minder.getSelectedNode();
                            return (0,
                            window.kityminder.data.getRegisterProtocol("text").Node2Text)(selectedNode)
                        },
                        type: function() {
                            return "export"
                        }
                    }
                }).result.then(function(result) {
                    parentFSM.jump("normal", "export-text-finish"),
                    editor.receiver.selectAll()
                }, function() {
                    parentFSM.jump("normal", "export-text-finish"),
                    editor.receiver.selectAll()
                })
            })
        }),
        {}
    }
    ]),
    angular.module("kityminderEditor").service("server", ["config", "$http", function(config, $http) {
        return {
            uploadImage: function(file) {
                var url = config.get("imageUpload")
                  , fd = new FormData;
                return fd.append("upload_file", file),
                $http.post(url, fd, {
                    transformRequest: angular.identity,
                    headers: {
                        "Content-Type": void 0
                    }
                })
            }
        }
    }
    ]),
    angular.module("kityminderEditor").service("valueTransfer", function() {
        return {}
    }),
    angular.module("kityminderEditor").filter("commandState", function() {
        return function(minder, command) {
            return minder.queryCommandState(command)
        }
    }).filter("commandValue", function() {
        return function(minder, command) {
            return minder.queryCommandValue(command)
        }
    }),
    angular.module("kityminderEditor").filter("lang", ["config", "lang.zh-cn", function(config, lang) {
        return function(text, block) {
            var defaultLang = config.get("defaultLang");
            if (void 0 == lang[defaultLang])
                return "未发现对应语言包，请检查 lang.xxx.service.js!";
            var dict = lang[defaultLang];
            return block.split("/").forEach(function(ele, idx) {
                dict = dict[ele]
            }),
            dict[text] || null
        }
    }
    ]),
    angular.module("kityminderEditor").controller("hyperlink.ctrl", ["$scope", "$modalInstance", "link", function($scope, $modalInstance, link) {
        $scope.R_URL = new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$","i"),
        $scope.url = link.url || "",
        $scope.title = link.title || "",
        setTimeout(function() {
            var $linkUrl = $("#link-url");
            $linkUrl.focus(),
            $linkUrl[0].setSelectionRange(0, $scope.url.length)
        }, 30),
        $scope.shortCut = function(e) {
            e.stopPropagation(),
            13 == e.keyCode ? $scope.ok() : 27 == e.keyCode && $scope.cancel()
        }
        ,
        $scope.ok = function() {
            if ($scope.R_URL.test($scope.url))
                $modalInstance.close({
                    url: $scope.url,
                    title: $scope.title
                });
            else {
                $scope.urlPassed = !1;
                var $linkUrl = $("#link-url");
                $linkUrl.focus(),
                $linkUrl[0].setSelectionRange(0, $scope.url.length)
            }
            editor.receiver.selectAll()
        }
        ,
        $scope.cancel = function() {
            $modalInstance.dismiss("cancel"),
            editor.receiver.selectAll()
        }
    }
    ]),
    angular.module("kityminderEditor").controller("imExportNode.ctrl", ["$scope", "$modalInstance", "title", "defaultValue", "type", function($scope, $modalInstance, title, defaultValue, type) {
        function getCursortPosition(ctrl) {
            var CaretPos = 0;
            if (document.selection) {
                ctrl.focus();
                var Sel = document.selection.createRange();
                Sel.moveStart("character", -ctrl.value.length),
                CaretPos = Sel.text.length
            } else
                (ctrl.selectionStart || "0" == ctrl.selectionStart) && (CaretPos = ctrl.selectionStart);
            return CaretPos
        }
        function setCaretPosition(ctrl, pos) {
            if (ctrl.setSelectionRange)
                ctrl.focus(),
                ctrl.setSelectionRange(pos, pos);
            else if (ctrl.createTextRange) {
                var range = ctrl.createTextRange();
                range.collapse(!0),
                range.moveEnd("character", pos),
                range.moveStart("character", pos),
                range.select()
            }
        }
        $scope.title = title,
        $scope.value = defaultValue,
        $scope.type = type,
        $scope.ok = function() {
            "" != $scope.value && ($modalInstance.close($scope.value),
            editor.receiver.selectAll())
        }
        ,
        $scope.cancel = function() {
            $modalInstance.dismiss("cancel"),
            editor.receiver.selectAll()
        }
        ,
        setTimeout(function() {
            $(".single-input").focus(),
            $(".single-input")[0].setSelectionRange(0, defaultValue.length)
        }, 30),
        $scope.shortCut = function(e) {
            if (e.stopPropagation(),
            27 == e.keyCode && $scope.cancel(),
            8 == e.keyCode && "export" == type && e.preventDefault(),
            9 == e.keyCode) {
                e.preventDefault();
                var $textarea = e.target
                  , pos = getCursortPosition($textarea)
                  , str = $textarea.value;
                $textarea.value = str.substr(0, pos) + "\t" + str.substr(pos),
                setCaretPosition($textarea, pos + 1)
            }
        }
    }
    ]),
    angular.module("kityminderEditor").controller("image.ctrl", ["$http", "$scope", "$modalInstance", "image", "server", function($http, $scope, $modalInstance, image, server) {
        function getImageData() {
            var key = $scope.data.searchKeyword2
              , currentTime = new Date
              , url = "http://image.baidu.com/search/acjson?tn=resultjson_com&ipn=rj&ct=201326592&fp=result&queryWord=" + key + "&cl=2&lm=-1&ie=utf-8&oe=utf-8&st=-1&ic=0&word=" + key + "&face=0&istype=2&nc=1&pn=60&rn=60&gsm=3c&" + currentTime.getTime() + "=&callback=JSON_CALLBACK";
            return $http.jsonp(url)
        }
        $scope.data = {
            list: [],
            url: image.url || "",
            title: image.title || "",
            R_URL: /^https?\:\/\/\w+/
        },
        setTimeout(function() {
            var $imageUrl = $("#image-url");
            $imageUrl.focus(),
            $imageUrl[0].setSelectionRange(0, $scope.data.url.length)
        }, 300),
        $scope.searchImage = function() {
            $scope.list = [],
            getImageData().success(function(json) {
                if (json && json.data)
                    for (var i = 0; i < json.data.length; i++)
                        json.data[i].objURL && $scope.list.push({
                            title: json.data[i].fromPageTitleEnc,
                            src: json.data[i].middleURL,
                            url: json.data[i].middleURL
                        })
            }).error(function() {})
        }
        ,
        $scope.selectImage = function($event) {
            var targetItem = $("#img-item" + this.$index)
              , targetImg = $("#img-" + this.$index);
            targetItem.siblings(".selected").removeClass("selected"),
            targetItem.addClass("selected"),
            $scope.data.url = targetImg.attr("src"),
            $scope.data.title = targetImg.attr("alt")
        }
        ,
        $scope.uploadImage = function() {
            var fileInput = $("#upload-image");
            if (fileInput.val()) {
                if (/^.*\.(jpg|JPG|jpeg|JPEG|gif|GIF|png|PNG)$/.test(fileInput.val())) {
                    var file = fileInput[0].files[0];
                    return server.uploadImage(file).then(function(json) {
                        var resp = json.data;
                        0 === resp.errno && ($scope.data.url = resp.data.url)
                    })
                }
                alert("后缀只能是 jpg、gif 及 png")
            }
        }
        ,
        $scope.shortCut = function(e) {
            e.stopPropagation(),
            13 == e.keyCode ? $scope.ok() : 27 == e.keyCode && $scope.cancel()
        }
        ,
        $scope.ok = function() {
            if ($scope.data.R_URL.test($scope.data.url))
                $modalInstance.close({
                    url: $scope.data.url,
                    title: $scope.data.title
                });
            else {
                $scope.urlPassed = !1;
                var $imageUrl = $("#image-url");
                $imageUrl && ($imageUrl.focus(),
                $imageUrl[0].setSelectionRange(0, $scope.data.url.length))
            }
            editor.receiver.selectAll()
        }
        ,
        $scope.cancel = function() {
            $modalInstance.dismiss("cancel"),
            editor.receiver.selectAll()
        }
    }
    ]),
    angular.module("kityminderEditor").directive("appendNode", ["commandBinder", function(commandBinder) {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/appendNode/appendNode.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                function editText() {
                    var receiverElement = editor.receiver.element
                      , fsm = editor.fsm
                      , receiver = editor.receiver;
                    receiverElement.innerText = minder.queryCommandValue("text"),
                    fsm.jump("input", "input-request"),
                    receiver.selectAll()
                }
                var minder = $scope.minder;
                commandBinder.bind(minder, "appendchildnode", $scope),
                $scope.execCommand = function(command) {
                    minder.execCommand(command, "分支主题"),
                    editText()
                }
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("arrange", ["commandBinder", function(commandBinder) {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/arrange/arrange.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                $scope.minder
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("colorPanel", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/colorPanel/colorPanel.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function(scope) {
                var minder = scope.minder;
                minder.getThemeItems();
                scope.$on("colorPicked", function(event, color) {
                    event.stopPropagation(),
                    scope.bgColor = color,
                    minder.execCommand("background", color)
                }),
                scope.setDefaultBg = function() {
                    var currentNode = minder.getSelectedNode()
                      , bgColor = minder.getNodeStyle(currentNode, "background");
                    return "object" == typeof bgColor ? bgColor.toHEX() : bgColor
                }
                ,
                scope.bgColor = scope.setDefaultBg() || "#fff"
            }
        }
    }),
    angular.module("kityminderEditor").directive("expandLevel", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/expandLevel/expandLevel.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                $scope.levels = [1, 2, 3, 4, 5, 6]
            }
        }
    }),
    angular.module("kityminderEditor").directive("fontOperator", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/fontOperator/fontOperator.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function(scope) {
                var minder = scope.minder;
                minder.getThemeItems();
                scope.fontSizeList = [10, 12, 16, 18, 24, 32, 48],
                scope.fontFamilyList = [{
                    name: "宋体",
                    val: "宋体,SimSun"
                }, {
                    name: "微软雅黑",
                    val: "微软雅黑,Microsoft YaHei"
                }, {
                    name: "楷体",
                    val: "楷体,楷体_GB2312,SimKai"
                }, {
                    name: "黑体",
                    val: "黑体, SimHei"
                }, {
                    name: "隶书",
                    val: "隶书, SimLi"
                }, {
                    name: "Andale Mono",
                    val: "andale mono"
                }, {
                    name: "Arial",
                    val: "arial,helvetica,sans-serif"
                }, {
                    name: "arialBlack",
                    val: "arial black,avant garde"
                }, {
                    name: "Comic Sans Ms",
                    val: "comic sans ms"
                }, {
                    name: "Impact",
                    val: "impact,chicago"
                }, {
                    name: "Times New Roman",
                    val: "times new roman"
                }, {
                    name: "Sans-Serif",
                    val: "sans-serif"
                }],
                scope.$on("colorPicked", function(event, color) {
                    event.stopPropagation(),
                    scope.foreColor = color,
                    minder.execCommand("forecolor", color)
                }),
                scope.setDefaultColor = function() {
                    var currentNode = minder.getSelectedNode()
                      , fontColor = minder.getNodeStyle(currentNode, "color");
                    return "object" == typeof fontColor ? fontColor.toHEX() : fontColor
                }
                ,
                scope.foreColor = scope.setDefaultColor() || "#000",
                scope.getFontfamilyName = function(val) {
                    var fontName = "";
                    return scope.fontFamilyList.forEach(function(ele, idx, arr) {
                        if (ele.val === val)
                            return fontName = ele.name,
                            ""
                    }),
                    fontName
                }
            }
        }
    }),
    angular.module("kityminderEditor").directive("hyperLink", ["$modal", function($modal) {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/hyperLink/hyperLink.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                var minder = $scope.minder;
                $scope.addHyperlink = function() {
                    var link = minder.queryCommandValue("HyperLink");
                    $modal.open({
                        animation: !0,
                        templateUrl: "/res/mind/ui/dialog/hyperlink/hyperlink.tpl.html",
                        controller: "hyperlink.ctrl",
                        size: "md",
                        resolve: {
                            link: function() {
                                return link
                            }
                        }
                    }).result.then(function(result) {
                        minder.execCommand("HyperLink", result.url, result.title || "")
                    })
                }
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("imageBtn", ["$modal", function($modal) {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/imageBtn/imageBtn.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                var minder = $scope.minder;
                $scope.addImage = function() {
                    var image = minder.queryCommandValue("image");
                    $modal.open({
                        animation: !0,
                        templateUrl: "/res/mind/ui/dialog/image/image.tpl.html",
                        controller: "image.ctrl",
                        size: "md",
                        resolve: {
                            image: function() {
                                return image
                            }
                        }
                    }).result.then(function(result) {
                        minder.execCommand("image", result.url, result.title || "")
                    })
                }
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("kityminderEditor", ["config", "minder.service", "revokeDialog", function(config, minderService, revokeDialog) {
        return {
            restrict: "EA",
            templateUrl: "/res/mind/ui/directive/kityminderEditor/kityminderEditor.html",
            replace: !0,
            scope: {
                onInit: "&"
            },
            link: function(scope, element, attributes) {
                function onInit(editor, minder) {
                    scope.onInit({
                        editor: editor,
                        minder: minder
                    }),
                    minderService.executeCallback()
                }
                var $minderEditor = element.children(".minder-editor")[0];
                if ("undefined" != typeof seajs)
                    seajs.config({
                        base: "/res/mind/src"
                    }),
                    define("demo", function(require) {
                        var Editor = require("editor")
                          , editor = window.editor = new Editor($minderEditor);
                        window.localStorage.__dev_minder_content && editor.minder.importJson(JSON.parse(window.localStorage.__dev_minder_content)),
                        editor.minder.on("contentchange", function() {
                            window.localStorage.__dev_minder_content = JSON.stringify(editor.minder.exportJson())
                        }),
                        window.minder = window.km = editor.minder,
                        scope.editor = editor,
                        scope.minder = minder,
                        scope.config = config.get(),
                        scope.$apply(),
                        onInit(editor, minder)
                    }),
                    seajs.use("demo");
                else if (window.kityminder && window.kityminder.Editor) {
                    var editor = new kityminder.Editor($minderEditor);
                    window.editor = scope.editor = editor,
                    window.minder = scope.minder = editor.minder,
                    scope.config = config.get(),
                    onInit(editor, editor.minder)
                }
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("kityminderViewer", ["config", "minder.service", function(config, minderService) {
        return {
            restrict: "EA",
            templateUrl: "/res/mind/ui/directive/kityminderViewer/kityminderViewer.html",
            replace: !0,
            scope: {
                onInit: "&"
            },
            link: function(scope, element, attributes) {
                var $minderEditor = element.children(".minder-viewer")[0];
                if (window.kityminder && window.kityminder.Editor) {
                    var editor = new kityminder.Editor($minderEditor);
                    window.editor = scope.editor = editor,
                    window.minder = scope.minder = editor.minder,
                    function(editor, minder) {
                        scope.onInit({
                            editor: editor,
                            minder: minder
                        }),
                        minderService.executeCallback()
                    }(editor, editor.minder)
                }
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("layout", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/layout/layout.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function(scope) {}
        }
    }),
    angular.module("kityminderEditor").directive("navigator", ["memory", "config", function(memory, config) {
        return {
            restrict: "A",
            templateUrl: "/res/mind/ui/directive/navigator/navigator.html",
            scope: {
                minder: "="
            },
            link: function(scope) {
                function bind() {
                    minder.on("layout layoutallfinish", updateContentView),
                    minder.on("viewchange", updateVisibleView)
                }
                function unbind() {
                    minder.off("layout layoutallfinish", updateContentView),
                    minder.off("viewchange", updateVisibleView)
                }
                function getPathHandler(theme) {
                    switch (theme) {
                    case "tianpan":
                    case "tianpan-compact":
                        return function(nodePathData, x, y, width, height) {
                            var r = width >> 1;
                            nodePathData.push("M", x, y + r, "a", r, r, 0, 1, 1, 0, .01, "z")
                        }
                        ;
                    default:
                        return function(nodePathData, x, y, width, height) {
                            nodePathData.push("M", x, y, "h", width, "v", height, "h", -width, "z")
                        }
                    }
                }
                function updateContentView() {
                    var view = minder.getRenderContainer().getBoundaryBox();
                    contentView = view;
                    paper.setViewBox(view.x - 30 - .5, view.y - 30 - .5, view.width + 60 + 1, view.height + 60 + 1);
                    var nodePathData = []
                      , connectionThumbData = [];
                    minder.getRoot().traverse(function(node) {
                        var box = node.getLayoutBox();
                        pathHandler(nodePathData, box.x, box.y, box.width, box.height),
                        node.getConnection() && node.parent && node.parent.isExpanded() && connectionThumbData.push(node.getConnection().getPathData())
                    }),
                    paper.setStyle("background", minder.getStyle("background")),
                    nodePathData.length ? nodeThumb.fill(minder.getStyle("root-background")).setPathData(nodePathData) : nodeThumb.setPathData(null),
                    connectionThumbData.length ? connectionThumb.stroke(minder.getStyle("connect-color"), "0.5%").setPathData(connectionThumbData) : connectionThumb.setPathData(null),
                    updateVisibleView()
                }
                function updateVisibleView() {
                    visibleView = minder.getViewDragger().getView(),
                    visibleRect.setBox(visibleView.intersect(contentView))
                }
                minder.setDefaultOptions({
                    zoom: config.get("zoom")
                }),
                scope.isNavOpen = !memory.get("navigator-hidden"),
                scope.getZoomRadio = function(value) {
                    var zoomStack = minder.getOption("zoom")
                      , minValue = zoomStack[0];
                    return 1 - (value - minValue) / (zoomStack[zoomStack.length - 1] - minValue)
                }
                ,
                scope.getHeight = function(value) {
                    var totalHeight = $(".zoom-pan").height();
                    return scope.getZoomRadio(value) * totalHeight
                }
                ,
                scope.zoom = 100,
                minder.on("zoom", function(e) {
                    scope.zoom = e.zoom
                }),
                scope.toggleNavOpen = function() {
                    scope.isNavOpen = !scope.isNavOpen,
                    memory.set("navigator-hidden", !scope.isNavOpen),
                    scope.isNavOpen ? (bind(),
                    updateContentView(),
                    updateVisibleView()) : unbind()
                }
                ,
                setTimeout(function() {
                    scope.isNavOpen ? (bind(),
                    updateContentView(),
                    updateVisibleView()) : unbind()
                }, 0);
                var $previewNavigator = $(".nav-previewer")
                  , paper = new kity.Paper($previewNavigator[0])
                  , nodeThumb = paper.put(new kity.Path)
                  , connectionThumb = paper.put(new kity.Path)
                  , visibleRect = paper.put(new kity.Rect(100,100).stroke("red", "1%"))
                  , contentView = new kity.Box
                  , visibleView = new kity.Box
                  , pathHandler = getPathHandler(minder.getTheme());
                minder.on("themechange", function(e) {
                    pathHandler = getPathHandler(e.theme)
                }),
                function() {
                    function moveView(center, duration) {
                        var box = visibleView;
                        center.x = -center.x,
                        center.y = -center.y,
                        box = minder.getPaper().getViewPortMatrix().transformBox(box);
                        var targetPosition = center.offset(box.width / 2, box.height / 2);
                        minder.getViewDragger().moveTo(targetPosition, duration)
                    }
                    var dragging = !1;
                    paper.on("mousedown", function(e) {
                        dragging = !0,
                        moveView(e.getPosition("top"), 200),
                        $previewNavigator.addClass("grab")
                    }),
                    paper.on("mousemove", function(e) {
                        dragging && moveView(e.getPosition("top"))
                    }),
                    $(window).on("mouseup", function() {
                        dragging = !1,
                        $previewNavigator.removeClass("grab")
                    })
                }()
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("noteBtn", ["valueTransfer", function(valueTransfer) {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/noteBtn/noteBtn.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                $scope.minder;
                $scope.addNote = function() {
                    valueTransfer.noteEditorOpen = !0
                }
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("noteEditor", ["valueTransfer", function(valueTransfer) {
        return {
            restrict: "A",
            templateUrl: "/res/mind/ui/directive/noteEditor/noteEditor.html",
            scope: {
                minder: "="
            },
            replace: !0,
            controller: ["$scope", function($scope) {
                function updateNote() {
                    var enabled = $scope.noteEnabled = -1 != minder.queryCommandState("note")
                      , noteValue = minder.queryCommandValue("note") || "";
                    enabled && ($scope.noteContent = noteValue),
                    isInteracting = !0,
                    $scope.$apply(),
                    isInteracting = !1
                }
                var cmEditor, minder = $scope.minder, isInteracting = !1;
                $scope.codemirrorLoaded = function(_editor) {
                    cmEditor = $scope.cmEditor = _editor,
                    _editor.setSize("100%", "100%")
                }
                ,
                $scope.$watch("noteContent", function(content) {
                    var enabled = -1 != minder.queryCommandState("note");
                    content && enabled && !isInteracting && minder.execCommand("note", content),
                    setTimeout(function() {
                        cmEditor.refresh()
                    })
                });
                var noteEditorOpen = function() {
                    return valueTransfer.noteEditorOpen
                };
                $scope.$watch(noteEditorOpen, function(newVal, oldVal) {
                    newVal && setTimeout(function() {
                        cmEditor.refresh(),
                        cmEditor.focus()
                    }),
                    $scope.noteEditorOpen = valueTransfer.noteEditorOpen
                }, !0),
                $scope.closeNoteEditor = function() {
                    valueTransfer.noteEditorOpen = !1,
                    editor.receiver.selectAll()
                }
                ,
                minder.on("interactchange", updateNote)
            }
            ]
        }
    }
    ]),
    angular.module("kityminderEditor").directive("notePreviewer", ["$sce", "valueTransfer", function($sce, valueTransfer) {
        return {
            restrict: "A",
            templateUrl: "/res/mind/ui/directive/notePreviewer/notePreviewer.html",
            link: function(scope, element) {
                function preview(node, keyword) {
                    var icon = node.getRenderer("NoteIconRenderer").getRenderShape()
                      , b = icon.getRenderBox("screen")
                      , note = node.getData("note");
                    $previewer[0].scrollTop = 0;
                    var html = marked(note);
                    keyword && (html = html.replace(new RegExp("(" + keyword + ")","ig"), '<span class="highlight">$1</span>')),
                    scope.noteContent = $sce.trustAsHtml(html),
                    scope.$apply();
                    var cw = $($container[0]).width()
                      , ch = $($container[0]).height()
                      , pw = $($previewer).outerWidth()
                      , ph = $($previewer).outerHeight()
                      , x = b.cx - pw / 2 - $container[0].offsetLeft
                      , y = b.bottom + 10 - $container[0].offsetTop;
                    x < 0 && (x = 10),
                    x + pw > cw && (x = b.left - pw - 10 - $container[0].offsetLeft),
                    y + ph > ch && (y = b.top - ph - 10 - $container[0].offsetTop),
                    scope.previewerStyle = {
                        left: Math.round(x) + "px",
                        top: Math.round(y) + "px"
                    },
                    scope.showNotePreviewer = !0;
                    var view = $previewer[0].querySelector(".highlight");
                    view && view.scrollIntoView(),
                    previewLive = !0,
                    scope.$apply()
                }
                var minder = scope.minder
                  , $container = element.parent()
                  , $previewer = element.children();
                scope.showNotePreviewer = !1,
                marked.setOptions({
                    gfm: !0,
                    tables: !0,
                    breaks: !0,
                    pedantic: !1,
                    sanitize: !0,
                    smartLists: !0,
                    smartypants: !1
                });
                var previewTimer;
                minder.on("shownoterequest", function(e) {
                    previewTimer = setTimeout(function() {
                        preview(e.node, e.keyword)
                    }, 300)
                }),
                minder.on("hidenoterequest", function() {
                    clearTimeout(previewTimer),
                    scope.showNotePreviewer = !1
                });
                var previewLive = !1;
                $(document).on("mousedown mousewheel DOMMouseScroll", function() {
                    previewLive && (scope.showNotePreviewer = !1,
                    scope.$apply())
                }),
                element.on("mousedown mousewheel DOMMouseScroll", function(e) {
                    e.stopPropagation()
                })
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("operation", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/operation/operation.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                $scope.editNode = function() {
                    var receiverElement = editor.receiver.element
                      , fsm = editor.fsm
                      , receiver = editor.receiver;
                    receiverElement.innerText = minder.queryCommandValue("text"),
                    fsm.jump("input", "input-request"),
                    receiver.selectAll()
                }
            }
        }
    }),
    angular.module("kityminderEditor").directive("priorityEditor", ["commandBinder", function(commandBinder) {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/priorityEditor/priorityEditor.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                for (var minder = $scope.minder, priorities = [], i = 0; i < 10; i++)
                    priorities.push(i);
                commandBinder.bind(minder, "priority", $scope),
                $scope.priorities = priorities,
                $scope.getPriorityTitle = function(p) {
                    switch (p) {
                    case 0:
                        return "移除优先级";
                    default:
                        return "优先级" + p
                    }
                }
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("progressEditor", ["commandBinder", function(commandBinder) {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/progressEditor/progressEditor.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                for (var minder = $scope.minder, progresses = [], i = 0; i < 10; i++)
                    progresses.push(i);
                commandBinder.bind(minder, "progress", $scope),
                $scope.progresses = progresses,
                $scope.getProgressTitle = function(p) {
                    switch (p) {
                    case 0:
                        return "移除进度";
                    case 1:
                        return "未开始";
                    case 9:
                        return "全部完成";
                    default:
                        return "完成" + (p - 1) + "/8"
                    }
                }
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("resourceEditor", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/resourceEditor/resourceEditor.html",
            scope: {
                minder: "="
            },
            replace: !0,
            controller: ["$scope", function($scope) {
                var minder = $scope.minder
                  , isInteracting = !1;
                minder.on("interactchange", function() {
                    var enabled = $scope.enabled = -1 != minder.queryCommandState("resource")
                      , selected = enabled ? minder.queryCommandValue("resource") : []
                      , used = minder.getUsedResource().map(function(resourceName) {
                        return {
                            name: resourceName,
                            selected: selected.indexOf(resourceName) > -1
                        }
                    });
                    $scope.used = used,
                    isInteracting = !0,
                    $scope.$apply(),
                    isInteracting = !1
                }),
                $scope.$watch("used", function(used) {
                    if (-1 != minder.queryCommandState("resource") && used) {
                        var resource = used.filter(function(resource) {
                            return resource.selected
                        }).map(function(resource) {
                            return resource.name
                        });
                        if (isInteracting)
                            return;
                        minder.execCommand("resource", resource)
                    }
                }, !0),
                $scope.resourceColor = function(resource) {
                    return minder.getResourceColor(resource).toHEX()
                }
                ,
                $scope.addResource = function(resourceName) {
                    var origin = minder.queryCommandValue("resource");
                    resourceName && /\S/.test(resourceName) && (-1 == origin.indexOf(resourceName) && $scope.used.push({
                        name: resourceName,
                        selected: !0
                    }),
                    $scope.newResourceName = null)
                }
            }
            ]
        }
    }).directive("clickAnywhereButHere", ["$document", function($document) {
        return {
            link: function(scope, element, attrs) {
                var onClick = function(event) {
                    var isChild = $("#resource-dropdown").has(event.target).length > 0
                      , isSelf = $("#resource-dropdown") == event.target;
                    isChild || isSelf || scope.$apply(attrs.clickAnywhereButHere)
                };
                scope.$watch(attrs.isActive, function(newValue, oldValue) {
                    newValue !== oldValue && 1 == newValue ? $document.bind("click", onClick) : newValue !== oldValue && 0 == newValue && $document.unbind("click", onClick)
                })
            }
        }
    }
    ]),
    angular.module("kityminderEditor").directive("searchBox", function() {
        return {
            restrict: "A",
            templateUrl: "/res/mind/ui/directive/searchBox/searchBox.html",
            scope: {
                minder: "="
            },
            replace: !0,
            controller: ["$scope", function($scope) {
                function handleKeyDown(e) {
                    if (13 == e.keyCode) {
                        var direction = e.shiftKey ? "prev" : "next";
                        doSearch($scope.keyword, direction)
                    }
                    27 == e.keyCode && exitSearch()
                }
                function exitSearch() {
                    $("#search-input").blur(),
                    $scope.showSearch = !1,
                    minder.fire("hidenoterequest"),
                    editor.receiver.selectAll()
                }
                function enterSearch() {
                    $scope.showSearch = !0,
                    setTimeout(function() {
                        $("#search-input").focus()
                    }, 10),
                    $scope.keyword && $("#search-input")[0].setSelectionRange(0, $scope.keyword.length)
                }
                function makeNodeSequence() {
                    nodeSequence = [],
                    minder.getRoot().traverse(function(node) {
                        nodeSequence.push(node)
                    })
                }
                function makeSearchSequence(keyword) {
                    searchSequence = [];
                    for (var i = 0; i < nodeSequence.length; i++) {
                        var node = nodeSequence[i];
                        -1 != node.getText().toLowerCase().indexOf(keyword) && searchSequence.push({
                            node: node
                        });
                        var note = node.getData("note");
                        note && -1 != note.toLowerCase().indexOf(keyword) && searchSequence.push({
                            node: node,
                            keyword: keyword
                        })
                    }
                }
                function doSearch(keyword, direction) {
                    if ($scope.showTip = !1,
                    minder.fire("hidenoterequest"),
                    !keyword || !/\S/.exec(keyword))
                        return void $("#search-input").focus();
                    $scope.showTip = !0,
                    $scope.curIndex = 0,
                    $scope.resultNum = 0,
                    keyword = keyword.toLowerCase();
                    var newSearch = doSearch.lastKeyword != keyword;
                    if (doSearch.lastKeyword = keyword,
                    newSearch && makeSearchSequence(keyword),
                    $scope.resultNum = searchSequence.length,
                    searchSequence.length) {
                        var curIndex = newSearch ? 0 : ("next" === direction ? doSearch.lastIndex + 1 : doSearch.lastIndex - 1) || 0;
                        curIndex = (searchSequence.length + curIndex) % searchSequence.length,
                        function(node, previewKeyword) {
                            minder.execCommand("camera", node, 50),
                            setTimeout(function() {
                                minder.select(node, !0),
                                node.isExpanded() || minder.execCommand("expand", !0),
                                previewKeyword && minder.fire("shownoterequest", {
                                    node: node,
                                    keyword: previewKeyword
                                })
                            }, 60)
                        }(searchSequence[curIndex].node, searchSequence[curIndex].keyword),
                        doSearch.lastIndex = curIndex,
                        $scope.curIndex = curIndex + 1
                    }
                }
                var minder = $scope.minder
                  , editor = window.editor;
                $scope.handleKeyDown = handleKeyDown,
                $scope.doSearch = doSearch,
                $scope.exitSearch = exitSearch,
                $scope.showTip = !1,
                $scope.showSearch = !1,
                $("body").on("keydown", function(e) {
                    70 != e.keyCode || !e.ctrlKey && !e.metaKey || e.shiftKey || (enterSearch(),
                    $scope.$apply(),
                    e.preventDefault())
                }),
                minder.on("searchNode", function() {
                    enterSearch()
                });
                var nodeSequence = []
                  , searchSequence = [];
                minder.on("contentchange", makeNodeSequence),
                makeNodeSequence()
            }
            ]
        }
    }),
    angular.module("kityminderEditor").directive("searchBtn", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/searchBtn/searchBtn.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function(scope) {
                function enterSearch() {
                    minder.fire("searchNode")
                }
                scope.enterSearch = enterSearch
            }
        }
    }),
    angular.module("kityminderEditor").directive("selectAll", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/selectAll/selectAll.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                var minder = $scope.minder;
                $scope.items = ["revert", "siblings", "level", "path", "tree"],
                $scope.select = {
                    all: function() {
                        var selection = [];
                        minder.getRoot().traverse(function(node) {
                            selection.push(node)
                        }),
                        minder.select(selection, !0),
                        minder.fire("receiverfocus")
                    },
                    revert: function() {
                        var selected = minder.getSelectedNodes()
                          , selection = [];
                        minder.getRoot().traverse(function(node) {
                            -1 == selected.indexOf(node) && selection.push(node)
                        }),
                        minder.select(selection, !0),
                        minder.fire("receiverfocus")
                    },
                    siblings: function() {
                        var selected = minder.getSelectedNodes()
                          , selection = [];
                        selected.forEach(function(node) {
                            node.parent && node.parent.children.forEach(function(sibling) {
                                -1 == selection.indexOf(sibling) && selection.push(sibling)
                            })
                        }),
                        minder.select(selection, !0),
                        minder.fire("receiverfocus")
                    },
                    level: function() {
                        var selectedLevel = minder.getSelectedNodes().map(function(node) {
                            return node.getLevel()
                        })
                          , selection = [];
                        minder.getRoot().traverse(function(node) {
                            -1 != selectedLevel.indexOf(node.getLevel()) && selection.push(node)
                        }),
                        minder.select(selection, !0),
                        minder.fire("receiverfocus")
                    },
                    path: function() {
                        var selected = minder.getSelectedNodes()
                          , selection = [];
                        selected.forEach(function(node) {
                            for (; node && -1 == selection.indexOf(node); )
                                selection.push(node),
                                node = node.parent
                        }),
                        minder.select(selection, !0),
                        minder.fire("receiverfocus")
                    },
                    tree: function() {
                        var selected = minder.getSelectedNodes()
                          , selection = [];
                        selected.forEach(function(parent) {
                            parent.traverse(function(node) {
                                -1 == selection.indexOf(node) && selection.push(node)
                            })
                        }),
                        minder.select(selection, !0),
                        minder.fire("receiverfocus")
                    }
                }
            }
        }
    }),
    angular.module("kityminderEditor").directive("styleOperator", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/styleOperator/styleOperator.html",
            scope: {
                minder: "="
            },
            replace: !0
        }
    }),
    angular.module("kityminderEditor").directive("templateList", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/templateList/templateList.html",
            scope: {
                minder: "="
            },
            replace: !0,
            link: function($scope) {
                $scope.templateList = kityminder.Minder.getTemplateList()
            }
        }
    }),
    angular.module("kityminderEditor").directive("themeList", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/themeList/themeList.html",
            replace: !0,
            link: function($scope) {
                var themeList = kityminder.Minder.getThemeList();
                $scope.getThemeThumbStyle = function(theme) {
                    var themeObj = themeList[theme];
                    if (themeObj) {
                        var style = {
                            color: themeObj["root-color"],
                            "border-radius": themeObj["root-radius"] / 2
                        };
                        return themeObj["root-background"] && (style.background = themeObj["root-background"].toString()),
                        style
                    }
                }
                ,
                $scope.themeKeyList = ["classic", "classic-compact", "fresh-blue", "fresh-blue-compat", "fresh-green", "fresh-green-compat", "fresh-pink", "fresh-pink-compat", "fresh-purple", "fresh-purple-compat", "fresh-red", "fresh-red-compat", "fresh-soil", "fresh-soil-compat", "snow", "snow-compact", "tianpan", "tianpan-compact", "fish", "wire"]
            }
        }
    }),
    angular.module("kityminderEditor").directive("topTab", function() {
        return {
            restrict: "A",
            templateUrl: "/res/mind/ui/directive/topTab/topTab.html",
            scope: {
                minder: "=topTab",
                editor: "="
            },
            link: function(scope) {
                function closeTopTab() {
                    var $tabContent = $(".tab-content")
                      , $minderEditor = $(".minder-editor");
                    $tabContent.animate({
                        height: 0,
                        display: "none"
                    }),
                    $minderEditor.animate({
                        top: "32px"
                    })
                }
                function openTopTab() {
                    var $tabContent = $(".tab-content")
                      , $minderEditor = $(".minder-editor");
                    $tabContent.animate({
                        height: "60px",
                        display: "block"
                    }),
                    $minderEditor.animate({
                        top: "92px"
                    })
                }
                var executedCurTab = !1
                  , isInit = !0
                  , isOpen = !0;
                scope.setCurTab = function(tabName) {
                    setTimeout(function() {
                        executedCurTab = !0,
                        "idea" != tabName && (isInit = !1)
                    })
                }
                ,
                scope.toggleTopTab = function() {
                    setTimeout(function() {
                        executedCurTab && !isInit || (isInit = !1,
                        isOpen ? closeTopTab() : openTopTab(),
                        isOpen = !isOpen),
                        executedCurTab = !1
                    })
                }
            }
        }
    }),
    angular.module("kityminderEditor").directive("undoRedo", function() {
        return {
            restrict: "E",
            templateUrl: "/res/mind/ui/directive/undoRedo/undoRedo.html",
            scope: {
                editor: "="
            },
            replace: !0,
            link: function($scope) {}
        }
    }),
    function(name) {
        _p.r([moduleMapping[name]])
    }("expose-editor")
}();
var Cookie = {
    isString: function(o) {
        return "string" == typeof o
    },
    isNonEmptyString: function(s) {
        return this.isString(s) && "" !== s
    },
    validateCookieName: function(name) {
        if (!this.isNonEmptyString(name))
            throw new TypeError("Cookie name must be a non-empty string")
    },
    same: function(s) {
        return s
    },
    parseCookieString: function(text, shouldDecode) {
        var cookies = {};
        if (this.isString(text) && text.length > 0)
            for (var cookieName, cookieValue, cookieNameValue, decodeValue = shouldDecode ? decodeURIComponent : this.same, cookieParts = text.split(/;\s/g), i = 0, len = cookieParts.length; i < len; i++) {
                if ((cookieNameValue = cookieParts[i].match(/([^=]+)=/i))instanceof Array)
                    try {
                        cookieName = decodeURIComponent(cookieNameValue[1]),
                        cookieValue = decodeValue(cookieParts[i].substring(cookieNameValue[1].length + 1))
                    } catch (ex) {}
                else
                    cookieName = decodeURIComponent(cookieParts[i]),
                    cookieValue = "";
                cookieName && (cookies[cookieName] = cookieValue)
            }
        return cookies
    },
    read: function(name, options) {
        this.validateCookieName(name),
        options = "function" == typeof options ? {
            converter: options
        } : options || {};
        var cookies = this.parseCookieString(document.cookie, !options.raw);
        return (options.converter || this.same)(cookies[name])
    },
    write: function(name, value, options) {
        this.validateCookieName(name),
        options = options || {};
        var expires = options.expires;
        void 0 === expires && (expires = 30);
        var domain = options.domain || document.domain
          , path = options.path || "/";
        options.raw || (value = encodeURIComponent(String(value)));
        var text = name + "=" + value
          , date = expires;
        return "number" == typeof date && (date = new Date,
        date.setDate(date.getDate() + expires)),
        date instanceof Date && (text += "; expires=" + date.toUTCString()),
        this.isNonEmptyString(domain) && (text += "; domain=" + domain),
        this.isNonEmptyString(path) && (text += "; path=" + path),
        options.secure && (text += "; secure"),
        document.cookie = text,
        text
    },
    remove: function(name, options) {
        return options = options || {},
        options.expires = new Date(0),
        this.set(name, "", options)
    }
}
  , timeoutInt = 0
  , oldValue = null;
angular.module("kityminderDemo", ["kityminderEditor"]).controller("MainController", function($scope) {
    $scope.initEditor = function(editor, minder) {
        function save() {
            if (!is_share) {return;}
            var value = minder.exportData("json").fulfillValue
              , newJson = JSON.parse(value)
              , oldJson = JSON.parse(mindData);
            if (noDelete(newJson, oldJson)) {
                var f = diff(newJson, oldJson);
                if (Object.keys(f).length > 0 && oldJson && oldJson.root && oldJson.root.data && (f.root && f.root.data ? f.root.data.id = oldJson.root.data.id : f.root ? f.root.data = {
                    id: oldJson.root.data.id
                } : f.root = {
                    data: {
                        id: oldJson.root.data.id
                    }
                }),
                0 === Object.keys(f).length)
                    return;
            }
            window.parent.document.querySelectorAll('.window.xmind>.titbar>span>.save-status')[0].innerText = "正在保存..."
            $.ajax({
                url: servers + '/file/save',
                type: "POST",
                // headers: {"X-CSRFToken": Cookie.read("csrfToken")},
                contentType: 'application/json',
                data: JSON.stringify({
                    id: file_id,
                    version: version,
                    data: value
                }),
                success: function(result) {
                    0 === result.code ? (
                    window.parent.document.querySelectorAll('.window.xmind>.titbar>span>.save-status')[0].innerText = window.parent.get_current_time() + " 已保存",
                    parseInt(result.code) > parseInt(version) + 1 ? (alert("此文件已经产生更新版本"),
                    location.reload()) : (version = result.code,
                    mindData = value)) : window.parent.document.querySelectorAll('.window.xmind>.titbar>span>.save-status')[0].innerText = "保存失败! " + result.msg
                },
                error: function(e) {
                    window.parent.document.querySelectorAll('.window.xmind>.titbar>span>.save-status')[0].innerText = "保存失败，请检查网络并重试..."
                }
            })
        }
        function diff(source, base) {
            if (!base)
                return source;
            var dif = {}
              , array = !1;
            if (source instanceof Array && (dif = [],
            array = !0),
            array) {
                if (source.length > 0) {
                    if (!source[0].data || !source[0].data.id) {
                        var allSame = !0;
                        if (source.length === base.length)
                            for (var i = 0; i < source.length; i++)
                                source[i] !== base[i] && (allSame = !1);
                        else
                            allSame = !1;
                        return allSame ? [] : source
                    }
                    for (var key in source) {
                        var d = source[key];
                        if ("object" == typeof d) {
                            var foundKey, exist = !1;
                            for (var key2 in base)
                                if (d.data.id == base[key2].data.id) {
                                    foundKey = key2,
                                    exist = !0;
                                    var f = diff(d, base[foundKey]);
                                    Object.keys(f).length > 0 && (f.data ? f.data.id = d.data.id : f.data = {
                                        id: d.data.id
                                    },
                                    dif.push(f));
                                    break
                                }
                            if (!exist) {
                                var f = d;
                                Object.keys(f).length > 0 && dif.push(f)
                            }
                        } else
                            dif.push(d)
                    }
                }
            } else
                for (var k in source) {
                    var dd = source[k];
                    if ("object" == typeof base[k]) {
                        if (dd) {
                            var f = diff(dd, base[k]);
                            Object.keys(f).length > 0 && (dif[k] = f)
                        }
                    } else
                        dd !== base[k] && (dif[k] = dd)
                }
            return dif
        }
        function noDelete(source, base) {
            for (var key in base) {
                if (void 0 === source[key])
                    return !1;
                if ("object" == typeof base[key] && !noDelete(source[key], base[key]))
                    return !1
            }
            return !0
        }
        function autoSave() {
            oldValue !== minder.exportData("json").fulfillValue && save(),
            timeoutInt && clearTimeout(timeoutInt),
            timeoutInt = setTimeout(autoSave, 1e4)
        }
        window.editor = editor,
        window.minder = minder,
        function() {
            mindData && editor.minder.importData("json", mindData),
            timeoutInt = setTimeout(autoSave, 15e3)
        }()
    }
    let div_node = document.createElement('div');
    div_node.className='btn-group-vertical';
    div_node.innerHTML = `<button type="button" class="btn btn-default search-caption dropdown-toggle" onclick="window.open('${export_url}')" title="导出为xmind8格式" style="height:100%;"><span class="caption ng-binding" style="white-space:break-spaces;">导出为xmind8</span></button>`;
    setTimeout(()=>{document.querySelectorAll('.tab-pane.ng-scope')[0].appendChild(div_node)}, 3000);
});
function close_xmind_editor(file_id) {
    window.parent.document.querySelectorAll('.window.xmind>.titbar>span>.save-status')[0].innerText = "正在保存...";
    window.parent.save_text_file(file_id, minder.exportData("json").fulfillValue, false);
    window.parent.document.querySelectorAll('.window.xmind>.titbar>span>.save-status')[0].innerText = "";
    window.parent.document.getElementsByClassName("xmind")[0].style.display = 'none';
    window.parent.document.getElementById("iframe_xmind").src = 'about:blank';
}